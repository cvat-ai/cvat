diff --git a/.vscode/launch.json b/.vscode/launch.json
index d5c2a9ad9..aa8125b9f 100644
--- a/.vscode/launch.json
+++ b/.vscode/launch.json
@@ -524,7 +524,22 @@
             "console": "integratedTerminal",
             "internalConsoleOptions": "neverOpen",
             "disableOptimisticBPs": true,
-        }
+        },
+        {
+            "name": "Serverless Debug",
+            "type": "python",
+            "request": "attach",
+            "connect": {
+              "host": "localhost",
+              "port": 5678
+            },
+            "pathMappings": [
+              {
+                "localRoot": "${workspaceFolder}/serverless/pytorch/omerferhatt/xmem/nuclio",
+                "remoteRoot": "/opt/nuclio"
+              }
+            ]
+          }
     ],
     "compounds": [
         {
diff --git a/cvat-ui/src/components/annotation-page/standard-workspace/controls-side-bar/tools-control.tsx b/cvat-ui/src/components/annotation-page/standard-workspace/controls-side-bar/tools-control.tsx
index fd230f5f8..a190ceea5 100644
--- a/cvat-ui/src/components/annotation-page/standard-workspace/controls-side-bar/tools-control.tsx
+++ b/cvat-ui/src/components/annotation-page/standard-workspace/controls-side-bar/tools-control.tsx
@@ -145,6 +145,7 @@ interface State {
     activeLabelID: number;
     activeTracker: MLModel | null;
     convertMasksToPolygons: boolean;
+    selectedObjectType: ObjectType;
     trackedShapes: TrackedShape[];
     fetching: boolean;
     pointsReceived: boolean;
@@ -153,23 +154,23 @@ interface State {
     portals: React.ReactPortal[];
 }
 
-function trackedRectangleMapper(shape: number[]): number[] {
-    return shape.reduce(
-        (acc: number[], value: number, index: number): number[] => {
-            if (index % 2) {
-                // y
-                acc[1] = Math.min(acc[1], value);
-                acc[3] = Math.max(acc[3], value);
-            } else {
-                // x
-                acc[0] = Math.min(acc[0], value);
-                acc[2] = Math.max(acc[2], value);
-            }
-            return acc;
-        },
-        [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER],
-    );
-}
+// function trackedRectangleMapper(shape: number[]): number[] {
+//     return shape.reduce(
+//         (acc: number[], value: number, index: number): number[] => {
+//             if (index % 2) {
+//                 // y
+//                 acc[1] = Math.min(acc[1], value);
+//                 acc[3] = Math.max(acc[3], value);
+//             } else {
+//                 // x
+//                 acc[0] = Math.min(acc[0], value);
+//                 acc[2] = Math.max(acc[2], value);
+//             }
+//             return acc;
+//         },
+//         [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER],
+//     );
+// }
 
 function registerPlugin(): (callback: null | (() => void)) => void {
     let onTrigger: null | (() => void) = null;
@@ -230,6 +231,7 @@ export class ToolsControlComponent extends React.PureComponent<Props, State> {
         super(props);
         this.state = {
             convertMasksToPolygons: false,
+            selectedObjectType: ObjectType.SHAPE,
             activeInteractor: props.interactors.length ? props.interactors[0] : null,
             activeTracker: props.trackers.length ? props.trackers[0] : null,
             activeLabelID: props.labels.length ? props.labels[0].id : null,
@@ -590,7 +592,7 @@ export class ToolsControlComponent extends React.PureComponent<Props, State> {
         const portals = !activeTracker ?
             [] :
             states
-                .filter((objectState) => objectState.objectType === 'track' && objectState.shapeType === 'rectangle')
+                .filter((objectState) => objectState.objectType === 'track' && (objectState.shapeType === 'rectangle' || objectState.shapeType === 'polygon'))
                 .map((objectState: any): React.ReactPortal | null => {
                     const { clientID } = objectState;
                     const selectorID = `#cvat-objects-sidebar-state-item-${clientID}`;
@@ -818,7 +820,7 @@ export class ToolsControlComponent extends React.PureComponent<Props, State> {
                             job: jobInstance.id,
                         });
 
-                        response.shapes = response.shapes.map(trackedRectangleMapper);
+                        // response.shapes = response.shapes.map(trackedRectangleMapper);
                         for (let i = 0; i < trackableObjects.clientIDs.length; i++) {
                             const clientID = trackableObjects.clientIDs[i];
                             const shape = response.shapes[i];
@@ -855,7 +857,7 @@ export class ToolsControlComponent extends React.PureComponent<Props, State> {
     }
 
     private async constructFromPoints(): Promise<void> {
-        const { convertMasksToPolygons } = this.state;
+        const { convertMasksToPolygons, selectedObjectType } = this.state;
         const {
             frame, labels, curZOrder, activeLabelID, createAnnotations,
         } = this.props;
@@ -863,7 +865,7 @@ export class ToolsControlComponent extends React.PureComponent<Props, State> {
         if (convertMasksToPolygons) {
             const object = new core.classes.ObjectState({
                 frame,
-                objectType: ObjectType.SHAPE,
+                objectType: selectedObjectType,
                 source: core.enums.Source.SEMI_AUTO,
                 label: labels.length ? labels.filter((label: any) => label.id === activeLabelID)[0] : null,
                 shapeType: ShapeType.POLYGON,
@@ -954,6 +956,29 @@ export class ToolsControlComponent extends React.PureComponent<Props, State> {
         );
     }
 
+    private renderObjectTypeBlock(): JSX.Element {
+        const { selectedObjectType } = this.state;
+        const objectTypes = Object.values(ObjectType);
+        objectTypes.splice(objectTypes.indexOf(ObjectType.TAG), 1);
+        return (
+            <Row className='cvat-interactors-setups-container'>
+                <Select
+                    value={selectedObjectType}
+                    onChange={(value: ObjectType) => {
+                        this.setState({ selectedObjectType: value });
+                    }}
+                >
+                    {objectTypes.map((type) => (
+                        <Select.Option key={type} value={type}>
+                            {type}
+                        </Select.Option>
+                    ))}
+                </Select>
+                <Text>Object Type</Text>
+            </Row>
+        );
+    }
+
     private renderLabelBlock(): JSX.Element {
         const { labels } = this.props;
         const { activeLabelID } = this.state;
@@ -1347,6 +1372,7 @@ export class ToolsControlComponent extends React.PureComponent<Props, State> {
     }
 
     private renderPopoverContent(): JSX.Element {
+        const { convertMasksToPolygons } = this.state;
         return (
             <div className='cvat-tools-control-popover-content'>
                 <Row justify='start'>
@@ -1359,6 +1385,7 @@ export class ToolsControlComponent extends React.PureComponent<Props, State> {
                 <Tabs type='card' tabBarGutter={8}>
                     <Tabs.TabPane key='interactors' tab='Interactors'>
                         {this.renderMasksConvertingBlock()}
+                        {convertMasksToPolygons ? this.renderObjectTypeBlock() : null}
                         {this.renderLabelBlock()}
                         {this.renderInteractorBlock()}
                     </Tabs.TabPane>
diff --git a/serverless/pytorch/omerferhatt/xmem/nuclio/function-gpu.yaml b/serverless/pytorch/omerferhatt/xmem/nuclio/function-gpu.yaml
new file mode 100644
index 000000000..8b6e936eb
--- /dev/null
+++ b/serverless/pytorch/omerferhatt/xmem/nuclio/function-gpu.yaml
@@ -0,0 +1,69 @@
+metadata:
+  name: pth-omerferhatt-xmem
+  namespace: cvat
+  annotations:
+    name: XMem
+    type: tracker
+    spec:
+    framework: pytorch
+
+spec:
+  description: Long-Term Object Segmentation with an Atkinson-Shiffrin Memory Model
+  runtime: 'python:3.9'
+  handler: main:handler
+  eventTimeout: 30s
+
+  env:
+    - name: PYTHONPATH
+      value: /opt/nuclio/xmem
+
+  build:
+    image: cvat.pth.omerferhatt.xmem:latest-gpu
+    baseImage: nvidia/cuda:12.1.0-runtime-ubuntu20.04
+
+    directives:
+      preCopy:
+        - kind: RUN
+          value: |-
+            apt update \
+              && apt install -y --no-install-recommends \
+                wget \
+                git \
+                ca-certificates \
+                python-is-python3 \
+                python3 \
+                python3-pip \
+              && rm -rf /var/lib/apt/lists/*
+        - kind: WORKDIR
+          value: /opt/nuclio
+        - kind: RUN
+          value: git clone --branch main https://github.com/hkchengrex/XMem xmem
+        - kind: RUN
+          value: |-
+            pip install \
+              jsonpickle opencv-python-headless \
+              torch torchvision
+        - kind: RUN
+          value: pip3 install debugpy
+        - kind: RUN
+          value: wget 'https://www.dropbox.com/scl/fi/5m1l747p15qzgq023e0q9/xmem.pth?rlkey=ss2kjaq4qlvvk5juucyvtmrh8&dl=0' -O '/xmem.pth'
+
+  triggers:
+    myHttpTrigger:
+      maxWorkers: 1
+      kind: 'http'
+      workerAvailabilityTimeoutMilliseconds: 10000
+      attributes:
+        # Set value from the calculation of tracking of 100 objects at the same time on a 4k image
+        maxRequestBodySize: 268435456 # 256MB
+
+  resources:
+    limits:
+      nvidia.com/gpu: 1
+
+  platform:
+    attributes:
+      restartPolicy:
+        name: always
+        maximumRetryCount: 3
+      mountMode: volume
diff --git a/serverless/pytorch/omerferhatt/xmem/nuclio/function.yaml b/serverless/pytorch/omerferhatt/xmem/nuclio/function.yaml
new file mode 100644
index 000000000..7c15f5c31
--- /dev/null
+++ b/serverless/pytorch/omerferhatt/xmem/nuclio/function.yaml
@@ -0,0 +1,66 @@
+metadata:
+  name: pth-omerferhatt-xmem
+  namespace: cvat
+  annotations:
+    name: XMem
+    type: tracker
+    spec:
+    framework: pytorch
+
+spec:
+  description: Long-Term Object Segmentation with an Atkinson-Shiffrin Memory Model
+  runtime: 'python:3.9'
+  handler: main:handler
+  eventTimeout: 30s
+
+  env:
+    - name: PYTHONPATH
+      value: /opt/nuclio/xmem
+
+  build:
+    image: cvat.pth.omerferhatt.xmem
+    baseImage: ubuntu:20.04
+
+    directives:
+      preCopy:
+        - kind: RUN
+          value: |-
+            apt update \
+              && apt install -y --no-install-recommends \
+                wget \
+                git \
+                ca-certificates \
+                python-is-python3 \
+                python3 \
+                python3-pip \
+              && rm -rf /var/lib/apt/lists/*
+        - kind: WORKDIR
+          value: /opt/nuclio
+        - kind: RUN
+          value: git clone --branch main https://github.com/hkchengrex/XMem xmem
+        - kind: RUN
+          value: |-
+            pip install \
+              jsonpickle opencv-python-headless \
+              torch torchvision \
+              --extra-index-url https://download.pytorch.org/whl/cpu
+        - kind: RUN
+          value: pip3 install debugpy
+        - kind: RUN
+          value: wget 'https://www.dropbox.com/scl/fi/5m1l747p15qzgq023e0q9/xmem.pth?rlkey=ss2kjaq4qlvvk5juucyvtmrh8&dl=0' -O '/xmem.pth'
+
+  triggers:
+    myHttpTrigger:
+      maxWorkers: 1
+      kind: 'http'
+      workerAvailabilityTimeoutMilliseconds: 10000
+      attributes:
+        # Set value from the calculation of tracking of 100 objects at the same time on a 4k image
+        maxRequestBodySize: 268435456 # 256MB
+
+  platform:
+    attributes:
+      restartPolicy:
+        name: always
+        maximumRetryCount: 3
+      mountMode: volume
diff --git a/serverless/pytorch/omerferhatt/xmem/nuclio/main.py b/serverless/pytorch/omerferhatt/xmem/nuclio/main.py
new file mode 100644
index 000000000..951194ac5
--- /dev/null
+++ b/serverless/pytorch/omerferhatt/xmem/nuclio/main.py
@@ -0,0 +1,45 @@
+import debugpy
+
+debugpy.listen(5678)
+
+import base64
+import io
+import json
+
+import numpy as np
+import torch
+from model_handler import ModelHandler
+from PIL import Image
+
+
+def init_context(context):
+    torch.autograd.set_grad_enabled(False)
+    context.logger.info("Init context...  0%")
+    model = ModelHandler()
+    context.user_data.model = model
+    context.logger.info("Init context...100%")
+
+
+def handler(context, event):
+    context.logger.info("Run XMem model")
+    data = event.body
+    buf = io.BytesIO(base64.b64decode(data["image"]))
+    shapes = data.get("shapes")
+    states = data.get("states")
+
+    image = Image.open(buf).convert("RGB")
+    image = np.array(image)[:, :, ::-1].copy()
+    results = {"shapes": [], "states": []}
+    for i, shape in enumerate(shapes):
+        shape, state = context.user_data.model.infer(
+            image, shape, states[i] if i < len(states) else None
+        )
+        results["shapes"].append(shape)
+        results["states"].append(state)
+
+    return context.Response(
+        body=json.dumps(results),
+        headers={},
+        content_type="application/json",
+        status_code=200,
+    )
diff --git a/serverless/pytorch/omerferhatt/xmem/nuclio/model_handler.py b/serverless/pytorch/omerferhatt/xmem/nuclio/model_handler.py
new file mode 100644
index 000000000..1c8377ac1
--- /dev/null
+++ b/serverless/pytorch/omerferhatt/xmem/nuclio/model_handler.py
@@ -0,0 +1,140 @@
+# Copyright (C) 2022 CVAT.ai Corporation
+#
+# SPDX-License-Identifier: MIT
+
+import jsonpickle
+import numpy as np
+import torch
+import cv2
+
+from model.network import XMem
+from inference.inference_core import InferenceCore
+from inference.data.mask_mapper import MaskMapper
+
+
+def convert_polygon_to_mask(image, points):
+    h, w = image.shape[:2]
+    points = np.array(points).reshape(-1, 2).astype(np.int32)
+    mask = np.zeros((h, w), dtype=np.int32)
+    mask = cv2.fillPoly(mask, [points], 1)[None, :, :]
+    return mask
+
+
+def convert_mask_to_polygon(mask):
+    if int(cv2.__version__.split(".")[0]) > 3:
+        contours = cv2.findContours(
+            mask.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_TC89_KCOS
+        )[0]
+    else:
+        contours = cv2.findContours(
+            mask.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_TC89_KCOS
+        )[1]
+
+    if len(contours) == 0:
+        return []
+
+    contours = max(contours, key=lambda arr: arr.size)
+
+    if contours.shape.count(1):
+        contours = np.squeeze(contours)
+
+    if contours.size < 3 * 2:
+        return []
+
+    else:
+        return contours.reshape(-1).tolist()
+
+
+class ModelHandler:
+    def __init__(self):
+        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
+        self.weight_path = "/xmem.pth"  # Absolute path of the model
+        self.config = {
+            "mem_every": 5,
+            "deep_update_every": -1,
+            "enable_long_term": True,
+            "enable_long_term_count_usage": True,
+            "disable_long_term": False,
+            "max_mid_term_frames": 10,
+            "min_mid_term_frames": 5,
+            "max_long_term_elements": 1000,
+            "num_prototypes": 128,
+            "top_k": 30,
+            "key_dim": 64,
+            "value_dim": 512,
+            "hidden_dim": 64,
+        }
+
+        self.model = XMem(
+            self.config, model_path=self.weight_path, map_location=self.device
+        )
+        self.model = self.model.eval()
+        self.model = self.model.to(self.device)
+
+        weights = torch.load(self.weight_path, map_location=self.device)
+        self.model.load_weights(weights, init_as_zero_if_needed=True)
+
+        self.mask_mapper = MaskMapper()
+        self.tracker = InferenceCore(self.model, self.config)
+
+    def encode_state(self):
+        state = {}
+        state["curr_ti"] = jsonpickle.encode(self.tracker.curr_ti)
+        state["last_mem_ti"] = jsonpickle.encode(self.tracker.last_mem_ti)
+        state["last_deep_update_ti"] = jsonpickle.encode(
+            self.tracker.last_deep_update_ti
+        )
+        state["memory"] = jsonpickle.encode(self.tracker.memory)
+        return state
+
+    def decode_state(self, state):
+        self.tracker.curr_ti = jsonpickle.decode(state["curr_ti"])
+        self.tracker.last_mem_ti = jsonpickle.decode(state["last_mem_ti"])
+        self.tracker.last_deep_update_ti = jsonpickle.decode(
+            state["last_deep_update_ti"]
+        )
+        self.tracker.memory = jsonpickle.decode(state["memory"])
+
+    def init_tracker(self, img, masks):
+        if masks is not None:
+            masks, labels = self.mask_mapper.convert_mask(masks[0], exhaustive=True)
+            masks = torch.Tensor(masks).to(self.device)
+            self.tracker.set_all_labels(list(self.mask_mapper.remappings.values()))
+        else:
+            labels = None
+        self.tracker.step(img, masks, labels)
+
+    def track(self, img):
+        prob = self.tracker.step(img)
+        mask = torch.max(prob, dim=0).indices
+        mask = mask.numpy(force=True)
+        return mask
+
+    def infer(self, image, shape, state):
+        with torch.autograd.set_grad_enabled(False):
+            with torch.cuda.amp.autocast(enabled=True):
+                mask = convert_polygon_to_mask(image, shape)
+                image = (
+                    torch.from_numpy(image)
+                    .float()
+                    .permute(2, 0, 1)
+                    .to(device=self.device)
+                )
+                image = image / 255.0
+                if state is None:
+                    with torch.inference_mode():
+                        self.init_tracker(image, mask)
+                    state = self.encode_state()
+
+                else:
+                    self.decode_state(state)
+                    with torch.inference_mode():
+                        mask = self.track(image)
+                    state = self.encode_state()
+                    shape = convert_mask_to_polygon(mask)
+                self.tracker.clear_memory()
+        if torch.cuda.is_available():
+            torch.cuda.synchronize()
+            torch.cuda.empty_cache()
+
+        return shape, state
