{"version":3,"sources":["webpack://cvat/webpack/bootstrap","webpack://cvat/../cvat-data/src/js/cvat-data.js","webpack://cvat/./node_modules/asynckit/index.js","webpack://cvat/./node_modules/asynckit/lib/abort.js","webpack://cvat/./node_modules/asynckit/lib/async.js","webpack://cvat/./node_modules/asynckit/lib/defer.js","webpack://cvat/./node_modules/asynckit/lib/iterate.js","webpack://cvat/./node_modules/asynckit/lib/state.js","webpack://cvat/./node_modules/asynckit/lib/terminator.js","webpack://cvat/./node_modules/asynckit/parallel.js","webpack://cvat/./node_modules/asynckit/serial.js","webpack://cvat/./node_modules/asynckit/serialOrdered.js","webpack://cvat/./node_modules/axios/index.js","webpack://cvat/./node_modules/axios/lib/adapters/http.js","webpack://cvat/./node_modules/axios/lib/adapters/xhr.js","webpack://cvat/./node_modules/axios/lib/axios.js","webpack://cvat/./node_modules/axios/lib/cancel/Cancel.js","webpack://cvat/./node_modules/axios/lib/cancel/CancelToken.js","webpack://cvat/./node_modules/axios/lib/cancel/isCancel.js","webpack://cvat/./node_modules/axios/lib/core/Axios.js","webpack://cvat/./node_modules/axios/lib/core/InterceptorManager.js","webpack://cvat/./node_modules/axios/lib/core/createError.js","webpack://cvat/./node_modules/axios/lib/core/dispatchRequest.js","webpack://cvat/./node_modules/axios/lib/core/enhanceError.js","webpack://cvat/./node_modules/axios/lib/core/settle.js","webpack://cvat/./node_modules/axios/lib/core/transformData.js","webpack://cvat/./node_modules/axios/lib/defaults.js","webpack://cvat/./node_modules/axios/lib/helpers/bind.js","webpack://cvat/./node_modules/axios/lib/helpers/buildURL.js","webpack://cvat/./node_modules/axios/lib/helpers/combineURLs.js","webpack://cvat/./node_modules/axios/lib/helpers/cookies.js","webpack://cvat/./node_modules/axios/lib/helpers/isAbsoluteURL.js","webpack://cvat/./node_modules/axios/lib/helpers/isURLSameOrigin.js","webpack://cvat/./node_modules/axios/lib/helpers/normalizeHeaderName.js","webpack://cvat/./node_modules/axios/lib/helpers/parseHeaders.js","webpack://cvat/./node_modules/axios/lib/helpers/spread.js","webpack://cvat/./node_modules/axios/lib/utils.js","webpack://cvat/./node_modules/combined-stream/lib/combined_stream.js","webpack://cvat/./node_modules/debug/src/browser.js","webpack://cvat/./node_modules/debug/src/debug.js","webpack://cvat/./node_modules/debug/src/index.js","webpack://cvat/./node_modules/debug/src/node.js","webpack://cvat/./node_modules/delayed-stream/lib/delayed_stream.js","webpack://cvat/./node_modules/error-stack-parser/error-stack-parser.js","webpack://cvat/./node_modules/follow-redirects/index.js","webpack://cvat/./node_modules/form-data/lib/form_data.js","webpack://cvat/./node_modules/form-data/lib/populate.js","webpack://cvat/./node_modules/has-flag/index.js","webpack://cvat/./node_modules/is-buffer/index.js","webpack://cvat/./node_modules/mime-db/index.js","webpack://cvat/./node_modules/mime-types/index.js","webpack://cvat/./node_modules/ms/index.js","webpack://cvat/./node_modules/platform/platform.js","webpack://cvat/./node_modules/stackframe/stackframe.js","webpack://cvat/./node_modules/store/dist/store.legacy.js","webpack://cvat/./node_modules/store/plugins/json2.js","webpack://cvat/./node_modules/store/plugins/lib/json2.js","webpack://cvat/./node_modules/store/src/store-engine.js","webpack://cvat/./node_modules/store/src/util.js","webpack://cvat/./node_modules/store/storages/all.js","webpack://cvat/./node_modules/store/storages/cookieStorage.js","webpack://cvat/./node_modules/store/storages/localStorage.js","webpack://cvat/./node_modules/store/storages/memoryStorage.js","webpack://cvat/./node_modules/store/storages/oldFF-globalStorage.js","webpack://cvat/./node_modules/store/storages/oldIE-userDataStorage.js","webpack://cvat/./node_modules/store/storages/sessionStorage.js","webpack://cvat/./node_modules/supports-color/index.js","webpack://cvat/(webpack)/buildin/module.js","webpack://cvat/./src/annotation-format.js","webpack://cvat/./src/annotations-collection.js","webpack://cvat/./src/annotations-objects.js","webpack://cvat/./src/annotations-saver.js","webpack://cvat/./src/annotations.js","webpack://cvat/./src/api-implementation.js","webpack://cvat/./src/api.js","webpack://cvat/./src/common.js","webpack://cvat/./src/config.js","webpack://cvat/./src/enums.js","webpack://cvat/./src/exceptions.js","webpack://cvat/./src/frames.js","webpack://cvat/./src/labels.js","webpack://cvat/./src/object-state.js","webpack://cvat/./src/plugins.js","webpack://cvat/./src/server-proxy.js","webpack://cvat/./src/session.js","webpack://cvat/./src/statistics.js","webpack://cvat/./src/user.js","webpack://cvat/external \"assert\"","webpack://cvat/external \"fs\"","webpack://cvat/external \"http\"","webpack://cvat/external \"https\"","webpack://cvat/external \"os\"","webpack://cvat/external \"path\"","webpack://cvat/external \"stream\"","webpack://cvat/external \"tty\"","webpack://cvat/external \"url\"","webpack://cvat/external \"util\"","webpack://cvat/external \"zlib\""],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD;;AAEA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,sBAAsB,OAAO;AAC7B,oBAAoB,OAAO;AAC3B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,MAAM,GAAG,IAAI;AAC9C,4B;;AAEA,yC;;AAEA;;AAEA;AACA;AACA,aAAa;;AAEb,gCAAgC;AAChC;AACA,6CAA6C;;;AAG7C;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;;AAEA;AACA;AACA,aAAa;;AAEb,gCAAgC;AAChC;AACA,6CAA6C;;;AAG7C;AACA;AACA;;AAEA,aAAa;AACb;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACvHA;AACA;AACA,kBAAkB,mBAAO,CAAC,0DAAe;AACzC,kBAAkB,mBAAO,CAAC,sDAAa;AACvC,kBAAkB,mBAAO,CAAC,oEAAoB;AAC9C;;;;;;;;;;;;ACLA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BA,YAAY,mBAAO,CAAC,wDAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gBAAgB,EAAE;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;;;;;;;;;;ACjCA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzBA,YAAY,mBAAO,CAAC,wDAAY;AAChC,YAAY,mBAAO,CAAC,wDAAY;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,cAAc;AAC3B,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC1EA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,cAAc;AAC3B;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;;;;;;;;;;ACpCA,YAAY,mBAAO,CAAC,wDAAY;AAChC,YAAY,mBAAO,CAAC,wDAAY;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC5BA,iBAAiB,mBAAO,CAAC,gEAAkB;AAC3C,iBAAiB,mBAAO,CAAC,4DAAgB;AACzC,iBAAiB,mBAAO,CAAC,sEAAqB;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;;;;;;;;;;;AC1CA,oBAAoB,mBAAO,CAAC,oEAAoB;;AAEhD;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBA,iBAAiB,mBAAO,CAAC,gEAAkB;AAC3C,iBAAiB,mBAAO,CAAC,4DAAgB;AACzC,iBAAiB,mBAAO,CAAC,sEAAqB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,MAAM;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1EA,iBAAiB,mBAAO,CAAC,sDAAa,E;;;;;;;;;;;;ACAzB;;AAEb,YAAY,mBAAO,CAAC,qDAAY;AAChC,aAAa,mBAAO,CAAC,iEAAkB;AACvC,eAAe,mBAAO,CAAC,2EAAuB;AAC9C,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,iBAAiB,mBAAO,CAAC,kEAAkB;AAC3C,kBAAkB,mBAAO,CAAC,kEAAkB;AAC5C,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;AACzB,UAAU,mBAAO,CAAC,+DAAsB;AACxC,kBAAkB,mBAAO,CAAC,yEAAqB;AAC/C,mBAAmB,mBAAO,CAAC,2EAAsB;;AAEjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC7Oa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;AAChC,aAAa,mBAAO,CAAC,iEAAkB;AACvC,eAAe,mBAAO,CAAC,2EAAuB;AAC9C,mBAAmB,mBAAO,CAAC,mFAA2B;AACtD,sBAAsB,mBAAO,CAAC,yFAA8B;AAC5D,kBAAkB,mBAAO,CAAC,yEAAqB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAO,CAAC,yEAAsB;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACjKa;;AAEb,YAAY,mBAAO,CAAC,kDAAS;AAC7B,WAAW,mBAAO,CAAC,gEAAgB;AACnC,YAAY,mBAAO,CAAC,4DAAc;AAClC,eAAe,mBAAO,CAAC,wDAAY;;AAEnC;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,kEAAiB;AACxC,oBAAoB,mBAAO,CAAC,4EAAsB;AAClD,iBAAiB,mBAAO,CAAC,sEAAmB;;AAE5C;AACA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,oEAAkB;;AAEzC;;AAEA;AACA;;;;;;;;;;;;;ACnDa;;AAEb;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;;;;;AClBa;;AAEb,aAAa,mBAAO,CAAC,2DAAU;;AAE/B;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACxDa;;AAEb;AACA;AACA;;;;;;;;;;;;;ACJa;;AAEb,eAAe,mBAAO,CAAC,2DAAe;AACtC,YAAY,mBAAO,CAAC,qDAAY;AAChC,yBAAyB,mBAAO,CAAC,iFAAsB;AACvD,sBAAsB,mBAAO,CAAC,2EAAmB;;AAEjD;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,kCAAkC,cAAc;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;;;;;;;;;;;;;AC9Ea;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;;;;ACnDa;;AAEb,mBAAmB,mBAAO,CAAC,qEAAgB;;AAE3C;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;AAChC,oBAAoB,mBAAO,CAAC,uEAAiB;AAC7C,eAAe,mBAAO,CAAC,uEAAoB;AAC3C,eAAe,mBAAO,CAAC,yDAAa;AACpC,oBAAoB,mBAAO,CAAC,qFAA4B;AACxD,kBAAkB,mBAAO,CAAC,iFAA0B;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,uCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;;ACrFa;;AAEb;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBa;;AAEb,kBAAkB,mBAAO,CAAC,mEAAe;;AAEzC;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,MAAM;AACjB,WAAW,eAAe;AAC1B,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;ACnBa;;AAEb,YAAY,mBAAO,CAAC,kDAAS;AAC7B,0BAA0B,mBAAO,CAAC,8FAA+B;;AAEjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,mBAAO,CAAC,gEAAgB;AACtC,GAAG;AACH;AACA,cAAc,mBAAO,CAAC,kEAAiB;AACvC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO,YAAY;AACnB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;;;;;;;;;;;;;AC/Fa;;AAEb;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACjEa;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC;AACxC,OAAO;;AAEP;AACA,0DAA0D,wBAAwB;AAClF;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,gCAAgC;AAChC,6BAA6B,aAAa,EAAE;AAC5C;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACpDa;;AAEb;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACba;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACnEa;;AAEb,YAAY,mBAAO,CAAC,mDAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACXa;;AAEb,YAAY,mBAAO,CAAC,qDAAY;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;ACpDa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1Ba;;AAEb,WAAW,mBAAO,CAAC,gEAAgB;AACnC,eAAe,mBAAO,CAAC,oDAAW;;AAElC;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS,GAAG,SAAS;AAC5C,2BAA2B;AAC3B;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC9SA,WAAW,mBAAO,CAAC,kBAAM;AACzB,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,oBAAoB,mBAAO,CAAC,2EAAgB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC/MA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,kDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,sCAAI;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AChOA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAO,CAAC,yDAAc;AACzC,CAAC;AACD,mBAAmB,mBAAO,CAAC,mDAAW;AACtC;;;;;;;;;;;;ACTA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,mBAAO,CAAC,kDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,mBAAO,CAAC,8DAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6DAA6D;AAC7D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;;AAEpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,EAAE;AACnD,sCAAsC;;AAEtC;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACzLA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1GA;AACA;AACA;;AAEA;AACA,QAAQ,IAA0C;AAClD,QAAQ,iCAA6B,CAAC,gFAAY,CAAC,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AAC7D,KAAK,MAAM,EAIN;AACL,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,CAAC;;;;;;;;;;;;ACzMD,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,eAAe,mBAAO,CAAC,sBAAQ;AAC/B,YAAY,mBAAO,CAAC,gDAAO;;AAE3B;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,sBAAsB,uCAAuC,EAAE;AAC/D,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,uBAAuB,2BAA2B;AAClD;;;;;;;;;;;;ACjUA,qBAAqB,mBAAO,CAAC,8EAAiB;AAC9C,WAAW,mBAAO,CAAC,kBAAM;AACzB,WAAW,mBAAO,CAAC,kBAAM;AACzB,WAAW,mBAAO,CAAC,kBAAM;AACzB,YAAY,mBAAO,CAAC,oBAAO;AAC3B,eAAe,mBAAO,CAAC,gBAAK;AAC5B,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,sDAAY;AAC/B,eAAe,mBAAO,CAAC,kDAAU;AACjC,eAAe,mBAAO,CAAC,+DAAe;;AAEtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;AACH;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACleA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;ACTa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,iDAAW;;;;;;;;;;;;;ACVpC;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ;AACA;AACA;AACA;;AAEA,SAAS,mBAAO,CAAC,gDAAS;AAC1B,cAAc,mBAAO,CAAC,kBAAM;;AAE5B;AACA;AACA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;AC3LA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO,yCAAyC;AAChD;AACA,OAAO,8CAA8C;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,+CAA+C;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,2DAA2D;AAClE;AACA,OAAO,4DAA4D;AACnE;AACA;AACA,OAAO,4CAA4C;AACnD;AACA;AACA;AACA;AACA;AACA,OAAO,4CAA4C;AACnD;AACA,OAAO,qCAAqC;AAC5C;AACA,OAAO,wDAAwD;AAC/D,OAAO,yDAAyD;AAChE,OAAO,iDAAiD;AACxD,OAAO,uCAAuC;AAC9C,OAAO,mCAAmC;AAC1C;AACA;;AAEA;AACA;AACA,OAAO,2CAA2C;AAClD;AACA,OAAO,6CAA6C;AACpD,OAAO,8CAA8C;AACrD,OAAO,8CAA8C;AACrD,OAAO,8CAA8C;AACrD,OAAO,6CAA6C;AACpD,OAAO,6CAA6C;AACpD,OAAO,kDAAkD;AACzD,OAAO,6CAA6C;AACpD,OAAO,kDAAkD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,mEAAmE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,sCAAsC;AAC7C;AACA;AACA,OAAO,yCAAyC;AAChD;AACA;;AAEA;AACA;AACA,gBAAgB,oCAAoC;AACpD,kBAAkB;AAClB,iBAAiB,gCAAgC;AACjD,eAAe,mBAAmB;AAClC,yBAAyB,YAAY;AACrC,qBAAqB,gBAAgB;AACrC,iBAAiB,6BAA6B;AAC9C,aAAa,gBAAgB;AAC7B,eAAe;AACf,cAAc;AACd,oBAAoB,2BAA2B;AAC/C,mBAAmB,YAAY;AAC/B,mBAAmB,wBAAwB;AAC3C,gBAAgB,aAAa;AAC7B,kBAAkB,gEAAgE;AAClF,eAAe;AACf,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,OAAO,0CAA0C;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kCAAkC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,GAAG;AACrD;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,8BAA8B,eAAe;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAM,IAA0E;AAChF;AACA;AACA;AACA;;AAEA;AACA,IAAI,mCAAO;AACX;AACA,KAAK;AAAA,oGAAC;AACN;AACA;AACA,OAAO,EASJ;AACH,CAAC;;;;;;;;;;;;;AChsCD;AACA;AACA;;AAEA;AACA,QAAQ,IAA0C;AAClD,QAAQ,iCAAqB,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AACzC,KAAK,MAAM,EAIN;AACL,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,CAAC;;;;;;;;;;;;AC9ID,aAAa,mBAAO,CAAC,qEAAqB;;AAE1C,eAAe,mBAAO,CAAC,6DAAiB;AACxC,eAAe,mBAAO,CAAC,+DAAkB;;AAEzC;;;;;;;;;;;;ACLA;;AAEA;AACA,CAAC,mBAAO,CAAC,8DAAa;AACtB;AACA;;;;;;;;;;;;ACLA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yCAAyC,iBAAiB;AAC1D,8BAA8B,kBAAkB;;AAEhD,yCAAyC,iBAAiB;AAC1D,sCAAsC,6BAA6B;;AAEnE;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B;AAC1B,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;;AAGA;;AAEA;;AAEA,cAAc;AACd,cAAc;AACd,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,2BAA2B,YAAY;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA,wBAAwB,wDAAwD;AAChF,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,WAAW;AACtC;AACA;;AAEA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,UAAU;AACtC;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,4BAA4B,MAAM;AAClC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC,I;;;;;;;;;;;AC3fD,WAAW,mBAAO,CAAC,gDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,aAAa;;AAEb;AACA,GAAG;;AAEH;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;;;;;;;;;;;;AC5OA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA,KAAK;AACL,I;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA,iBAAiB;AACjB;;;;;;;;;;;;ACrHA;AACA;AACA,CAAC,mBAAO,CAAC,qEAAgB;AACzB,CAAC,mBAAO,CAAC,mFAAuB;AAChC,CAAC,mBAAO,CAAC,uFAAyB;AAClC,CAAC,mBAAO,CAAC,uEAAiB;AAC1B,CAAC,mBAAO,CAAC,yEAAkB;AAC3B,CAAC,mBAAO,CAAC,uEAAiB;AAC1B;;;;;;;;;;;;ACRA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,qDAAa;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA,qBAAqB,KAAK,MAAM;AAChC;AACA;;AAEA;AACA,kCAAkC;AAClC,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX,mDAAmD,uCAAuC;AAC1F;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,uCAAuC;AACtE;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA,2BAA2B;AAC3B;;;;;;;;;;;;AC5DA,WAAW,mBAAO,CAAC,qDAAa;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACrCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACtCA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,qDAAa;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;;;;;;;;;;;ACzCA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,qDAAa;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,YAAY,EAAE;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9HA,WAAW,mBAAO,CAAC,qDAAa;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACrCa;AACb,WAAW,mBAAO,CAAC,cAAI;AACvB,gBAAgB,mBAAO,CAAC,kDAAU;;AAElC;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAiC,GAAG;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC1OD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,2DAAuB;AACvC,WAAW,kBAAkB,GAAG,mBAAO,CAAC,iCAAU;AAClD,uBAAuB,mBAAO,CAAC,yCAAc;AAC7C,WAAW,QAAQ,GAAG,mBAAO,CAAC,iCAAU;AACxC;AACA;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,yCAAc;;AAE9B;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,+BAAS;AACzB,wBAAwB,mBAAO,CAAC,6CAAgB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,KAAK;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,IAAI;;AAEjB,6BAA6B;AAC7B,2BAA2B;AAC3B;AACA,8BAA8B;AAC9B;AACA;AACA,kCAAkC,qBAAqB,SAAS;AAChE;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,iCAAiC;AACjC,mBAAmB,mBAAmB;AACtC;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;;AAEA;AACA;AACA,8CAA8C,UAAU;AACxD;AACA;;AAEA;AACA;AACA;AACA,aAAa,IAAI;;AAEjB,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA,+DAA+D,WAAW,YAAY,iBAAiB;AACvG;AACA;;AAEA;AACA;AACA,yDAAyD,UAAU,YAAY,gBAAgB;AAC/F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA,iCAAiC;AACjC;AACA;AACA,iBAAiB;AACjB;AACA,gEAAgE,wBAAwB;AACxF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,IAAI;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,oDAAoD,WAAW;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,2BAA2B,YAAY;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,2CAA2C;AAChF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA,qCAAqC,0CAA0C;AAC/E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;AC1vBD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,mBAAO,CAAC,6CAAgB;AAChD;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,iCAAU;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,+BAAS;;AAEzB;AACA;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,yCAAc;;AAE9B,WAAW,QAAQ,GAAG,mBAAO,CAAC,iCAAU;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA,SAAS;AACT;AACA;AACA,oEAAoE,kBAAkB;AACtF;AACA;AACA,SAAS;AACT;AACA;AACA,qEAAqE,kBAAkB;AACvF;AACA;AACA,SAAS;AACT;AACA;AACA,mEAAmE,kBAAkB;AACrF;AACA;AACA,SAAS;AACT;AACA,gEAAgE,UAAU;AAC1E;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;;AAEA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI;;AAEzB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,wEAAwE,OAAO,aAAa,MAAM;AAClG;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,gBAAgB;AACvC;AACA,+BAA+B,4BAA4B;AAC3D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,EAAE;AAClC;AACA,qDAAqD,WAAW;AAChE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,IAAI;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;;AAErB;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,wEAAwE,OAAO,aAAa,MAAM;AAClG;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,gBAAgB;AACvC;AACA,+BAA+B,4BAA4B;AAC3D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,EAAE;AAClC;AACA,qDAAqD,WAAW;AAChE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gFAAgF,QAAQ;AACxF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,QAAQ;;AAEvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAkD,uBAAuB;AACzE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA,mCAAmC,mBAAmB;AACtD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,+BAA+B;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC1gDD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,mBAAO,CAAC,6CAAgB;AAChD,WAAW,OAAO,GAAG,mBAAO,CAAC,mCAAW;AACxC,WAAW,iBAAiB;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA,wDAAwD,UAAU;AAClE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,cAAc,MAAM,YAAY;AAC7D;AACA;;AAEA;AACA;AACA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA,uDAAuD,qCAAqC;AAC5F;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA,4DAA4D,oCAAoC;AAChG;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,oCAAoC;AAChG;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,oCAAoC;AAChG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,sDAAsD,cAAc;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;ACtRD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,mBAAO,CAAC,6CAAgB;AAChD,uBAAuB,mBAAO,CAAC,iEAA0B;AACzD,6BAA6B,mBAAO,CAAC,uDAAqB;AAC1D,WAAW,kBAAkB,GAAG,mBAAO,CAAC,iCAAU;AAClD,WAAW,OAAO,GAAG,mBAAO,CAAC,mCAAW;AACxC;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,0DAAwB;AACxC;AACA;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,yCAAc;;AAE9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD,YAAY;AAC7D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;;AAEA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACjPD;AACA;AACA;AACA;;AAEA,6CAA6C,8BAA8B;;AAE3E;AACA;AACA;;;AAGA;AACA,2BAA2B,mBAAO,CAAC,mCAAW;AAC9C,wBAAwB,mBAAO,CAAC,6CAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,iCAAU;;AAE1B;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,+BAAS;;AAEzB,iBAAiB,mBAAO,CAAC,6BAAQ;AACjC,WAAW,mBAAmB,GAAG,mBAAO,CAAC,0DAAwB;AACjE,WAAW,gBAAgB,GAAG,mBAAO,CAAC,yCAAc;AACpD,WAAW,OAAO,GAAG,mBAAO,CAAC,mCAAW;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,cAAc;AAC7E,aAAa;AACb;AACA;AACA,mEAAmE,YAAY;AAC/E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;AC3KD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAO,CAAC,mCAAW;AAC9C,iBAAiB,mBAAO,CAAC,6BAAQ;AACjC,wBAAwB,mBAAO,CAAC,6CAAgB;AAChD,uBAAuB,mBAAO,CAAC,yCAAc;AAC7C,WAAW,YAAY,GAAG,mBAAO,CAAC,mCAAW;AAC7C,WAAW,mBAAmB,GAAG,mBAAO,CAAC,iCAAU;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,+BAAS;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,yCAAc;;AAE9B,kBAAkB,mBAAO,CAAC,uCAAiB;AAC3C,mBAAmB,mBAAO,CAAC,iCAAU;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,6BAA6B,OAAO;AACpC,6BAA6B,OAAO;AACpC,6BAA6B,OAAO;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,4BAA4B,OAAO;AACnC,6BAA6B,OAAO;AACpC,6BAA6B,oCAAoC;AACjE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,4BAA4B;AAC5B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,0BAA0B,OAAO;AACjC,0BAA0B,OAAO;AACjC,0BAA0B,OAAO;AACjC,0BAA0B,OAAO;AACjC,0BAA0B,OAAO;AACjC,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,0BAA0B,OAAO;AACjC,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,6BAA6B,OAAO;AACpC,6BAA6B,iCAAiC;AAC9D;AACA,6BAA6B,+BAA+B;AAC5D;AACA,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC;AACA;AACA,6BAA6B,OAAO;AACpC,6BAA6B,OAAO;AACpC,6BAA6B,OAAO;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW,WAAW;AAChD,4BAA4B;AAC5B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA,iCAAiC;AACjC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC,4BAA4B;AAC5B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA,iCAAiC;AACjC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,6BAA6B,QAAQ;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW,WAAW;AAChD,4BAA4B;AAC5B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA,iCAAiC;AACjC;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,yBAAyB;AACzB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,iCAAiC;AACjC,+BAA+B;AAC/B,6BAA6B;AAC7B,2BAA2B;AAC3B,yBAAyB;AACzB,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,uBAAuB;AACvB,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA,6BAA6B,OAAO;AACpC;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA,6BAA6B,QAAQ;AACrC;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC,8BAA8B,MAAM,EAAE,MAAM,EAAE,MAAM;AACpD,+CAA+C;AAC/C;AACA,+CAA+C;AAC/C,+CAA+C;AAC/C;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,mBAAO,CAAC,yDAAsB;;AAEvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvgBA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,gBAAgB,GAAG,mBAAO,CAAC,yCAAc;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2EAA2E,KAAK;AAChF;AACA,iBAAiB;AACjB;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,KAAK,uBAAuB,KAAK,UAAU,eAAe;AAClF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,KAAK,sBAAsB,cAAc;AACrE,kCAAkC,uBAAuB;AACzD;AACA;;AAEA;AACA,wBAAwB,KAAK,sBAAsB,cAAc;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACzFD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AClMD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,qDAAU;AACvC,6BAA6B,mBAAO,CAAC,mFAAoB;AACzD,mBAAmB,mBAAO,CAAC,iCAAU;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,cAAc,GAAG,iBAAiB;AAChE;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,qCAAqC;;AAErC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,mBAAO,CAAC,6CAAgB;AAC5D;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,sBAAsB,iBAAiB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC/QD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,yDAAiB;AAC9C,2BAA2B,mBAAO,CAAC,mCAAW;AAC9C,wBAAwB,mBAAO,CAAC,6CAAgB;AAChD;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,yCAAc;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,sBAAsB,SAAS,4BAA4B;AAC3D;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wDAAwD,MAAM;AAC9D;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA,iDAAiD,KAAK;AACtD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC3LD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,gBAAgB,GAAG,mBAAO,CAAC,+BAAS;AAC/C,WAAW,gBAAgB,GAAG,mBAAO,CAAC,yCAAc;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACjND;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAO,CAAC,mCAAW;AAC9C,WAAW,gBAAgB,GAAG,mBAAO,CAAC,yCAAc;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iDAAiD;AACjD,oFAAoF;AACpF;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,4FAA4F;AAC5F;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB,wBAAwB,oCAAoC;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA,wBAAwB,QAAQ;AAChC,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,CAAC;;;;;;;;;;;;AClaD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,cAAc,GAAG,mBAAO,CAAC,yCAAc;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB,yEAAyE,YAAY,IAAI,qBAAqB;AAC9G;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,yBAAyB;AACzB,yEAAyE,YAAY,IAAI,qBAAqB;AAC9G;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8EAA8E,cAAc;AAC5F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;AChHD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,4DAAW;AACxC;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,yCAAc;AAC9B,kBAAkB,mBAAO,CAAC,wDAAO;AACjC,mBAAmB,mBAAO,CAAC,iCAAU;;AAErC;AACA;AACA,+BAA+B,YAAY;AAC3C,qBAAqB,kBAAkB,IAAI,8CAA8C;AACzF;AACA;;AAEA;AACA,2BAA2B,YAAY;AACvC,aAAa,kBAAkB,GAAG;AAClC;AACA;;AAEA;AACA;AACA,0BAA0B,mBAAO,CAAC,4CAAO;AACzC;AACA;AACA;;AAEA;AACA;AACA,uEAAuE,MAAM;AAC7E;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,aAAa;AACpC;;AAEA;AACA;AACA,kDAAkD,WAAW,0BAA0B,UAAU;AACjG;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mDAAmD,kBAAkB;AACrE;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,+BAA+B,GAAG,6BAA6B;AACtF,uBAAuB,+BAA+B,GAAG,6BAA6B;AACtF;;AAEA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;;AAEA;AACA;AACA,uEAAuE,MAAM;AAC7E;;AAEA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA;AACA,kDAAkD,WAAW,SAAS,OAAO;AAC7E;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA,yCAAyC,WAAW,SAAS,GAAG;AAChE;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA,0CAA0C,WAAW,SAAS,GAAG;AACjE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA;AACA;AACA;AACA,oEAAoE,WAAW,SAAS,GAAG;AAC3F;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,iFAAiF,oBAAoB;AACrG;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D,mDAAmD,IAAI,GAAG,EAAE;AAC5D;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mDAAmD,WAAW;AAC9D;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,WAAW,SAAS,iBAAiB;AAC7E;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA,0DAA0D,YAAY;AACtE;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA;AACA,kDAAkD,WAAW,QAAQ,MAAM;AAC3E;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA,yCAAyC,WAAW,QAAQ,GAAG;AAC/D;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA;AACA,kDAAkD,WAAW,SAAS,IAAI;AAC1E;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,oEAAoE,IAAI;AACxE;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA;AACA,kDAAkD,WAAW,SAAS,IAAI,gBAAgB,MAAM;AAChG;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,+CAA+C,MAAM,gBAAgB,IAAI;AACzE;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,aAAa;;AAEpC;AACA;AACA,kDAAkD,WAAW,SAAS,IAAI;AAC1E;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,sEAAsE,IAAI;AAC1E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,aAAa;;AAEpC;AACA;AACA,kDAAkD,WAAW,GAAG,QAAQ,IAAI,GAAG;AAC/E;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,6DAA6D,QAAQ,GAAG,GAAG;AAC3E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA,6BAA6B,WAAW,GAAG,QAAQ,IAAI,GAAG;AAC1D,iBAAiB;AACjB;AACA,6BAA6B,WAAW,GAAG,QAAQ,IAAI,GAAG,sBAAsB,OAAO;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,iEAAiE,QAAQ,GAAG,GAAG;AAC/E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,aAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,WAAW,GAAG,QAAQ,IAAI,GAAG,sBAAsB,OAAO;AAClG;AACA,iCAAiC;AACjC;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,wEAAwE,QAAQ,GAAG,GAAG;AACtF;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA,6BAA6B,WAAW,SAAS,GAAG,eAAe,SAAS,UAAU,OAAO;;AAE7F;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C;AACA,iCAAiC;AACjC;AACA;AACA,6BAA6B;AAC7B,yCAAyC,IAAI;AAC7C;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,2EAA2E,GAAG;AAC9E;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;AC5qBD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B,mBAAO,CAAC,mCAAW;AAC9C,wBAAwB,mBAAO,CAAC,6CAAgB;AAChD,WAAW,sBAAsB,GAAG,mBAAO,CAAC,iCAAU;AACtD,WAAW,gBAAgB,GAAG,mBAAO,CAAC,yCAAc;AACpD,WAAW,aAAa,GAAG,mBAAO,CAAC,+BAAS;AAC5C,WAAW,QAAQ,GAAG,mBAAO,CAAC,iCAAU;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB,gDAAgD;AAChD;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B,0BAA0B,+BAA+B;AACzD;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,0BAA0B,+BAA+B;AACzD;AACA,4BAA4B,OAAO;AACnC,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mCAAmC;AAC/D,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sCAAsC;AAChE;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC,6BAA6B,OAAO;AACpC,6BAA6B,iCAAiC;AAC9D,6BAA6B,kCAAkC;AAC/D,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC,6BAA6B,OAAO;AACpC,6BAA6B,OAAO;AACpC,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC,0BAA0B,eAAe;AACzC;AACA,4BAA4B;AAC5B;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC,0BAA0B,QAAQ;AAClC,0BAA0B,QAAQ;AAClC,4BAA4B,QAAQ;AACpC,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sCAAsC;AAChE;AACA,0BAA0B,MAAM;AAChC,0BAA0B,MAAM;AAChC,4BAA4B;AAC5B,6BAA6B,qCAAqC;AAClE;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sCAAsC;AAChE,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oCAAoC;AAC9D,0BAA0B,QAAQ;AAClC,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sCAAsC;AAChE,0BAA0B,QAAQ;AAClC,4BAA4B,QAAQ;AACpC,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC,4BAA4B;AAC5B;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8BAA8B;AACxD,0BAA0B,QAAQ;AAClC,0BAA0B,OAAO;AACjC,4BAA4B;AAC5B;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gCAAgC;AAC1D,0BAA0B,UAAU;AACpC,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gCAAgC;AAC1D,0BAA0B,UAAU;AACpC,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qBAAqB;AACpF;AACA;;AAEA;AACA;AACA;AACA,0EAA0E,eAAe;AACzF;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qBAAqB;AACpF;AACA;;AAEA;AACA;AACA;AACA,wEAAwE,uBAAuB;AAC/F;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qBAAqB;AACpF;AACA;;AAEA;AACA;AACA;AACA,0EAA0E,eAAe;AACzF;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,gBAAgB;AACtF;AACA;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,yFAAyF,UAAU;AACnG;AACA;;AAEA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,GAAG,mBAAO,CAAC,2CAAe;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;;AAEA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;;AAEA;AACA;AACA,yCAAyC,MAAM;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2DAA2D,MAAM;AACjE;AACA;;AAEA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;AC78CD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;AC1FD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;ACtJD,mC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,iC","file":"cvat-core.node.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/api.js\");\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:true\n*/\n// require(\"./decode_video\")\nconst BlockType = Object.freeze({\n    TSVIDEO: 'tsvideo',\n    ARCHIVE: 'archive',\n});\n\nclass FrameProvider {\n    constructor(memory, blockType) {\n        this._frames = {};\n        this._memory = Math.max(1, memory); // number of stored blocks\n        this._blocks = [];\n        this._running = false;\n        this._blockType = blockType;\n        this._currFrame = -1;\n    }\n\n    /* This method removes extra data from a cache when memory overflow */\n    _cleanup() {\n        if (this._blocks.length > this._memory) {\n            const shifted = this._blocks.shift(); // get the oldest block\n            const [start, end] = shifted.split(':').map((el) => +el);\n\n            // remove all frames within this block\n            for (let i = start; i <= end; i++) {\n                delete this._frames[i];\n            }\n        }\n    }\n\n    /* Method returns frame from collection. Else method returns 0 */\n    frame(frameNumber) {\n        if (frameNumber in this._frames) {\n            return this._frames[frameNumber];\n        }\n        return null;\n    }\n\n\n    /*\n        Method start asynchronic decode a block of data\n\n        @param block - is a data from a server as is (ts file or archive)\n        @param start {number} - is the first frame of a block\n        @param end {number} - is the last frame of a block + 1\n        @param callback - callback)\n\n    */\n\n    startDecode(block, start, end, callback)\n    {\n         if (this._blockType === BlockType.TSVIDEO){\n            if (this._running) {\n                throw new Error('Decoding has already running');\n            }\n\n            this._blocks.push(`${start}:${end}`);\n            this._cleanup();    \n\n            // decode(start, end, block);        \n\n            const worker = new Worker('/static/engine/js/decode_video.js');\n\n            worker.onerror = (function (e) {\n                console.log(['ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message].join(''));\n            });\n\n            worker.postMessage({block : block, \n                                start : start, \n                                  end : end });\n            \n\n            worker.onmessage = (function (event){\n                this._frames[event.data.index] = event.data.data;\n                callback(event.data.index);\n            }).bind(this);\n           \n        } else {\n            const worker = new Worker('/static/engine/js/unzip_imgs.js');\n\n            worker.onerror = (function (e) {\n                console.log(['ERROR: Line ', e.lineno, ' in ', e.filename, ': ', e.message].join(''));\n            });\n\n            worker.postMessage({block : block, \n                                start : start, \n                                  end : end });\n\n            \n            worker.onmessage = (function (event){\n                this._frames[event.data.index] = event.data.data;\n                callback(event.data.index);\n\n            }).bind(this);\n        }\n    }\n\n\n    /*\n        Method returns a list of cached ranges\n        Is an array of strings like \"start:end\"\n    */\n    get cachedFrames() {\n        return [...this._blocks].sort(\n            (a, b) => a.split(':')[0] - b.split(':')[0],\n        );\n    }\n}\n\nmodule.exports = {\n    FrameProvider,\n    BlockType,\n};\n","module.exports =\n{\n  parallel      : require('./parallel.js'),\n  serial        : require('./serial.js'),\n  serialOrdered : require('./serialOrdered.js')\n};\n","// API\nmodule.exports = abort;\n\n/**\n * Aborts leftover active jobs\n *\n * @param {object} state - current state object\n */\nfunction abort(state)\n{\n  Object.keys(state.jobs).forEach(clean.bind(state));\n\n  // reset leftover jobs\n  state.jobs = {};\n}\n\n/**\n * Cleans up leftover job by invoking abort function for the provided job id\n *\n * @this  state\n * @param {string|number} key - job id to abort\n */\nfunction clean(key)\n{\n  if (typeof this.jobs[key] == 'function')\n  {\n    this.jobs[key]();\n  }\n}\n","var defer = require('./defer.js');\n\n// API\nmodule.exports = async;\n\n/**\n * Runs provided callback asynchronously\n * even if callback itself is not\n *\n * @param   {function} callback - callback to invoke\n * @returns {function} - augmented callback\n */\nfunction async(callback)\n{\n  var isAsync = false;\n\n  // check if async happened\n  defer(function() { isAsync = true; });\n\n  return function async_callback(err, result)\n  {\n    if (isAsync)\n    {\n      callback(err, result);\n    }\n    else\n    {\n      defer(function nextTick_callback()\n      {\n        callback(err, result);\n      });\n    }\n  };\n}\n","module.exports = defer;\n\n/**\n * Runs provided function on next iteration of the event loop\n *\n * @param {function} fn - function to run\n */\nfunction defer(fn)\n{\n  var nextTick = typeof setImmediate == 'function'\n    ? setImmediate\n    : (\n      typeof process == 'object' && typeof process.nextTick == 'function'\n      ? process.nextTick\n      : null\n    );\n\n  if (nextTick)\n  {\n    nextTick(fn);\n  }\n  else\n  {\n    setTimeout(fn, 0);\n  }\n}\n","var async = require('./async.js')\n  , abort = require('./abort.js')\n  ;\n\n// API\nmodule.exports = iterate;\n\n/**\n * Iterates over each job object\n *\n * @param {array|object} list - array or object (named list) to iterate over\n * @param {function} iterator - iterator to run\n * @param {object} state - current job status\n * @param {function} callback - invoked when all elements processed\n */\nfunction iterate(list, iterator, state, callback)\n{\n  // store current index\n  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;\n\n  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)\n  {\n    // don't repeat yourself\n    // skip secondary callbacks\n    if (!(key in state.jobs))\n    {\n      return;\n    }\n\n    // clean up jobs\n    delete state.jobs[key];\n\n    if (error)\n    {\n      // don't process rest of the results\n      // stop still active jobs\n      // and reset the list\n      abort(state);\n    }\n    else\n    {\n      state.results[key] = output;\n    }\n\n    // return salvaged results\n    callback(error, state.results);\n  });\n}\n\n/**\n * Runs iterator over provided job element\n *\n * @param   {function} iterator - iterator to invoke\n * @param   {string|number} key - key/index of the element in the list of jobs\n * @param   {mixed} item - job description\n * @param   {function} callback - invoked after iterator is done with the job\n * @returns {function|mixed} - job abort function or something else\n */\nfunction runJob(iterator, key, item, callback)\n{\n  var aborter;\n\n  // allow shortcut if iterator expects only two arguments\n  if (iterator.length == 2)\n  {\n    aborter = iterator(item, async(callback));\n  }\n  // otherwise go with full three arguments\n  else\n  {\n    aborter = iterator(item, key, async(callback));\n  }\n\n  return aborter;\n}\n","// API\nmodule.exports = state;\n\n/**\n * Creates initial state object\n * for iteration over list\n *\n * @param   {array|object} list - list to iterate over\n * @param   {function|null} sortMethod - function to use for keys sort,\n *                                     or `null` to keep them as is\n * @returns {object} - initial state object\n */\nfunction state(list, sortMethod)\n{\n  var isNamedList = !Array.isArray(list)\n    , initState =\n    {\n      index    : 0,\n      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,\n      jobs     : {},\n      results  : isNamedList ? {} : [],\n      size     : isNamedList ? Object.keys(list).length : list.length\n    }\n    ;\n\n  if (sortMethod)\n  {\n    // sort array keys based on it's values\n    // sort object's keys just on own merit\n    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)\n    {\n      return sortMethod(list[a], list[b]);\n    });\n  }\n\n  return initState;\n}\n","var abort = require('./abort.js')\n  , async = require('./async.js')\n  ;\n\n// API\nmodule.exports = terminator;\n\n/**\n * Terminates jobs in the attached state context\n *\n * @this  AsyncKitState#\n * @param {function} callback - final callback to invoke after termination\n */\nfunction terminator(callback)\n{\n  if (!Object.keys(this.jobs).length)\n  {\n    return;\n  }\n\n  // fast forward iteration index\n  this.index = this.size;\n\n  // abort jobs\n  abort(this);\n\n  // send back results we have so far\n  async(callback)(null, this.results);\n}\n","var iterate    = require('./lib/iterate.js')\n  , initState  = require('./lib/state.js')\n  , terminator = require('./lib/terminator.js')\n  ;\n\n// Public API\nmodule.exports = parallel;\n\n/**\n * Runs iterator over provided array elements in parallel\n *\n * @param   {array|object} list - array or object (named list) to iterate over\n * @param   {function} iterator - iterator to run\n * @param   {function} callback - invoked when all elements processed\n * @returns {function} - jobs terminator\n */\nfunction parallel(list, iterator, callback)\n{\n  var state = initState(list);\n\n  while (state.index < (state['keyedList'] || list).length)\n  {\n    iterate(list, iterator, state, function(error, result)\n    {\n      if (error)\n      {\n        callback(error, result);\n        return;\n      }\n\n      // looks like it's the last one\n      if (Object.keys(state.jobs).length === 0)\n      {\n        callback(null, state.results);\n        return;\n      }\n    });\n\n    state.index++;\n  }\n\n  return terminator.bind(state, callback);\n}\n","var serialOrdered = require('./serialOrdered.js');\n\n// Public API\nmodule.exports = serial;\n\n/**\n * Runs iterator over provided array elements in series\n *\n * @param   {array|object} list - array or object (named list) to iterate over\n * @param   {function} iterator - iterator to run\n * @param   {function} callback - invoked when all elements processed\n * @returns {function} - jobs terminator\n */\nfunction serial(list, iterator, callback)\n{\n  return serialOrdered(list, iterator, null, callback);\n}\n","var iterate    = require('./lib/iterate.js')\n  , initState  = require('./lib/state.js')\n  , terminator = require('./lib/terminator.js')\n  ;\n\n// Public API\nmodule.exports = serialOrdered;\n// sorting helpers\nmodule.exports.ascending  = ascending;\nmodule.exports.descending = descending;\n\n/**\n * Runs iterator over provided sorted array elements in series\n *\n * @param   {array|object} list - array or object (named list) to iterate over\n * @param   {function} iterator - iterator to run\n * @param   {function} sortMethod - custom sort function\n * @param   {function} callback - invoked when all elements processed\n * @returns {function} - jobs terminator\n */\nfunction serialOrdered(list, iterator, sortMethod, callback)\n{\n  var state = initState(list, sortMethod);\n\n  iterate(list, iterator, state, function iteratorHandler(error, result)\n  {\n    if (error)\n    {\n      callback(error, result);\n      return;\n    }\n\n    state.index++;\n\n    // are we there yet?\n    if (state.index < (state['keyedList'] || list).length)\n    {\n      iterate(list, iterator, state, iteratorHandler);\n      return;\n    }\n\n    // done here\n    callback(null, state.results);\n  });\n\n  return terminator.bind(state, callback);\n}\n\n/*\n * -- Sort methods\n */\n\n/**\n * sort helper to sort array elements in ascending order\n *\n * @param   {mixed} a - an item to compare\n * @param   {mixed} b - an item to compare\n * @returns {number} - comparison result\n */\nfunction ascending(a, b)\n{\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\n/**\n * sort helper to sort array elements in descending order\n *\n * @param   {mixed} a - an item to compare\n * @param   {mixed} b - an item to compare\n * @returns {number} - comparison result\n */\nfunction descending(a, b)\n{\n  return -1 * ascending(a, b);\n}\n","module.exports = require('./lib/axios');","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildURL = require('./../helpers/buildURL');\nvar http = require('http');\nvar https = require('https');\nvar httpFollow = require('follow-redirects').http;\nvar httpsFollow = require('follow-redirects').https;\nvar url = require('url');\nvar zlib = require('zlib');\nvar pkg = require('./../../package.json');\nvar createError = require('../core/createError');\nvar enhanceError = require('../core/enhanceError');\n\n/*eslint consistent-return:0*/\nmodule.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolve, reject) {\n    var data = config.data;\n    var headers = config.headers;\n    var timer;\n\n    // Set User-Agent (required by some servers)\n    // Only set header if it hasn't been set in config\n    // See https://github.com/axios/axios/issues/69\n    if (!headers['User-Agent'] && !headers['user-agent']) {\n      headers['User-Agent'] = 'axios/' + pkg.version;\n    }\n\n    if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = new Buffer(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = new Buffer(data, 'utf-8');\n      } else {\n        return reject(createError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers['Content-Length'] = data.length;\n    }\n\n    // HTTP basic authentication\n    var auth = undefined;\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    // Parse url\n    var parsed = url.parse(config.url);\n    var protocol = parsed.protocol || 'http:';\n\n    if (!auth && parsed.auth) {\n      var urlAuth = parsed.auth.split(':');\n      var urlUsername = urlAuth[0] || '';\n      var urlPassword = urlAuth[1] || '';\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    if (auth) {\n      delete headers.Authorization;\n    }\n\n    var isHttps = protocol === 'https:';\n    var agent = isHttps ? config.httpsAgent : config.httpAgent;\n\n    var options = {\n      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''),\n      method: config.method,\n      headers: headers,\n      agent: agent,\n      auth: auth\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n    }\n\n    var proxy = config.proxy;\n    if (!proxy && proxy !== false) {\n      var proxyEnv = protocol.slice(0, -1) + '_proxy';\n      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];\n      if (proxyUrl) {\n        var parsedProxyUrl = url.parse(proxyUrl);\n        proxy = {\n          host: parsedProxyUrl.hostname,\n          port: parsedProxyUrl.port\n        };\n\n        if (parsedProxyUrl.auth) {\n          var proxyUrlAuth = parsedProxyUrl.auth.split(':');\n          proxy.auth = {\n            username: proxyUrlAuth[0],\n            password: proxyUrlAuth[1]\n          };\n        }\n      }\n    }\n\n    if (proxy) {\n      options.hostname = proxy.host;\n      options.host = proxy.host;\n      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');\n      options.port = proxy.port;\n      options.path = protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path;\n\n      // Basic proxy authorization\n      if (proxy.auth) {\n        var base64 = new Buffer(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');\n        options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n      }\n    }\n\n    var transport;\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttps ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      transport = isHttps ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxContentLength && config.maxContentLength > -1) {\n      options.maxBodyLength = config.maxContentLength;\n    }\n\n    // Create the request\n    var req = transport.request(options, function handleResponse(res) {\n      if (req.aborted) return;\n\n      // Response has been received so kill timer that handles request timeout\n      clearTimeout(timer);\n      timer = null;\n\n      // uncompress the response body transparently if required\n      var stream = res;\n      switch (res.headers['content-encoding']) {\n      /*eslint default-case:0*/\n      case 'gzip':\n      case 'compress':\n      case 'deflate':\n        // add the unzipper to the body stream processing pipeline\n        stream = stream.pipe(zlib.createUnzip());\n\n        // remove the content-encoding in order to not confuse downstream operations\n        delete res.headers['content-encoding'];\n        break;\n      }\n\n      // return the last request in case of redirects\n      var lastRequest = res.req || req;\n\n      var response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: res.headers,\n        config: config,\n        request: lastRequest\n      };\n\n      if (config.responseType === 'stream') {\n        response.data = stream;\n        settle(resolve, reject, response);\n      } else {\n        var responseBuffer = [];\n        stream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {\n            stream.destroy();\n            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              config, null, lastRequest));\n          }\n        });\n\n        stream.on('error', function handleStreamError(err) {\n          if (req.aborted) return;\n          reject(enhanceError(err, config, null, lastRequest));\n        });\n\n        stream.on('end', function handleStreamEnd() {\n          var responseData = Buffer.concat(responseBuffer);\n          if (config.responseType !== 'arraybuffer') {\n            responseData = responseData.toString('utf8');\n          }\n\n          response.data = responseData;\n          settle(resolve, reject, response);\n        });\n      }\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      if (req.aborted) return;\n      reject(enhanceError(err, config, null, req));\n    });\n\n    // Handle request timeout\n    if (config.timeout && !timer) {\n      timer = setTimeout(function handleRequestTimeout() {\n        req.abort();\n        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', req));\n      }, config.timeout);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (req.aborted) return;\n\n        req.abort();\n        reject(cancel);\n      });\n    }\n\n    // Send the request\n    if (utils.isStream(data)) {\n      data.pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildURL = require('./../helpers/buildURL');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    // Listen for ready state\n    request.onreadystatechange = function handleLoad() {\n      if (!request || request.readyState !== 4) {\n        return;\n      }\n\n      // The request errored out and we didn't get a response, this will be\n      // handled by onerror instead\n      // With one exception: request that using file: protocol, most browsers\n      // will return status as 0 even though it's a successful request\n      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n        return;\n      }\n\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      var cookies = require('./../helpers/cookies');\n\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?\n          cookies.read(config.xsrfCookieName) :\n          undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (config.withCredentials) {\n      request.withCredentials = true;\n    }\n\n    // Add responseType to request if needed\n    if (config.responseType) {\n      try {\n        request.responseType = config.responseType;\n      } catch (e) {\n        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.\n        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.\n        if (config.responseType !== 'json') {\n          throw e;\n        }\n      }\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (requestData === undefined) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(utils.merge(defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar defaults = require('./../defaults');\nvar utils = require('./../utils');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\n\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = utils.merge({\n      url: arguments[0]\n    }, arguments[1]);\n  }\n\n  config = utils.merge(defaults, {method: 'get'}, this.defaults, config);\n  config.method = config.method.toLowerCase();\n\n  // Hook up interceptors middleware\n  var chain = [dispatchRequest, undefined];\n  var promise = Promise.resolve(config);\n\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    chain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    chain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  while (chain.length) {\n    promise = promise.then(chain.shift(), chain.shift());\n  }\n\n  return promise;\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(utils.merge(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\nvar isAbsoluteURL = require('./../helpers/isAbsoluteURL');\nvar combineURLs = require('./../helpers/combineURLs');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Support baseURL config\n  if (config.baseURL && !isAbsoluteURL(config.url)) {\n    config.url = combineURLs(config.baseURL, config.url);\n  }\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData(\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers || {}\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData(\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData(\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n  error.request = request;\n  error.response = response;\n  return error;\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  // Note: status is not exposed by XDomainRequest\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nvar defaults = {\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Content-Type');\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data)) {\n      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');\n      return JSON.stringify(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    /*eslint no-param-reassign:0*/\n    if (typeof data === 'string') {\n      try {\n        data = JSON.parse(data);\n      } catch (e) { /* Ignore */ }\n    }\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%40/gi, '@').\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n  (function standardBrowserEnv() {\n    return {\n      write: function write(name, value, expires, path, domain, secure) {\n        var cookie = [];\n        cookie.push(name + '=' + encodeURIComponent(value));\n\n        if (utils.isNumber(expires)) {\n          cookie.push('expires=' + new Date(expires).toGMTString());\n        }\n\n        if (utils.isString(path)) {\n          cookie.push('path=' + path);\n        }\n\n        if (utils.isString(domain)) {\n          cookie.push('domain=' + domain);\n        }\n\n        if (secure === true) {\n          cookie.push('secure');\n        }\n\n        document.cookie = cookie.join('; ');\n      },\n\n      read: function read(name) {\n        var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n        return (match ? decodeURIComponent(match[3]) : null);\n      },\n\n      remove: function remove(name) {\n        this.write(name, '', Date.now() - 86400000);\n      }\n    };\n  })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return {\n      write: function write() {},\n      read: function read() { return null; },\n      remove: function remove() {}\n    };\n  })()\n);\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  (function standardBrowserEnv() {\n    var msie = /(msie|trident)/i.test(navigator.userAgent);\n    var urlParsingNode = document.createElement('a');\n    var originURL;\n\n    /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n    function resolveURL(url) {\n      var href = url;\n\n      if (msie) {\n        // IE needs attribute set twice to normalize properties\n        urlParsingNode.setAttribute('href', href);\n        href = urlParsingNode.href;\n      }\n\n      urlParsingNode.setAttribute('href', href);\n\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n        host: urlParsingNode.host,\n        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n        hostname: urlParsingNode.hostname,\n        port: urlParsingNode.port,\n        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n                  urlParsingNode.pathname :\n                  '/' + urlParsingNode.pathname\n      };\n    }\n\n    originURL = resolveURL(window.location.href);\n\n    /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n    return function isURLSameOrigin(requestURL) {\n      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n      return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n    };\n  })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  (function nonStandardBrowserEnv() {\n    return function isURLSameOrigin() {\n      return true;\n    };\n  })()\n);\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\nvar bind = require('./helpers/bind');\nvar isBuffer = require('is-buffer');\n\n/*global toString:true*/\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (typeof result[key] === 'object' && typeof val === 'object') {\n      result[key] = merge(result[key], val);\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim\n};\n","var util = require('util');\nvar Stream = require('stream').Stream;\nvar DelayedStream = require('delayed-stream');\n\nmodule.exports = CombinedStream;\nfunction CombinedStream() {\n  this.writable = false;\n  this.readable = true;\n  this.dataSize = 0;\n  this.maxDataSize = 2 * 1024 * 1024;\n  this.pauseStreams = true;\n\n  this._released = false;\n  this._streams = [];\n  this._currentStream = null;\n  this._insideLoop = false;\n  this._pendingNext = false;\n}\nutil.inherits(CombinedStream, Stream);\n\nCombinedStream.create = function(options) {\n  var combinedStream = new this();\n\n  options = options || {};\n  for (var option in options) {\n    combinedStream[option] = options[option];\n  }\n\n  return combinedStream;\n};\n\nCombinedStream.isStreamLike = function(stream) {\n  return (typeof stream !== 'function')\n    && (typeof stream !== 'string')\n    && (typeof stream !== 'boolean')\n    && (typeof stream !== 'number')\n    && (!Buffer.isBuffer(stream));\n};\n\nCombinedStream.prototype.append = function(stream) {\n  var isStreamLike = CombinedStream.isStreamLike(stream);\n\n  if (isStreamLike) {\n    if (!(stream instanceof DelayedStream)) {\n      var newStream = DelayedStream.create(stream, {\n        maxDataSize: Infinity,\n        pauseStream: this.pauseStreams,\n      });\n      stream.on('data', this._checkDataSize.bind(this));\n      stream = newStream;\n    }\n\n    this._handleErrors(stream);\n\n    if (this.pauseStreams) {\n      stream.pause();\n    }\n  }\n\n  this._streams.push(stream);\n  return this;\n};\n\nCombinedStream.prototype.pipe = function(dest, options) {\n  Stream.prototype.pipe.call(this, dest, options);\n  this.resume();\n  return dest;\n};\n\nCombinedStream.prototype._getNext = function() {\n  this._currentStream = null;\n\n  if (this._insideLoop) {\n    this._pendingNext = true;\n    return; // defer call\n  }\n\n  this._insideLoop = true;\n  try {\n    do {\n      this._pendingNext = false;\n      this._realGetNext();\n    } while (this._pendingNext);\n  } finally {\n    this._insideLoop = false;\n  }\n};\n\nCombinedStream.prototype._realGetNext = function() {\n  var stream = this._streams.shift();\n\n\n  if (typeof stream == 'undefined') {\n    this.end();\n    return;\n  }\n\n  if (typeof stream !== 'function') {\n    this._pipeNext(stream);\n    return;\n  }\n\n  var getStream = stream;\n  getStream(function(stream) {\n    var isStreamLike = CombinedStream.isStreamLike(stream);\n    if (isStreamLike) {\n      stream.on('data', this._checkDataSize.bind(this));\n      this._handleErrors(stream);\n    }\n\n    this._pipeNext(stream);\n  }.bind(this));\n};\n\nCombinedStream.prototype._pipeNext = function(stream) {\n  this._currentStream = stream;\n\n  var isStreamLike = CombinedStream.isStreamLike(stream);\n  if (isStreamLike) {\n    stream.on('end', this._getNext.bind(this));\n    stream.pipe(this, {end: false});\n    return;\n  }\n\n  var value = stream;\n  this.write(value);\n  this._getNext();\n};\n\nCombinedStream.prototype._handleErrors = function(stream) {\n  var self = this;\n  stream.on('error', function(err) {\n    self._emitError(err);\n  });\n};\n\nCombinedStream.prototype.write = function(data) {\n  this.emit('data', data);\n};\n\nCombinedStream.prototype.pause = function() {\n  if (!this.pauseStreams) {\n    return;\n  }\n\n  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();\n  this.emit('pause');\n};\n\nCombinedStream.prototype.resume = function() {\n  if (!this._released) {\n    this._released = true;\n    this.writable = true;\n    this._getNext();\n  }\n\n  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();\n  this.emit('resume');\n};\n\nCombinedStream.prototype.end = function() {\n  this._reset();\n  this.emit('end');\n};\n\nCombinedStream.prototype.destroy = function() {\n  this._reset();\n  this.emit('close');\n};\n\nCombinedStream.prototype._reset = function() {\n  this.writable = false;\n  this._streams = [];\n  this._currentStream = null;\n};\n\nCombinedStream.prototype._checkDataSize = function() {\n  this._updateDataSize();\n  if (this.dataSize <= this.maxDataSize) {\n    return;\n  }\n\n  var message =\n    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';\n  this._emitError(new Error(message));\n};\n\nCombinedStream.prototype._updateDataSize = function() {\n  this.dataSize = 0;\n\n  var self = this;\n  this._streams.forEach(function(stream) {\n    if (!stream.dataSize) {\n      return;\n    }\n\n    self.dataSize += stream.dataSize;\n  });\n\n  if (this._currentStream && this._currentStream.dataSize) {\n    this.dataSize += this._currentStream.dataSize;\n  }\n};\n\nCombinedStream.prototype._emitError = function(err) {\n  this._reset();\n  this.emit('error', err);\n};\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [ 6, 2, 3, 4, 5, 1 ];\n\ntry {\n  var supportsColor = require('supports-color');\n  if (supportsColor && supportsColor.level >= 2) {\n    exports.colors = [\n      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,\n      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,\n      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,\n      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,\n      205, 206, 207, 208, 209, 214, 215, 220, 221\n    ];\n  }\n} catch (err) {\n  // swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(process.stderr.fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var colorCode = '\\u001b[3' + (c < 8 ? c : '8;5;' + c);\n    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = getDate() + name + ' ' + args[0];\n  }\n}\n\nfunction getDate() {\n  if (exports.inspectOpts.hideDate) {\n    return '';\n  } else {\n    return new Date().toISOString() + ' ';\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log() {\n  return process.stderr.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","var Stream = require('stream').Stream;\nvar util = require('util');\n\nmodule.exports = DelayedStream;\nfunction DelayedStream() {\n  this.source = null;\n  this.dataSize = 0;\n  this.maxDataSize = 1024 * 1024;\n  this.pauseStream = true;\n\n  this._maxDataSizeExceeded = false;\n  this._released = false;\n  this._bufferedEvents = [];\n}\nutil.inherits(DelayedStream, Stream);\n\nDelayedStream.create = function(source, options) {\n  var delayedStream = new this();\n\n  options = options || {};\n  for (var option in options) {\n    delayedStream[option] = options[option];\n  }\n\n  delayedStream.source = source;\n\n  var realEmit = source.emit;\n  source.emit = function() {\n    delayedStream._handleEmit(arguments);\n    return realEmit.apply(source, arguments);\n  };\n\n  source.on('error', function() {});\n  if (delayedStream.pauseStream) {\n    source.pause();\n  }\n\n  return delayedStream;\n};\n\nObject.defineProperty(DelayedStream.prototype, 'readable', {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    return this.source.readable;\n  }\n});\n\nDelayedStream.prototype.setEncoding = function() {\n  return this.source.setEncoding.apply(this.source, arguments);\n};\n\nDelayedStream.prototype.resume = function() {\n  if (!this._released) {\n    this.release();\n  }\n\n  this.source.resume();\n};\n\nDelayedStream.prototype.pause = function() {\n  this.source.pause();\n};\n\nDelayedStream.prototype.release = function() {\n  this._released = true;\n\n  this._bufferedEvents.forEach(function(args) {\n    this.emit.apply(this, args);\n  }.bind(this));\n  this._bufferedEvents = [];\n};\n\nDelayedStream.prototype.pipe = function() {\n  var r = Stream.prototype.pipe.apply(this, arguments);\n  this.resume();\n  return r;\n};\n\nDelayedStream.prototype._handleEmit = function(args) {\n  if (this._released) {\n    this.emit.apply(this, args);\n    return;\n  }\n\n  if (args[0] === 'data') {\n    this.dataSize += args[1].length;\n    this._checkIfMaxDataSizeExceeded();\n  }\n\n  this._bufferedEvents.push(args);\n};\n\nDelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {\n  if (this._maxDataSizeExceeded) {\n    return;\n  }\n\n  if (this.dataSize <= this.maxDataSize) {\n    return;\n  }\n\n  this._maxDataSizeExceeded = true;\n  var message =\n    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'\n  this.emit('error', new Error(message));\n};\n","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('error-stack-parser', ['stackframe'], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('stackframe'));\n    } else {\n        root.ErrorStackParser = factory(root.StackFrame);\n    }\n}(this, function ErrorStackParser(StackFrame) {\n    'use strict';\n\n    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+\\:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\n    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code\\])?$/;\n\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */\n        parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error('Cannot parse given Error object');\n            }\n        },\n\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(':') === -1) {\n                return [urlLike];\n            }\n\n            var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n            var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n            return [parts[1], parts[2] || undefined, parts[3] || undefined];\n        },\n\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !!line.match(CHROME_IE_STACK_REGEXP);\n            }, this);\n\n            return filtered.map(function(line) {\n                if (line.indexOf('(eval ') > -1) {\n                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n                    line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n                }\n                var sanitizedLine = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(');\n\n                // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n                // case it has spaces in it, as the string is split on \\s+ later on\n                var location = sanitizedLine.match(/ (\\((.+):(\\d+):(\\d+)\\)$)/);\n\n                // remove the parenthesized location from the line, if it was matched\n                sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;\n\n                var tokens = sanitizedLine.split(/\\s+/).slice(1);\n                // if a location was matched, pass it to extractLocation() otherwise pop the last token\n                var locationParts = this.extractLocation(location ? location[1] : tokens.pop());\n                var functionName = tokens.join(' ') || undefined;\n                var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n\n                return new StackFrame({\n                    functionName: functionName,\n                    fileName: fileName,\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        },\n\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n            }, this);\n\n            return filtered.map(function(line) {\n                // Throw away eval information until we implement stacktrace.js/stackframe#8\n                if (line.indexOf(' > eval') > -1) {\n                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval\\:\\d+\\:\\d+/g, ':$1');\n                }\n\n                if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {\n                    // Safari eval frames only have function names and nothing else\n                    return new StackFrame({\n                        functionName: line\n                    });\n                } else {\n                    var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n                    var matches = line.match(functionNameRegex);\n                    var functionName = matches && matches[1] ? matches[1] : undefined;\n                    var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));\n\n                    return new StackFrame({\n                        functionName: functionName,\n                        fileName: locationParts[0],\n                        lineNumber: locationParts[1],\n                        columnNumber: locationParts[2],\n                        source: line\n                    });\n                }\n            }, this);\n        },\n\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || (e.message.indexOf('\\n') > -1 &&\n                e.message.split('\\n').length > e.stacktrace.split('\\n').length)) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split('\\n');\n            var result = [];\n\n            for (var i = 2, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame({\n                        fileName: match[2],\n                        lineNumber: match[1],\n                        source: lines[i]\n                    }));\n                }\n            }\n\n            return result;\n        },\n\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split('\\n');\n            var result = [];\n\n            for (var i = 0, len = lines.length; i < len; i += 2) {\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(\n                        new StackFrame({\n                            functionName: match[3] || undefined,\n                            fileName: match[2],\n                            lineNumber: match[1],\n                            source: lines[i]\n                        })\n                    );\n                }\n            }\n\n            return result;\n        },\n\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = error.stack.split('\\n').filter(function(line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            }, this);\n\n            return filtered.map(function(line) {\n                var tokens = line.split('@');\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = (tokens.shift() || '');\n                var functionName = functionCall\n                        .replace(/<anonymous function(: (\\w+))?>/, '$2')\n                        .replace(/\\([^\\)]*\\)/g, '') || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^\\)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^\\(]+\\(([^\\)]*)\\)$/, '$1');\n                }\n                var args = (argsRaw === undefined || argsRaw === '[arguments not available]') ?\n                    undefined : argsRaw.split(',');\n\n                return new StackFrame({\n                    functionName: functionName,\n                    args: args,\n                    fileName: locationParts[0],\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        }\n    };\n}));\n","var url = require(\"url\");\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar assert = require(\"assert\");\nvar Writable = require(\"stream\").Writable;\nvar debug = require(\"debug\")(\"follow-redirects\");\n\n// RFC72314.2.1: Of the request methods defined by this specification,\n// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.\nvar SAFE_METHODS = { GET: true, HEAD: true, OPTIONS: true, TRACE: true };\n\n// Create handlers that pass events from native requests\nvar eventHandlers = Object.create(null);\n[\"abort\", \"aborted\", \"error\", \"socket\", \"timeout\"].forEach(function (event) {\n  eventHandlers[event] = function (arg) {\n    this._redirectable.emit(event, arg);\n  };\n});\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  options.headers = options.headers || {};\n  this._options = options;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\n    throw new Error(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new Error(\"Request body larger than maxBodyLength limit\"));\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data and end\n  var currentRequest = this._currentRequest;\n  this.write(data || \"\", encoding, function () {\n    currentRequest.end(null, null, callback);\n  });\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"abort\", \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\", \"setTimeout\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    this.emit(\"error\", new Error(\"Unsupported protocol \" + protocol));\n    return;\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var event in eventHandlers) {\n    /* istanbul ignore else */\n    if (event) {\n      request.on(event, eventHandlers[event]);\n    }\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext() {\n      if (i < buffers.length) {\n        var buffer = buffers[i++];\n        request.write(buffer.data, buffer.encoding, writeNext);\n      }\n      else {\n        request.end();\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: response.statusCode,\n    });\n  }\n\n  // RFC72316.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n  var location = response.headers.location;\n  if (location && this._options.followRedirects !== false &&\n      response.statusCode >= 300 && response.statusCode < 400) {\n    // RFC72316.4: A client SHOULD detect and intervene\n    // in cyclical redirections (i.e., \"infinite\" redirection loops).\n    if (++this._redirectCount > this._options.maxRedirects) {\n      this.emit(\"error\", new Error(\"Max redirects exceeded.\"));\n      return;\n    }\n\n    // RFC72316.4: Automatic redirection needs to done with\n    // care for methods not known to be safe [],\n    // since the user might not wish to redirect an unsafe request.\n    // RFC72316.4.7: The 307 (Temporary Redirect) status code indicates\n    // that the target resource resides temporarily under a different URI\n    // and the user agent MUST NOT change the request method\n    // if it performs an automatic redirection to that URI.\n    var header;\n    var headers = this._options.headers;\n    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {\n      this._options.method = \"GET\";\n      // Drop a possible entity and headers related to it\n      this._requestBodyBuffers = [];\n      for (header in headers) {\n        if (/^content-/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Drop the Host header, as the redirect might lead to a different host\n    if (!this._isRedirect) {\n      for (header in headers) {\n        if (/^host$/i.test(header)) {\n          delete headers[header];\n        }\n      }\n    }\n\n    // Perform the redirected request\n    var redirectUrl = url.resolve(this._currentUrl, location);\n    debug(\"redirecting to\", redirectUrl);\n    Object.assign(this._options, url.parse(redirectUrl));\n    this._isRedirect = true;\n    this._performRequest();\n\n    // Discard the remainder of the response to avoid waiting for data\n    response.destroy();\n  }\n  else {\n    // The response is not a redirect; return it as-is\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    wrappedProtocol.request = function (options, callback) {\n      if (typeof options === \"string\") {\n        options = url.parse(options);\n        options.maxRedirects = exports.maxRedirects;\n      }\n      else {\n        options = Object.assign({\n          protocol: protocol,\n          maxRedirects: exports.maxRedirects,\n          maxBodyLength: exports.maxBodyLength,\n        }, options);\n      }\n      options.nativeProtocols = nativeProtocols;\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    };\n\n    // Executes a GET request, following redirects\n    wrappedProtocol.get = function (options, callback) {\n      var request = wrappedProtocol.request(options, callback);\n      request.end();\n      return request;\n    };\n  });\n  return exports;\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n","var CombinedStream = require('combined-stream');\nvar util = require('util');\nvar path = require('path');\nvar http = require('http');\nvar https = require('https');\nvar parseUrl = require('url').parse;\nvar fs = require('fs');\nvar mime = require('mime-types');\nvar asynckit = require('asynckit');\nvar populate = require('./populate.js');\n\n// Public API\nmodule.exports = FormData;\n\n// make it a Stream\nutil.inherits(FormData, CombinedStream);\n\n/**\n * Create readable \"multipart/form-data\" streams.\n * Can be used to submit forms\n * and file uploads to other web applications.\n *\n * @constructor\n * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream\n */\nfunction FormData(options) {\n  if (!(this instanceof FormData)) {\n    return new FormData();\n  }\n\n  this._overheadLength = 0;\n  this._valueLength = 0;\n  this._valuesToMeasure = [];\n\n  CombinedStream.call(this);\n\n  options = options || {};\n  for (var option in options) {\n    this[option] = options[option];\n  }\n}\n\nFormData.LINE_BREAK = '\\r\\n';\nFormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';\n\nFormData.prototype.append = function(field, value, options) {\n\n  options = options || {};\n\n  // allow filename as single option\n  if (typeof options == 'string') {\n    options = {filename: options};\n  }\n\n  var append = CombinedStream.prototype.append.bind(this);\n\n  // all that streamy business can't handle numbers\n  if (typeof value == 'number') {\n    value = '' + value;\n  }\n\n  // https://github.com/felixge/node-form-data/issues/38\n  if (util.isArray(value)) {\n    // Please convert your array into string\n    // the way web server expects it\n    this._error(new Error('Arrays are not supported.'));\n    return;\n  }\n\n  var header = this._multiPartHeader(field, value, options);\n  var footer = this._multiPartFooter();\n\n  append(header);\n  append(value);\n  append(footer);\n\n  // pass along options.knownLength\n  this._trackLength(header, value, options);\n};\n\nFormData.prototype._trackLength = function(header, value, options) {\n  var valueLength = 0;\n\n  // used w/ getLengthSync(), when length is known.\n  // e.g. for streaming directly from a remote server,\n  // w/ a known file a size, and not wanting to wait for\n  // incoming file to finish to get its size.\n  if (options.knownLength != null) {\n    valueLength += +options.knownLength;\n  } else if (Buffer.isBuffer(value)) {\n    valueLength = value.length;\n  } else if (typeof value === 'string') {\n    valueLength = Buffer.byteLength(value);\n  }\n\n  this._valueLength += valueLength;\n\n  // @check why add CRLF? does this account for custom/multiple CRLFs?\n  this._overheadLength +=\n    Buffer.byteLength(header) +\n    FormData.LINE_BREAK.length;\n\n  // empty or either doesn't have path or not an http response\n  if (!value || ( !value.path && !(value.readable && value.hasOwnProperty('httpVersion')) )) {\n    return;\n  }\n\n  // no need to bother with the length\n  if (!options.knownLength) {\n    this._valuesToMeasure.push(value);\n  }\n};\n\nFormData.prototype._lengthRetriever = function(value, callback) {\n\n  if (value.hasOwnProperty('fd')) {\n\n    // take read range into a account\n    // `end` = Infinity > read file till the end\n    //\n    // TODO: Looks like there is bug in Node fs.createReadStream\n    // it doesn't respect `end` options without `start` options\n    // Fix it when node fixes it.\n    // https://github.com/joyent/node/issues/7819\n    if (value.end != undefined && value.end != Infinity && value.start != undefined) {\n\n      // when end specified\n      // no need to calculate range\n      // inclusive, starts with 0\n      callback(null, value.end + 1 - (value.start ? value.start : 0));\n\n    // not that fast snoopy\n    } else {\n      // still need to fetch file size from fs\n      fs.stat(value.path, function(err, stat) {\n\n        var fileSize;\n\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        // update final size based on the range options\n        fileSize = stat.size - (value.start ? value.start : 0);\n        callback(null, fileSize);\n      });\n    }\n\n  // or http response\n  } else if (value.hasOwnProperty('httpVersion')) {\n    callback(null, +value.headers['content-length']);\n\n  // or request stream http://github.com/mikeal/request\n  } else if (value.hasOwnProperty('httpModule')) {\n    // wait till response come back\n    value.on('response', function(response) {\n      value.pause();\n      callback(null, +response.headers['content-length']);\n    });\n    value.resume();\n\n  // something else\n  } else {\n    callback('Unknown stream');\n  }\n};\n\nFormData.prototype._multiPartHeader = function(field, value, options) {\n  // custom header specified (as string)?\n  // it becomes responsible for boundary\n  // (e.g. to handle extra CRLFs on .NET servers)\n  if (typeof options.header == 'string') {\n    return options.header;\n  }\n\n  var contentDisposition = this._getContentDisposition(value, options);\n  var contentType = this._getContentType(value, options);\n\n  var contents = '';\n  var headers  = {\n    // add custom disposition as third element or keep it two elements if not\n    'Content-Disposition': ['form-data', 'name=\"' + field + '\"'].concat(contentDisposition || []),\n    // if no content type. allow it to be empty array\n    'Content-Type': [].concat(contentType || [])\n  };\n\n  // allow custom headers.\n  if (typeof options.header == 'object') {\n    populate(headers, options.header);\n  }\n\n  var header;\n  for (var prop in headers) {\n    if (!headers.hasOwnProperty(prop)) continue;\n    header = headers[prop];\n\n    // skip nullish headers.\n    if (header == null) {\n      continue;\n    }\n\n    // convert all headers to arrays.\n    if (!Array.isArray(header)) {\n      header = [header];\n    }\n\n    // add non-empty headers.\n    if (header.length) {\n      contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;\n    }\n  }\n\n  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;\n};\n\nFormData.prototype._getContentDisposition = function(value, options) {\n\n  var filename\n    , contentDisposition\n    ;\n\n  if (typeof options.filepath === 'string') {\n    // custom filepath for relative paths\n    filename = path.normalize(options.filepath).replace(/\\\\/g, '/');\n  } else if (options.filename || value.name || value.path) {\n    // custom filename take precedence\n    // formidable and the browser add a name property\n    // fs- and request- streams have path property\n    filename = path.basename(options.filename || value.name || value.path);\n  } else if (value.readable && value.hasOwnProperty('httpVersion')) {\n    // or try http response\n    filename = path.basename(value.client._httpMessage.path || '');\n  }\n\n  if (filename) {\n    contentDisposition = 'filename=\"' + filename + '\"';\n  }\n\n  return contentDisposition;\n};\n\nFormData.prototype._getContentType = function(value, options) {\n\n  // use custom content-type above all\n  var contentType = options.contentType;\n\n  // or try `name` from formidable, browser\n  if (!contentType && value.name) {\n    contentType = mime.lookup(value.name);\n  }\n\n  // or try `path` from fs-, request- streams\n  if (!contentType && value.path) {\n    contentType = mime.lookup(value.path);\n  }\n\n  // or if it's http-reponse\n  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {\n    contentType = value.headers['content-type'];\n  }\n\n  // or guess it from the filepath or filename\n  if (!contentType && (options.filepath || options.filename)) {\n    contentType = mime.lookup(options.filepath || options.filename);\n  }\n\n  // fallback to the default content type if `value` is not simple value\n  if (!contentType && typeof value == 'object') {\n    contentType = FormData.DEFAULT_CONTENT_TYPE;\n  }\n\n  return contentType;\n};\n\nFormData.prototype._multiPartFooter = function() {\n  return function(next) {\n    var footer = FormData.LINE_BREAK;\n\n    var lastPart = (this._streams.length === 0);\n    if (lastPart) {\n      footer += this._lastBoundary();\n    }\n\n    next(footer);\n  }.bind(this);\n};\n\nFormData.prototype._lastBoundary = function() {\n  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;\n};\n\nFormData.prototype.getHeaders = function(userHeaders) {\n  var header;\n  var formHeaders = {\n    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()\n  };\n\n  for (header in userHeaders) {\n    if (userHeaders.hasOwnProperty(header)) {\n      formHeaders[header.toLowerCase()] = userHeaders[header];\n    }\n  }\n\n  return formHeaders;\n};\n\nFormData.prototype.getBoundary = function() {\n  if (!this._boundary) {\n    this._generateBoundary();\n  }\n\n  return this._boundary;\n};\n\nFormData.prototype.getBuffer = function() {\n  var dataBuffer = new Buffer.alloc( 0 );\n  var boundary = this.getBoundary();\n\n  // Create the form content. Add Line breaks to the end of data.\n  for (var i = 0, len = this._streams.length; i < len; i++) {\n    if (typeof this._streams[i] !== 'function') {\n\n      // Add content to the buffer.\n      if(Buffer.isBuffer(this._streams[i])) {\n        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);\n      }else {\n        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);\n      }\n\n      // Add break after content.\n      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {\n        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );\n      }\n    }\n  }\n\n  // Add the footer and return the Buffer object.\n  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );\n};\n\nFormData.prototype._generateBoundary = function() {\n  // This generates a 50 character boundary similar to those used by Firefox.\n  // They are optimized for boyer-moore parsing.\n  var boundary = '--------------------------';\n  for (var i = 0; i < 24; i++) {\n    boundary += Math.floor(Math.random() * 10).toString(16);\n  }\n\n  this._boundary = boundary;\n};\n\n// Note: getLengthSync DOESN'T calculate streams length\n// As workaround one can calculate file size manually\n// and add it as knownLength option\nFormData.prototype.getLengthSync = function() {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  // Don't get confused, there are 3 \"internal\" streams for each keyval pair\n  // so it basically checks if there is any value added to the form\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  // https://github.com/form-data/form-data/issues/40\n  if (!this.hasKnownLength()) {\n    // Some async length retrievers are present\n    // therefore synchronous length calculation is false.\n    // Please use getLength(callback) to get proper length\n    this._error(new Error('Cannot calculate proper length in synchronous way.'));\n  }\n\n  return knownLength;\n};\n\n// Public API to check if length of added values is known\n// https://github.com/form-data/form-data/issues/196\n// https://github.com/form-data/form-data/issues/262\nFormData.prototype.hasKnownLength = function() {\n  var hasKnownLength = true;\n\n  if (this._valuesToMeasure.length) {\n    hasKnownLength = false;\n  }\n\n  return hasKnownLength;\n};\n\nFormData.prototype.getLength = function(cb) {\n  var knownLength = this._overheadLength + this._valueLength;\n\n  if (this._streams.length) {\n    knownLength += this._lastBoundary().length;\n  }\n\n  if (!this._valuesToMeasure.length) {\n    process.nextTick(cb.bind(this, null, knownLength));\n    return;\n  }\n\n  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {\n    if (err) {\n      cb(err);\n      return;\n    }\n\n    values.forEach(function(length) {\n      knownLength += length;\n    });\n\n    cb(null, knownLength);\n  });\n};\n\nFormData.prototype.submit = function(params, cb) {\n  var request\n    , options\n    , defaults = {method: 'post'}\n    ;\n\n  // parse provided url if it's string\n  // or treat it as options object\n  if (typeof params == 'string') {\n\n    params = parseUrl(params);\n    options = populate({\n      port: params.port,\n      path: params.pathname,\n      host: params.hostname,\n      protocol: params.protocol\n    }, defaults);\n\n  // use custom params\n  } else {\n\n    options = populate(params, defaults);\n    // if no port provided use default one\n    if (!options.port) {\n      options.port = options.protocol == 'https:' ? 443 : 80;\n    }\n  }\n\n  // put that good code in getHeaders to some use\n  options.headers = this.getHeaders(params.headers);\n\n  // https if specified, fallback to http in any other case\n  if (options.protocol == 'https:') {\n    request = https.request(options);\n  } else {\n    request = http.request(options);\n  }\n\n  // get content length and fire away\n  this.getLength(function(err, length) {\n    if (err) {\n      this._error(err);\n      return;\n    }\n\n    // add content length\n    request.setHeader('Content-Length', length);\n\n    this.pipe(request);\n    if (cb) {\n      request.on('error', cb);\n      request.on('response', cb.bind(this, null));\n    }\n  }.bind(this));\n\n  return request;\n};\n\nFormData.prototype._error = function(err) {\n  if (!this.error) {\n    this.error = err;\n    this.pause();\n    this.emit('error', err);\n  }\n};\n\nFormData.prototype.toString = function () {\n  return '[object FormData]';\n};\n","// populates missing values\nmodule.exports = function(dst, src) {\n\n  Object.keys(src).forEach(function(prop)\n  {\n    dst[prop] = dst[prop] || src[prop];\n  });\n\n  return dst;\n};\n","'use strict';\nmodule.exports = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = require('./db.json')\n","/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar db = require('mime-db')\nvar extname = require('path').extname\n\n/**\n * Module variables.\n * @private\n */\n\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\nvar TEXT_TYPE_REGEXP = /^text\\//i\n\n/**\n * Module exports.\n * @public\n */\n\nexports.charset = charset\nexports.charsets = { lookup: charset }\nexports.contentType = contentType\nexports.extension = extension\nexports.extensions = Object.create(null)\nexports.lookup = lookup\nexports.types = Object.create(null)\n\n// Populate the extensions/types maps\npopulateMaps(exports.extensions, exports.types)\n\n/**\n * Get the default charset for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction charset (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n  var mime = match && db[match[1].toLowerCase()]\n\n  if (mime && mime.charset) {\n    return mime.charset\n  }\n\n  // default text/* to utf-8\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n    return 'UTF-8'\n  }\n\n  return false\n}\n\n/**\n * Create a full Content-Type header given a MIME type or extension.\n *\n * @param {string} str\n * @return {boolean|string}\n */\n\nfunction contentType (str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false\n  }\n\n  var mime = str.indexOf('/') === -1\n    ? exports.lookup(str)\n    : str\n\n  if (!mime) {\n    return false\n  }\n\n  // TODO: use content-type or other module\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime)\n    if (charset) mime += '; charset=' + charset.toLowerCase()\n  }\n\n  return mime\n}\n\n/**\n * Get the default extension for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction extension (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\n  // get extensions\n  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n  if (!exts || !exts.length) {\n    return false\n  }\n\n  return exts[0]\n}\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\n\nfunction lookup (path) {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  var extension = extname('x.' + path)\n    .toLowerCase()\n    .substr(1)\n\n  if (!extension) {\n    return false\n  }\n\n  return exports.types[extension] || false\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps (extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana']\n\n  Object.keys(db).forEach(function forEachMimeType (type) {\n    var mime = db[type]\n    var exts = mime.extensions\n\n    if (!exts || !exts.length) {\n      return\n    }\n\n    // mime -> extensions\n    extensions[type] = exts\n\n    // extension -> mime\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i]\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source)\n        var to = preference.indexOf(mime.source)\n\n        if (types[extension] !== 'application/octet-stream' &&\n          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n          // skip the remapping\n          continue\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type\n    }\n  })\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","/*!\n * Platform.js <https://mths.be/platform>\n * Copyright 2014-2018 Benjamin Tan <https://bnjmnt4n.now.sh/>\n * Copyright 2011-2013 John-David Dalton <http://allyoucanleet.com/>\n * Available under MIT license <https://mths.be/mit>\n */\n;(function() {\n  'use strict';\n\n  /** Used to determine if values are of the language type `Object`. */\n  var objectTypes = {\n    'function': true,\n    'object': true\n  };\n\n  /** Used as a reference to the global object. */\n  var root = (objectTypes[typeof window] && window) || this;\n\n  /** Backup possible global object. */\n  var oldRoot = root;\n\n  /** Detect free variable `exports`. */\n  var freeExports = objectTypes[typeof exports] && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;\n\n  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */\n  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;\n  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  /**\n   * Used as the maximum length of an array-like object.\n   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)\n   * for more details.\n   */\n  var maxSafeInteger = Math.pow(2, 53) - 1;\n\n  /** Regular expression to detect Opera. */\n  var reOpera = /\\bOpera/;\n\n  /** Possible global object. */\n  var thisBinding = this;\n\n  /** Used for native method references. */\n  var objectProto = Object.prototype;\n\n  /** Used to check for own properties of an object. */\n  var hasOwnProperty = objectProto.hasOwnProperty;\n\n  /** Used to resolve the internal `[[Class]]` of values. */\n  var toString = objectProto.toString;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Capitalizes a string value.\n   *\n   * @private\n   * @param {string} string The string to capitalize.\n   * @returns {string} The capitalized string.\n   */\n  function capitalize(string) {\n    string = String(string);\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  }\n\n  /**\n   * A utility function to clean up the OS name.\n   *\n   * @private\n   * @param {string} os The OS name to clean up.\n   * @param {string} [pattern] A `RegExp` pattern matching the OS name.\n   * @param {string} [label] A label for the OS.\n   */\n  function cleanupOS(os, pattern, label) {\n    // Platform tokens are defined at:\n    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx\n    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx\n    var data = {\n      '10.0': '10',\n      '6.4':  '10 Technical Preview',\n      '6.3':  '8.1',\n      '6.2':  '8',\n      '6.1':  'Server 2008 R2 / 7',\n      '6.0':  'Server 2008 / Vista',\n      '5.2':  'Server 2003 / XP 64-bit',\n      '5.1':  'XP',\n      '5.01': '2000 SP1',\n      '5.0':  '2000',\n      '4.0':  'NT',\n      '4.90': 'ME'\n    };\n    // Detect Windows version from platform tokens.\n    if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) &&\n        (data = data[/[\\d.]+$/.exec(os)])) {\n      os = 'Windows ' + data;\n    }\n    // Correct character case and cleanup string.\n    os = String(os);\n\n    if (pattern && label) {\n      os = os.replace(RegExp(pattern, 'i'), label);\n    }\n\n    os = format(\n      os.replace(/ ce$/i, ' CE')\n        .replace(/\\bhpw/i, 'web')\n        .replace(/\\bMacintosh\\b/, 'Mac OS')\n        .replace(/_PowerPC\\b/i, ' OS')\n        .replace(/\\b(OS X) [^ \\d]+/i, '$1')\n        .replace(/\\bMac (OS X)\\b/, '$1')\n        .replace(/\\/(\\d)/, ' $1')\n        .replace(/_/g, '.')\n        .replace(/(?: BePC|[ .]*fc[ \\d.]+)$/i, '')\n        .replace(/\\bx86\\.64\\b/gi, 'x86_64')\n        .replace(/\\b(Windows Phone) OS\\b/, '$1')\n        .replace(/\\b(Chrome OS \\w+) [\\d.]+\\b/, '$1')\n        .split(' on ')[0]\n    );\n\n    return os;\n  }\n\n  /**\n   * An iteration utility for arrays and objects.\n   *\n   * @private\n   * @param {Array|Object} object The object to iterate over.\n   * @param {Function} callback The function called per iteration.\n   */\n  function each(object, callback) {\n    var index = -1,\n        length = object ? object.length : 0;\n\n    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {\n      while (++index < length) {\n        callback(object[index], index, object);\n      }\n    } else {\n      forOwn(object, callback);\n    }\n  }\n\n  /**\n   * Trim and conditionally capitalize string values.\n   *\n   * @private\n   * @param {string} string The string to format.\n   * @returns {string} The formatted string.\n   */\n  function format(string) {\n    string = trim(string);\n    return /^(?:webOS|i(?:OS|P))/.test(string)\n      ? string\n      : capitalize(string);\n  }\n\n  /**\n   * Iterates over an object's own properties, executing the `callback` for each.\n   *\n   * @private\n   * @param {Object} object The object to iterate over.\n   * @param {Function} callback The function executed per own property.\n   */\n  function forOwn(object, callback) {\n    for (var key in object) {\n      if (hasOwnProperty.call(object, key)) {\n        callback(object[key], key, object);\n      }\n    }\n  }\n\n  /**\n   * Gets the internal `[[Class]]` of a value.\n   *\n   * @private\n   * @param {*} value The value.\n   * @returns {string} The `[[Class]]`.\n   */\n  function getClassOf(value) {\n    return value == null\n      ? capitalize(value)\n      : toString.call(value).slice(8, -1);\n  }\n\n  /**\n   * Host objects can return type values that are different from their actual\n   * data type. The objects we are concerned with usually return non-primitive\n   * types of \"object\", \"function\", or \"unknown\".\n   *\n   * @private\n   * @param {*} object The owner of the property.\n   * @param {string} property The property to check.\n   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.\n   */\n  function isHostType(object, property) {\n    var type = object != null ? typeof object[property] : 'number';\n    return !/^(?:boolean|number|string|undefined)$/.test(type) &&\n      (type == 'object' ? !!object[property] : true);\n  }\n\n  /**\n   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.\n   *\n   * @private\n   * @param {string} string The string to qualify.\n   * @returns {string} The qualified string.\n   */\n  function qualify(string) {\n    return String(string).replace(/([ -])(?!$)/g, '$1?');\n  }\n\n  /**\n   * A bare-bones `Array#reduce` like utility function.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} callback The function called per iteration.\n   * @returns {*} The accumulated result.\n   */\n  function reduce(array, callback) {\n    var accumulator = null;\n    each(array, function(value, index) {\n      accumulator = callback(accumulator, value, index, array);\n    });\n    return accumulator;\n  }\n\n  /**\n   * Removes leading and trailing whitespace from a string.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} The trimmed string.\n   */\n  function trim(string) {\n    return String(string).replace(/^ +| +$/g, '');\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Creates a new platform object.\n   *\n   * @memberOf platform\n   * @param {Object|string} [ua=navigator.userAgent] The user agent string or\n   *  context object.\n   * @returns {Object} A platform object.\n   */\n  function parse(ua) {\n\n    /** The environment context object. */\n    var context = root;\n\n    /** Used to flag when a custom context is provided. */\n    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';\n\n    // Juggle arguments.\n    if (isCustomContext) {\n      context = ua;\n      ua = null;\n    }\n\n    /** Browser navigator object. */\n    var nav = context.navigator || {};\n\n    /** Browser user agent string. */\n    var userAgent = nav.userAgent || '';\n\n    ua || (ua = userAgent);\n\n    /** Used to flag when `thisBinding` is the [ModuleScope]. */\n    var isModuleScope = isCustomContext || thisBinding == oldRoot;\n\n    /** Used to detect if browser is like Chrome. */\n    var likeChrome = isCustomContext\n      ? !!nav.likeChrome\n      : /\\bChrome\\b/.test(ua) && !/internal|\\n/i.test(toString.toString());\n\n    /** Internal `[[Class]]` value shortcuts. */\n    var objectClass = 'Object',\n        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',\n        enviroClass = isCustomContext ? objectClass : 'Environment',\n        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),\n        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';\n\n    /** Detect Java environments. */\n    var java = /\\bJava/.test(javaClass) && context.java;\n\n    /** Detect Rhino. */\n    var rhino = java && getClassOf(context.environment) == enviroClass;\n\n    /** A character to represent alpha. */\n    var alpha = java ? 'a' : '\\u03b1';\n\n    /** A character to represent beta. */\n    var beta = java ? 'b' : '\\u03b2';\n\n    /** Browser document object. */\n    var doc = context.document || {};\n\n    /**\n     * Detect Opera browser (Presto-based).\n     * http://www.howtocreate.co.uk/operaStuff/operaObject.html\n     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini\n     */\n    var opera = context.operamini || context.opera;\n\n    /** Opera `[[Class]]`. */\n    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))\n      ? operaClass\n      : (opera = null);\n\n    /*------------------------------------------------------------------------*/\n\n    /** Temporary variable used over the script's lifetime. */\n    var data;\n\n    /** The CPU architecture. */\n    var arch = ua;\n\n    /** Platform description array. */\n    var description = [];\n\n    /** Platform alpha/beta indicator. */\n    var prerelease = null;\n\n    /** A flag to indicate that environment features should be used to resolve the platform. */\n    var useFeatures = ua == userAgent;\n\n    /** The browser/environment version. */\n    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();\n\n    /** A flag to indicate if the OS ends with \"/ Version\" */\n    var isSpecialCasedOS;\n\n    /* Detectable layout engines (order is important). */\n    var layout = getLayout([\n      { 'label': 'EdgeHTML', 'pattern': 'Edge' },\n      'Trident',\n      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },\n      'iCab',\n      'Presto',\n      'NetFront',\n      'Tasman',\n      'KHTML',\n      'Gecko'\n    ]);\n\n    /* Detectable browser names (order is important). */\n    var name = getName([\n      'Adobe AIR',\n      'Arora',\n      'Avant Browser',\n      'Breach',\n      'Camino',\n      'Electron',\n      'Epiphany',\n      'Fennec',\n      'Flock',\n      'Galeon',\n      'GreenBrowser',\n      'iCab',\n      'Iceweasel',\n      'K-Meleon',\n      'Konqueror',\n      'Lunascape',\n      'Maxthon',\n      { 'label': 'Microsoft Edge', 'pattern': 'Edge' },\n      'Midori',\n      'Nook Browser',\n      'PaleMoon',\n      'PhantomJS',\n      'Raven',\n      'Rekonq',\n      'RockMelt',\n      { 'label': 'Samsung Internet', 'pattern': 'SamsungBrowser' },\n      'SeaMonkey',\n      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },\n      'Sleipnir',\n      'SlimBrowser',\n      { 'label': 'SRWare Iron', 'pattern': 'Iron' },\n      'Sunrise',\n      'Swiftfox',\n      'Waterfox',\n      'WebPositive',\n      'Opera Mini',\n      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },\n      'Opera',\n      { 'label': 'Opera', 'pattern': 'OPR' },\n      'Chrome',\n      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },\n      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },\n      { 'label': 'Firefox for iOS', 'pattern': 'FxiOS' },\n      { 'label': 'IE', 'pattern': 'IEMobile' },\n      { 'label': 'IE', 'pattern': 'MSIE' },\n      'Safari'\n    ]);\n\n    /* Detectable products (order is important). */\n    var product = getProduct([\n      { 'label': 'BlackBerry', 'pattern': 'BB10' },\n      'BlackBerry',\n      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },\n      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },\n      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },\n      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },\n      { 'label': 'Galaxy S5', 'pattern': 'SM-G900' },\n      { 'label': 'Galaxy S6', 'pattern': 'SM-G920' },\n      { 'label': 'Galaxy S6 Edge', 'pattern': 'SM-G925' },\n      { 'label': 'Galaxy S7', 'pattern': 'SM-G930' },\n      { 'label': 'Galaxy S7 Edge', 'pattern': 'SM-G935' },\n      'Google TV',\n      'Lumia',\n      'iPad',\n      'iPod',\n      'iPhone',\n      'Kindle',\n      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },\n      'Nexus',\n      'Nook',\n      'PlayBook',\n      'PlayStation Vita',\n      'PlayStation',\n      'TouchPad',\n      'Transformer',\n      { 'label': 'Wii U', 'pattern': 'WiiU' },\n      'Wii',\n      'Xbox One',\n      { 'label': 'Xbox 360', 'pattern': 'Xbox' },\n      'Xoom'\n    ]);\n\n    /* Detectable manufacturers. */\n    var manufacturer = getManufacturer({\n      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },\n      'Archos': {},\n      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },\n      'Asus': { 'Transformer': 1 },\n      'Barnes & Noble': { 'Nook': 1 },\n      'BlackBerry': { 'PlayBook': 1 },\n      'Google': { 'Google TV': 1, 'Nexus': 1 },\n      'HP': { 'TouchPad': 1 },\n      'HTC': {},\n      'LG': {},\n      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },\n      'Motorola': { 'Xoom': 1 },\n      'Nintendo': { 'Wii U': 1,  'Wii': 1 },\n      'Nokia': { 'Lumia': 1 },\n      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },\n      'Sony': { 'PlayStation': 1, 'PlayStation Vita': 1 }\n    });\n\n    /* Detectable operating systems (order is important). */\n    var os = getOS([\n      'Windows Phone',\n      'Android',\n      'CentOS',\n      { 'label': 'Chrome OS', 'pattern': 'CrOS' },\n      'Debian',\n      'Fedora',\n      'FreeBSD',\n      'Gentoo',\n      'Haiku',\n      'Kubuntu',\n      'Linux Mint',\n      'OpenBSD',\n      'Red Hat',\n      'SuSE',\n      'Ubuntu',\n      'Xubuntu',\n      'Cygwin',\n      'Symbian OS',\n      'hpwOS',\n      'webOS ',\n      'webOS',\n      'Tablet OS',\n      'Tizen',\n      'Linux',\n      'Mac OS X',\n      'Macintosh',\n      'Mac',\n      'Windows 98;',\n      'Windows '\n    ]);\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Picks the layout engine from an array of guesses.\n     *\n     * @private\n     * @param {Array} guesses An array of guesses.\n     * @returns {null|string} The detected layout engine.\n     */\n    function getLayout(guesses) {\n      return reduce(guesses, function(result, guess) {\n        return result || RegExp('\\\\b' + (\n          guess.pattern || qualify(guess)\n        ) + '\\\\b', 'i').exec(ua) && (guess.label || guess);\n      });\n    }\n\n    /**\n     * Picks the manufacturer from an array of guesses.\n     *\n     * @private\n     * @param {Array} guesses An object of guesses.\n     * @returns {null|string} The detected manufacturer.\n     */\n    function getManufacturer(guesses) {\n      return reduce(guesses, function(result, value, key) {\n        // Lookup the manufacturer by product or scan the UA for the manufacturer.\n        return result || (\n          value[product] ||\n          value[/^[a-z]+(?: +[a-z]+\\b)*/i.exec(product)] ||\n          RegExp('\\\\b' + qualify(key) + '(?:\\\\b|\\\\w*\\\\d)', 'i').exec(ua)\n        ) && key;\n      });\n    }\n\n    /**\n     * Picks the browser name from an array of guesses.\n     *\n     * @private\n     * @param {Array} guesses An array of guesses.\n     * @returns {null|string} The detected browser name.\n     */\n    function getName(guesses) {\n      return reduce(guesses, function(result, guess) {\n        return result || RegExp('\\\\b' + (\n          guess.pattern || qualify(guess)\n        ) + '\\\\b', 'i').exec(ua) && (guess.label || guess);\n      });\n    }\n\n    /**\n     * Picks the OS name from an array of guesses.\n     *\n     * @private\n     * @param {Array} guesses An array of guesses.\n     * @returns {null|string} The detected OS name.\n     */\n    function getOS(guesses) {\n      return reduce(guesses, function(result, guess) {\n        var pattern = guess.pattern || qualify(guess);\n        if (!result && (result =\n              RegExp('\\\\b' + pattern + '(?:/[\\\\d.]+|[ \\\\w.]*)', 'i').exec(ua)\n            )) {\n          result = cleanupOS(result, pattern, guess.label || guess);\n        }\n        return result;\n      });\n    }\n\n    /**\n     * Picks the product name from an array of guesses.\n     *\n     * @private\n     * @param {Array} guesses An array of guesses.\n     * @returns {null|string} The detected product name.\n     */\n    function getProduct(guesses) {\n      return reduce(guesses, function(result, guess) {\n        var pattern = guess.pattern || qualify(guess);\n        if (!result && (result =\n              RegExp('\\\\b' + pattern + ' *\\\\d+[.\\\\w_]*', 'i').exec(ua) ||\n              RegExp('\\\\b' + pattern + ' *\\\\w+-[\\\\w]*', 'i').exec(ua) ||\n              RegExp('\\\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\\\d+|[^ ();-]*)', 'i').exec(ua)\n            )) {\n          // Split by forward slash and append product version if needed.\n          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\\d.]+/.test(result[0])) {\n            result[0] += ' ' + result[1];\n          }\n          // Correct character case and cleanup string.\n          guess = guess.label || guess;\n          result = format(result[0]\n            .replace(RegExp(pattern, 'i'), guess)\n            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')\n            .replace(RegExp('(' + guess + ')[-_.]?(\\\\w)', 'i'), '$1 $2'));\n        }\n        return result;\n      });\n    }\n\n    /**\n     * Resolves the version using an array of UA patterns.\n     *\n     * @private\n     * @param {Array} patterns An array of UA patterns.\n     * @returns {null|string} The detected version.\n     */\n    function getVersion(patterns) {\n      return reduce(patterns, function(result, pattern) {\n        return result || (RegExp(pattern +\n          '(?:-[\\\\d.]+/|(?: for [\\\\w-]+)?[ /-])([\\\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;\n      });\n    }\n\n    /**\n     * Returns `platform.description` when the platform object is coerced to a string.\n     *\n     * @name toString\n     * @memberOf platform\n     * @returns {string} Returns `platform.description` if available, else an empty string.\n     */\n    function toStringPlatform() {\n      return this.description || '';\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Convert layout to an array so we can add extra details.\n    layout && (layout = [layout]);\n\n    // Detect product names that contain their manufacturer's name.\n    if (manufacturer && !product) {\n      product = getProduct([manufacturer]);\n    }\n    // Clean up Google TV.\n    if ((data = /\\bGoogle TV\\b/.exec(product))) {\n      product = data[0];\n    }\n    // Detect simulators.\n    if (/\\bSimulator\\b/i.test(ua)) {\n      product = (product ? product + ' ' : '') + 'Simulator';\n    }\n    // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.\n    if (name == 'Opera Mini' && /\\bOPiOS\\b/.test(ua)) {\n      description.push('running in Turbo/Uncompressed mode');\n    }\n    // Detect IE Mobile 11.\n    if (name == 'IE' && /\\blike iPhone OS\\b/.test(ua)) {\n      data = parse(ua.replace(/like iPhone OS/, ''));\n      manufacturer = data.manufacturer;\n      product = data.product;\n    }\n    // Detect iOS.\n    else if (/^iP/.test(product)) {\n      name || (name = 'Safari');\n      os = 'iOS' + ((data = / OS ([\\d_]+)/i.exec(ua))\n        ? ' ' + data[1].replace(/_/g, '.')\n        : '');\n    }\n    // Detect Kubuntu.\n    else if (name == 'Konqueror' && !/buntu/i.test(os)) {\n      os = 'Kubuntu';\n    }\n    // Detect Android browsers.\n    else if ((manufacturer && manufacturer != 'Google' &&\n        ((/Chrome/.test(name) && !/\\bMobile Safari\\b/i.test(ua)) || /\\bVita\\b/.test(product))) ||\n        (/\\bAndroid\\b/.test(os) && /^Chrome/.test(name) && /\\bVersion\\//i.test(ua))) {\n      name = 'Android Browser';\n      os = /\\bAndroid\\b/.test(os) ? os : 'Android';\n    }\n    // Detect Silk desktop/accelerated modes.\n    else if (name == 'Silk') {\n      if (!/\\bMobi/i.test(ua)) {\n        os = 'Android';\n        description.unshift('desktop mode');\n      }\n      if (/Accelerated *= *true/i.test(ua)) {\n        description.unshift('accelerated');\n      }\n    }\n    // Detect PaleMoon identifying as Firefox.\n    else if (name == 'PaleMoon' && (data = /\\bFirefox\\/([\\d.]+)\\b/.exec(ua))) {\n      description.push('identifying as Firefox ' + data[1]);\n    }\n    // Detect Firefox OS and products running Firefox.\n    else if (name == 'Firefox' && (data = /\\b(Mobile|Tablet|TV)\\b/i.exec(ua))) {\n      os || (os = 'Firefox OS');\n      product || (product = data[1]);\n    }\n    // Detect false positives for Firefox/Safari.\n    else if (!name || (data = !/\\bMinefield\\b/i.test(ua) && /\\b(?:Firefox|Safari)\\b/.exec(name))) {\n      // Escape the `/` for Firefox 1.\n      if (name && !product && /[\\/,]|^[^(]+?\\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {\n        // Clear name of false positives.\n        name = null;\n      }\n      // Reassign a generic name.\n      if ((data = product || manufacturer || os) &&\n          (product || manufacturer || /\\b(?:Android|Symbian OS|Tablet OS|webOS)\\b/.test(os))) {\n        name = /[a-z]+(?: Hat)?/i.exec(/\\bAndroid\\b/.test(os) ? os : data) + ' Browser';\n      }\n    }\n    // Add Chrome version to description for Electron.\n    else if (name == 'Electron' && (data = (/\\bChrome\\/([\\d.]+)\\b/.exec(ua) || 0)[1])) {\n      description.push('Chromium ' + data);\n    }\n    // Detect non-Opera (Presto-based) versions (order is important).\n    if (!version) {\n      version = getVersion([\n        '(?:Cloud9|CriOS|CrMo|Edge|FxiOS|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\\\d.]+$))',\n        'Version',\n        qualify(name),\n        '(?:Firefox|Minefield|NetFront)'\n      ]);\n    }\n    // Detect stubborn layout engines.\n    if ((data =\n          layout == 'iCab' && parseFloat(version) > 3 && 'WebKit' ||\n          /\\bOpera\\b/.test(name) && (/\\bOPR\\b/.test(ua) ? 'Blink' : 'Presto') ||\n          /\\b(?:Midori|Nook|Safari)\\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && 'WebKit' ||\n          !layout && /\\bMSIE\\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident') ||\n          layout == 'WebKit' && /\\bPlayStation\\b(?! Vita\\b)/i.test(name) && 'NetFront'\n        )) {\n      layout = [data];\n    }\n    // Detect Windows Phone 7 desktop mode.\n    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\\d+)/i.exec(ua) || 0)[1])) {\n      name += ' Mobile';\n      os = 'Windows Phone ' + (/\\+$/.test(data) ? data : data + '.x');\n      description.unshift('desktop mode');\n    }\n    // Detect Windows Phone 8.x desktop mode.\n    else if (/\\bWPDesktop\\b/i.test(ua)) {\n      name = 'IE Mobile';\n      os = 'Windows Phone 8.x';\n      description.unshift('desktop mode');\n      version || (version = (/\\brv:([\\d.]+)/.exec(ua) || 0)[1]);\n    }\n    // Detect IE 11 identifying as other browsers.\n    else if (name != 'IE' && layout == 'Trident' && (data = /\\brv:([\\d.]+)/.exec(ua))) {\n      if (name) {\n        description.push('identifying as ' + name + (version ? ' ' + version : ''));\n      }\n      name = 'IE';\n      version = data[1];\n    }\n    // Leverage environment features.\n    if (useFeatures) {\n      // Detect server-side environments.\n      // Rhino has a global function while others have a global object.\n      if (isHostType(context, 'global')) {\n        if (java) {\n          data = java.lang.System;\n          arch = data.getProperty('os.arch');\n          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');\n        }\n        if (rhino) {\n          try {\n            version = context.require('ringo/engine').version.join('.');\n            name = 'RingoJS';\n          } catch(e) {\n            if ((data = context.system) && data.global.system == context.system) {\n              name = 'Narwhal';\n              os || (os = data[0].os || null);\n            }\n          }\n          if (!name) {\n            name = 'Rhino';\n          }\n        }\n        else if (\n          typeof context.process == 'object' && !context.process.browser &&\n          (data = context.process)\n        ) {\n          if (typeof data.versions == 'object') {\n            if (typeof data.versions.electron == 'string') {\n              description.push('Node ' + data.versions.node);\n              name = 'Electron';\n              version = data.versions.electron;\n            } else if (typeof data.versions.nw == 'string') {\n              description.push('Chromium ' + version, 'Node ' + data.versions.node);\n              name = 'NW.js';\n              version = data.versions.nw;\n            }\n          }\n          if (!name) {\n            name = 'Node.js';\n            arch = data.arch;\n            os = data.platform;\n            version = /[\\d.]+/.exec(data.version);\n            version = version ? version[0] : null;\n          }\n        }\n      }\n      // Detect Adobe AIR.\n      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {\n        name = 'Adobe AIR';\n        os = data.flash.system.Capabilities.os;\n      }\n      // Detect PhantomJS.\n      else if (getClassOf((data = context.phantom)) == phantomClass) {\n        name = 'PhantomJS';\n        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);\n      }\n      // Detect IE compatibility modes.\n      else if (typeof doc.documentMode == 'number' && (data = /\\bTrident\\/(\\d+)/i.exec(ua))) {\n        // We're in compatibility mode when the Trident version + 4 doesn't\n        // equal the document mode.\n        version = [version, doc.documentMode];\n        if ((data = +data[1] + 4) != version[1]) {\n          description.push('IE ' + version[1] + ' mode');\n          layout && (layout[1] = '');\n          version[1] = data;\n        }\n        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];\n      }\n      // Detect IE 11 masking as other browsers.\n      else if (typeof doc.documentMode == 'number' && /^(?:Chrome|Firefox)\\b/.test(name)) {\n        description.push('masking as ' + name + ' ' + version);\n        name = 'IE';\n        version = '11.0';\n        layout = ['Trident'];\n        os = 'Windows';\n      }\n      os = os && format(os);\n    }\n    // Detect prerelease phases.\n    if (version && (data =\n          /(?:[ab]|dp|pre|[ab]\\d+pre)(?:\\d+\\+?)?$/i.exec(version) ||\n          /(?:alpha|beta)(?: ?\\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||\n          /\\bMinefield\\b/i.test(ua) && 'a'\n        )) {\n      prerelease = /b/i.test(data) ? 'beta' : 'alpha';\n      version = version.replace(RegExp(data + '\\\\+?$'), '') +\n        (prerelease == 'beta' ? beta : alpha) + (/\\d+\\+?/.exec(data) || '');\n    }\n    // Detect Firefox Mobile.\n    if (name == 'Fennec' || name == 'Firefox' && /\\b(?:Android|Firefox OS)\\b/.test(os)) {\n      name = 'Firefox Mobile';\n    }\n    // Obscure Maxthon's unreliable version.\n    else if (name == 'Maxthon' && version) {\n      version = version.replace(/\\.[\\d.]+/, '.x');\n    }\n    // Detect Xbox 360 and Xbox One.\n    else if (/\\bXbox\\b/i.test(product)) {\n      if (product == 'Xbox 360') {\n        os = null;\n      }\n      if (product == 'Xbox 360' && /\\bIEMobile\\b/.test(ua)) {\n        description.unshift('mobile mode');\n      }\n    }\n    // Add mobile postfix.\n    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&\n        (os == 'Windows CE' || /Mobi/i.test(ua))) {\n      name += ' Mobile';\n    }\n    // Detect IE platform preview.\n    else if (name == 'IE' && useFeatures) {\n      try {\n        if (context.external === null) {\n          description.unshift('platform preview');\n        }\n      } catch(e) {\n        description.unshift('embedded');\n      }\n    }\n    // Detect BlackBerry OS version.\n    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp\n    else if ((/\\bBlackBerry\\b/.test(product) || /\\bBB10\\b/.test(ua)) && (data =\n          (RegExp(product.replace(/ +/g, ' *') + '/([.\\\\d]+)', 'i').exec(ua) || 0)[1] ||\n          version\n        )) {\n      data = [data, /BB10/.test(ua)];\n      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];\n      version = null;\n    }\n    // Detect Opera identifying/masking itself as another browser.\n    // http://www.opera.com/support/kb/view/843/\n    else if (this != forOwn && product != 'Wii' && (\n          (useFeatures && opera) ||\n          (/Opera/.test(name) && /\\b(?:MSIE|Firefox)\\b/i.test(ua)) ||\n          (name == 'Firefox' && /\\bOS X (?:\\d+\\.){2,}/.test(os)) ||\n          (name == 'IE' && (\n            (os && !/^Win/.test(os) && version > 5.5) ||\n            /\\bWindows XP\\b/.test(os) && version > 8 ||\n            version == 8 && !/\\bTrident\\b/.test(ua)\n          ))\n        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {\n      // When \"identifying\", the UA contains both Opera and the other browser's name.\n      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');\n      if (reOpera.test(name)) {\n        if (/\\bIE\\b/.test(data) && os == 'Mac OS') {\n          os = null;\n        }\n        data = 'identify' + data;\n      }\n      // When \"masking\", the UA contains only the other browser's name.\n      else {\n        data = 'mask' + data;\n        if (operaClass) {\n          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));\n        } else {\n          name = 'Opera';\n        }\n        if (/\\bIE\\b/.test(data)) {\n          os = null;\n        }\n        if (!useFeatures) {\n          version = null;\n        }\n      }\n      layout = ['Presto'];\n      description.push(data);\n    }\n    // Detect WebKit Nightly and approximate Chrome/Safari versions.\n    if ((data = (/\\bAppleWebKit\\/([\\d.]+\\+?)/i.exec(ua) || 0)[1])) {\n      // Correct build number for numeric comparison.\n      // (e.g. \"532.5\" becomes \"532.05\")\n      data = [parseFloat(data.replace(/\\.(\\d)$/, '.0$1')), data];\n      // Nightly builds are postfixed with a \"+\".\n      if (name == 'Safari' && data[1].slice(-1) == '+') {\n        name = 'WebKit Nightly';\n        prerelease = 'alpha';\n        version = data[1].slice(0, -1);\n      }\n      // Clear incorrect browser versions.\n      else if (version == data[1] ||\n          version == (data[2] = (/\\bSafari\\/([\\d.]+\\+?)/i.exec(ua) || 0)[1])) {\n        version = null;\n      }\n      // Use the full Chrome version when available.\n      data[1] = (/\\bChrome\\/([\\d.]+)/i.exec(ua) || 0)[1];\n      // Detect Blink layout engine.\n      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == 'WebKit') {\n        layout = ['Blink'];\n      }\n      // Detect JavaScriptCore.\n      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi\n      if (!useFeatures || (!likeChrome && !data[1])) {\n        layout && (layout[1] = 'like Safari');\n        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');\n      } else {\n        layout && (layout[1] = 'like Chrome');\n        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');\n      }\n      // Add the postfix of \".x\" or \"+\" for approximate versions.\n      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));\n      // Obscure version for some Safari 1-2 releases.\n      if (name == 'Safari' && (!version || parseInt(version) > 45)) {\n        version = data;\n      }\n    }\n    // Detect Opera desktop modes.\n    if (name == 'Opera' &&  (data = /\\bzbov|zvav$/.exec(os))) {\n      name += ' ';\n      description.unshift('desktop mode');\n      if (data == 'zvav') {\n        name += 'Mini';\n        version = null;\n      } else {\n        name += 'Mobile';\n      }\n      os = os.replace(RegExp(' *' + data + '$'), '');\n    }\n    // Detect Chrome desktop mode.\n    else if (name == 'Safari' && /\\bChrome\\b/.exec(layout && layout[1])) {\n      description.unshift('desktop mode');\n      name = 'Chrome Mobile';\n      version = null;\n\n      if (/\\bOS X\\b/.test(os)) {\n        manufacturer = 'Apple';\n        os = 'iOS 4.3+';\n      } else {\n        os = null;\n      }\n    }\n    // Strip incorrect OS versions.\n    if (version && version.indexOf((data = /[\\d.]+$/.exec(os))) == 0 &&\n        ua.indexOf('/' + data + '-') > -1) {\n      os = trim(os.replace(data, ''));\n    }\n    // Add layout engine.\n    if (layout && !/\\b(?:Avant|Nook)\\b/.test(name) && (\n        /Browser|Lunascape|Maxthon/.test(name) ||\n        name != 'Safari' && /^iOS/.test(os) && /\\bSafari\\b/.test(layout[1]) ||\n        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|Web)/.test(name) && layout[1])) {\n      // Don't add layout details to description if they are falsey.\n      (data = layout[layout.length - 1]) && description.push(data);\n    }\n    // Combine contextual information.\n    if (description.length) {\n      description = ['(' + description.join('; ') + ')'];\n    }\n    // Append manufacturer to description.\n    if (manufacturer && product && product.indexOf(manufacturer) < 0) {\n      description.push('on ' + manufacturer);\n    }\n    // Append product to description.\n    if (product) {\n      description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);\n    }\n    // Parse the OS into an object.\n    if (os) {\n      data = / ([\\d.+]+)$/.exec(os);\n      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';\n      os = {\n        'architecture': 32,\n        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,\n        'version': data ? data[1] : null,\n        'toString': function() {\n          var version = this.version;\n          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');\n        }\n      };\n    }\n    // Add browser/OS architecture.\n    if ((data = /\\b(?:AMD|IA|Win|WOW|x86_|x)64\\b/i.exec(arch)) && !/\\bi686\\b/i.test(arch)) {\n      if (os) {\n        os.architecture = 64;\n        os.family = os.family.replace(RegExp(' *' + data), '');\n      }\n      if (\n          name && (/\\bWOW64\\b/i.test(ua) ||\n          (useFeatures && /\\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\\bWin64; x64\\b/i.test(ua)))\n      ) {\n        description.unshift('32-bit');\n      }\n    }\n    // Chrome 39 and above on OS X is always 64-bit.\n    else if (\n        os && /^OS X/.test(os.family) &&\n        name == 'Chrome' && parseFloat(version) >= 39\n    ) {\n      os.architecture = 64;\n    }\n\n    ua || (ua = null);\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The platform object.\n     *\n     * @name platform\n     * @type Object\n     */\n    var platform = {};\n\n    /**\n     * The platform description.\n     *\n     * @memberOf platform\n     * @type string|null\n     */\n    platform.description = ua;\n\n    /**\n     * The name of the browser's layout engine.\n     *\n     * The list of common layout engines include:\n     * \"Blink\", \"EdgeHTML\", \"Gecko\", \"Trident\" and \"WebKit\"\n     *\n     * @memberOf platform\n     * @type string|null\n     */\n    platform.layout = layout && layout[0];\n\n    /**\n     * The name of the product's manufacturer.\n     *\n     * The list of manufacturers include:\n     * \"Apple\", \"Archos\", \"Amazon\", \"Asus\", \"Barnes & Noble\", \"BlackBerry\",\n     * \"Google\", \"HP\", \"HTC\", \"LG\", \"Microsoft\", \"Motorola\", \"Nintendo\",\n     * \"Nokia\", \"Samsung\" and \"Sony\"\n     *\n     * @memberOf platform\n     * @type string|null\n     */\n    platform.manufacturer = manufacturer;\n\n    /**\n     * The name of the browser/environment.\n     *\n     * The list of common browser names include:\n     * \"Chrome\", \"Electron\", \"Firefox\", \"Firefox for iOS\", \"IE\",\n     * \"Microsoft Edge\", \"PhantomJS\", \"Safari\", \"SeaMonkey\", \"Silk\",\n     * \"Opera Mini\" and \"Opera\"\n     *\n     * Mobile versions of some browsers have \"Mobile\" appended to their name:\n     * eg. \"Chrome Mobile\", \"Firefox Mobile\", \"IE Mobile\" and \"Opera Mobile\"\n     *\n     * @memberOf platform\n     * @type string|null\n     */\n    platform.name = name;\n\n    /**\n     * The alpha/beta release indicator.\n     *\n     * @memberOf platform\n     * @type string|null\n     */\n    platform.prerelease = prerelease;\n\n    /**\n     * The name of the product hosting the browser.\n     *\n     * The list of common products include:\n     *\n     * \"BlackBerry\", \"Galaxy S4\", \"Lumia\", \"iPad\", \"iPod\", \"iPhone\", \"Kindle\",\n     * \"Kindle Fire\", \"Nexus\", \"Nook\", \"PlayBook\", \"TouchPad\" and \"Transformer\"\n     *\n     * @memberOf platform\n     * @type string|null\n     */\n    platform.product = product;\n\n    /**\n     * The browser's user agent string.\n     *\n     * @memberOf platform\n     * @type string|null\n     */\n    platform.ua = ua;\n\n    /**\n     * The browser/environment version.\n     *\n     * @memberOf platform\n     * @type string|null\n     */\n    platform.version = name && version;\n\n    /**\n     * The name of the operating system.\n     *\n     * @memberOf platform\n     * @type Object\n     */\n    platform.os = os || {\n\n      /**\n       * The CPU architecture the OS is built for.\n       *\n       * @memberOf platform.os\n       * @type number|null\n       */\n      'architecture': null,\n\n      /**\n       * The family of the OS.\n       *\n       * Common values include:\n       * \"Windows\", \"Windows Server 2008 R2 / 7\", \"Windows Server 2008 / Vista\",\n       * \"Windows XP\", \"OS X\", \"Ubuntu\", \"Debian\", \"Fedora\", \"Red Hat\", \"SuSE\",\n       * \"Android\", \"iOS\" and \"Windows Phone\"\n       *\n       * @memberOf platform.os\n       * @type string|null\n       */\n      'family': null,\n\n      /**\n       * The version of the OS.\n       *\n       * @memberOf platform.os\n       * @type string|null\n       */\n      'version': null,\n\n      /**\n       * Returns the OS string.\n       *\n       * @memberOf platform.os\n       * @returns {string} The OS string.\n       */\n      'toString': function() { return 'null'; }\n    };\n\n    platform.parse = parse;\n    platform.toString = toStringPlatform;\n\n    if (platform.version) {\n      description.unshift(version);\n    }\n    if (platform.name) {\n      description.unshift(name);\n    }\n    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {\n      description.push(product ? '(' + os + ')' : 'on ' + os);\n    }\n    if (description.length) {\n      platform.description = description.join(' ');\n    }\n    return platform;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export platform.\n  var platform = parse();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like the following:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose platform on the global object to prevent errors when platform is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    root.platform = platform;\n\n    // Define as an anonymous module so platform can be aliased through path mapping.\n    define(function() {\n      return platform;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.\n  else if (freeExports && freeModule) {\n    // Export for CommonJS support.\n    forOwn(platform, function(value, key) {\n      freeExports[key] = value;\n    });\n  }\n  else {\n    // Export to the global object.\n    root.platform = platform;\n  }\n}.call(this));\n","(function(root, factory) {\n    'use strict';\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define('stackframe', [], factory);\n    } else if (typeof exports === 'object') {\n        module.exports = factory();\n    } else {\n        root.StackFrame = factory();\n    }\n}(this, function() {\n    'use strict';\n    function _isNumber(n) {\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    function _capitalize(str) {\n        return str.charAt(0).toUpperCase() + str.substring(1);\n    }\n\n    function _getter(p) {\n        return function() {\n            return this[p];\n        };\n    }\n\n    var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];\n    var numericProps = ['columnNumber', 'lineNumber'];\n    var stringProps = ['fileName', 'functionName', 'source'];\n    var arrayProps = ['args'];\n\n    var props = booleanProps.concat(numericProps, stringProps, arrayProps);\n\n    function StackFrame(obj) {\n        if (obj instanceof Object) {\n            for (var i = 0; i < props.length; i++) {\n                if (obj.hasOwnProperty(props[i]) && obj[props[i]] !== undefined) {\n                    this['set' + _capitalize(props[i])](obj[props[i]]);\n                }\n            }\n        }\n    }\n\n    StackFrame.prototype = {\n        getArgs: function() {\n            return this.args;\n        },\n        setArgs: function(v) {\n            if (Object.prototype.toString.call(v) !== '[object Array]') {\n                throw new TypeError('Args must be an Array');\n            }\n            this.args = v;\n        },\n\n        getEvalOrigin: function() {\n            return this.evalOrigin;\n        },\n        setEvalOrigin: function(v) {\n            if (v instanceof StackFrame) {\n                this.evalOrigin = v;\n            } else if (v instanceof Object) {\n                this.evalOrigin = new StackFrame(v);\n            } else {\n                throw new TypeError('Eval Origin must be an Object or StackFrame');\n            }\n        },\n\n        toString: function() {\n            var fileName = this.getFileName() || '';\n            var lineNumber = this.getLineNumber() || '';\n            var columnNumber = this.getColumnNumber() || '';\n            var functionName = this.getFunctionName() || '';\n            if (this.getIsEval()) {\n                if (fileName) {\n                    return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n                }\n                return '[eval]:' + lineNumber + ':' + columnNumber;\n            }\n            if (functionName) {\n                return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';\n            }\n            return fileName + ':' + lineNumber + ':' + columnNumber;\n        }\n    };\n\n    StackFrame.fromString = function StackFrame$$fromString(str) {\n        var argsStartIndex = str.indexOf('(');\n        var argsEndIndex = str.lastIndexOf(')');\n\n        var functionName = str.substring(0, argsStartIndex);\n        var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');\n        var locationString = str.substring(argsEndIndex + 1);\n\n        if (locationString.indexOf('@') === 0) {\n            var parts = /@(.+?)(?::(\\d+))?(?::(\\d+))?$/.exec(locationString, '');\n            var fileName = parts[1];\n            var lineNumber = parts[2];\n            var columnNumber = parts[3];\n        }\n\n        return new StackFrame({\n            functionName: functionName,\n            args: args || undefined,\n            fileName: fileName,\n            lineNumber: lineNumber || undefined,\n            columnNumber: columnNumber || undefined\n        });\n    };\n\n    for (var i = 0; i < booleanProps.length; i++) {\n        StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);\n        StackFrame.prototype['set' + _capitalize(booleanProps[i])] = (function(p) {\n            return function(v) {\n                this[p] = Boolean(v);\n            };\n        })(booleanProps[i]);\n    }\n\n    for (var j = 0; j < numericProps.length; j++) {\n        StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);\n        StackFrame.prototype['set' + _capitalize(numericProps[j])] = (function(p) {\n            return function(v) {\n                if (!_isNumber(v)) {\n                    throw new TypeError(p + ' must be a Number');\n                }\n                this[p] = Number(v);\n            };\n        })(numericProps[j]);\n    }\n\n    for (var k = 0; k < stringProps.length; k++) {\n        StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);\n        StackFrame.prototype['set' + _capitalize(stringProps[k])] = (function(p) {\n            return function(v) {\n                this[p] = String(v);\n            };\n        })(stringProps[k]);\n    }\n\n    return StackFrame;\n}));\n","var engine = require('../src/store-engine')\n\nvar storages = require('../storages/all')\nvar plugins = [require('../plugins/json2')]\n\nmodule.exports = engine.createStore(storages, plugins)\n","module.exports = json2Plugin\n\nfunction json2Plugin() {\n\trequire('./lib/json2')\n\treturn {}\n}\n","/* eslint-disable */\n\n//  json2.js\n//  2016-10-28\n//  Public Domain.\n//  NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n//  See http://www.JSON.org/js.html\n//  This code should be minified before deployment.\n//  See http://javascript.crockford.com/jsmin.html\n\n//  USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n//  NOT CONTROL.\n\n//  This file creates a global JSON object containing two methods: stringify\n//  and parse. This file provides the ES5 JSON capability to ES3 systems.\n//  If a project might run on IE8 or earlier, then this file should be included.\n//  This file does nothing on ES5 systems.\n\n//      JSON.stringify(value, replacer, space)\n//          value       any JavaScript value, usually an object or array.\n//          replacer    an optional parameter that determines how object\n//                      values are stringified for objects. It can be a\n//                      function or an array of strings.\n//          space       an optional parameter that specifies the indentation\n//                      of nested structures. If it is omitted, the text will\n//                      be packed without extra whitespace. If it is a number,\n//                      it will specify the number of spaces to indent at each\n//                      level. If it is a string (such as \"\\t\" or \"&nbsp;\"),\n//                      it contains the characters used to indent at each level.\n//          This method produces a JSON text from a JavaScript value.\n//          When an object value is found, if the object contains a toJSON\n//          method, its toJSON method will be called and the result will be\n//          stringified. A toJSON method does not serialize: it returns the\n//          value represented by the name/value pair that should be serialized,\n//          or undefined if nothing should be serialized. The toJSON method\n//          will be passed the key associated with the value, and this will be\n//          bound to the value.\n\n//          For example, this would serialize Dates as ISO strings.\n\n//              Date.prototype.toJSON = function (key) {\n//                  function f(n) {\n//                      // Format integers to have at least two digits.\n//                      return (n < 10)\n//                          ? \"0\" + n\n//                          : n;\n//                  }\n//                  return this.getUTCFullYear()   + \"-\" +\n//                       f(this.getUTCMonth() + 1) + \"-\" +\n//                       f(this.getUTCDate())      + \"T\" +\n//                       f(this.getUTCHours())     + \":\" +\n//                       f(this.getUTCMinutes())   + \":\" +\n//                       f(this.getUTCSeconds())   + \"Z\";\n//              };\n\n//          You can provide an optional replacer method. It will be passed the\n//          key and value of each member, with this bound to the containing\n//          object. The value that is returned from your method will be\n//          serialized. If your method returns undefined, then the member will\n//          be excluded from the serialization.\n\n//          If the replacer parameter is an array of strings, then it will be\n//          used to select the members to be serialized. It filters the results\n//          such that only members with keys listed in the replacer array are\n//          stringified.\n\n//          Values that do not have JSON representations, such as undefined or\n//          functions, will not be serialized. Such values in objects will be\n//          dropped; in arrays they will be replaced with null. You can use\n//          a replacer function to replace those with JSON values.\n\n//          JSON.stringify(undefined) returns undefined.\n\n//          The optional space parameter produces a stringification of the\n//          value that is filled with line breaks and indentation to make it\n//          easier to read.\n\n//          If the space parameter is a non-empty string, then that string will\n//          be used for indentation. If the space parameter is a number, then\n//          the indentation will be that many spaces.\n\n//          Example:\n\n//          text = JSON.stringify([\"e\", {pluribus: \"unum\"}]);\n//          // text is '[\"e\",{\"pluribus\":\"unum\"}]'\n\n//          text = JSON.stringify([\"e\", {pluribus: \"unum\"}], null, \"\\t\");\n//          // text is '[\\n\\t\"e\",\\n\\t{\\n\\t\\t\"pluribus\": \"unum\"\\n\\t}\\n]'\n\n//          text = JSON.stringify([new Date()], function (key, value) {\n//              return this[key] instanceof Date\n//                  ? \"Date(\" + this[key] + \")\"\n//                  : value;\n//          });\n//          // text is '[\"Date(---current time---)\"]'\n\n//      JSON.parse(text, reviver)\n//          This method parses a JSON text to produce an object or array.\n//          It can throw a SyntaxError exception.\n\n//          The optional reviver parameter is a function that can filter and\n//          transform the results. It receives each of the keys and values,\n//          and its return value is used instead of the original value.\n//          If it returns what it received, then the structure is not modified.\n//          If it returns undefined then the member is deleted.\n\n//          Example:\n\n//          // Parse the text. Values that look like ISO date strings will\n//          // be converted to Date objects.\n\n//          myData = JSON.parse(text, function (key, value) {\n//              var a;\n//              if (typeof value === \"string\") {\n//                  a =\n//   /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\n//                  if (a) {\n//                      return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\n//                          +a[5], +a[6]));\n//                  }\n//              }\n//              return value;\n//          });\n\n//          myData = JSON.parse('[\"Date(09/09/2001)\"]', function (key, value) {\n//              var d;\n//              if (typeof value === \"string\" &&\n//                      value.slice(0, 5) === \"Date(\" &&\n//                      value.slice(-1) === \")\") {\n//                  d = new Date(value.slice(5, -1));\n//                  if (d) {\n//                      return d;\n//                  }\n//              }\n//              return value;\n//          });\n\n//  This is a reference implementation. You are free to copy, modify, or\n//  redistribute.\n\n/*jslint\n    eval, for, this\n*/\n\n/*property\n    JSON, apply, call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,\n    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,\n    lastIndex, length, parse, prototype, push, replace, slice, stringify,\n    test, toJSON, toString, valueOf\n*/\n\n\n// Create a JSON object only if one does not already exist. We create the\n// methods in a closure to avoid creating global variables.\n\nif (typeof JSON !== \"object\") {\n    JSON = {};\n}\n\n(function () {\n    \"use strict\";\n\n    var rx_one = /^[\\],:{}\\s]*$/;\n    var rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\n    var rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\n    var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g;\n    var rx_escapable = /[\\\\\"\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n    var rx_dangerous = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n\n    function f(n) {\n        // Format integers to have at least two digits.\n        return n < 10\n            ? \"0\" + n\n            : n;\n    }\n\n    function this_value() {\n        return this.valueOf();\n    }\n\n    if (typeof Date.prototype.toJSON !== \"function\") {\n\n        Date.prototype.toJSON = function () {\n\n            return isFinite(this.valueOf())\n                ? this.getUTCFullYear() + \"-\" +\n                        f(this.getUTCMonth() + 1) + \"-\" +\n                        f(this.getUTCDate()) + \"T\" +\n                        f(this.getUTCHours()) + \":\" +\n                        f(this.getUTCMinutes()) + \":\" +\n                        f(this.getUTCSeconds()) + \"Z\"\n                : null;\n        };\n\n        Boolean.prototype.toJSON = this_value;\n        Number.prototype.toJSON = this_value;\n        String.prototype.toJSON = this_value;\n    }\n\n    var gap;\n    var indent;\n    var meta;\n    var rep;\n\n\n    function quote(string) {\n\n// If the string contains no control characters, no quote characters, and no\n// backslash characters, then we can safely slap some quotes around it.\n// Otherwise we must also replace the offending characters with safe escape\n// sequences.\n\n        rx_escapable.lastIndex = 0;\n        return rx_escapable.test(string)\n            ? \"\\\"\" + string.replace(rx_escapable, function (a) {\n                var c = meta[a];\n                return typeof c === \"string\"\n                    ? c\n                    : \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n            }) + \"\\\"\"\n            : \"\\\"\" + string + \"\\\"\";\n    }\n\n\n    function str(key, holder) {\n\n// Produce a string from holder[key].\n\n        var i;          // The loop counter.\n        var k;          // The member key.\n        var v;          // The member value.\n        var length;\n        var mind = gap;\n        var partial;\n        var value = holder[key];\n\n// If the value has a toJSON method, call it to obtain a replacement value.\n\n        if (value && typeof value === \"object\" &&\n                typeof value.toJSON === \"function\") {\n            value = value.toJSON(key);\n        }\n\n// If we were called with a replacer function, then call the replacer to\n// obtain a replacement value.\n\n        if (typeof rep === \"function\") {\n            value = rep.call(holder, key, value);\n        }\n\n// What happens next depends on the value's type.\n\n        switch (typeof value) {\n        case \"string\":\n            return quote(value);\n\n        case \"number\":\n\n// JSON numbers must be finite. Encode non-finite numbers as null.\n\n            return isFinite(value)\n                ? String(value)\n                : \"null\";\n\n        case \"boolean\":\n        case \"null\":\n\n// If the value is a boolean or null, convert it to a string. Note:\n// typeof null does not produce \"null\". The case is included here in\n// the remote chance that this gets fixed someday.\n\n            return String(value);\n\n// If the type is \"object\", we might be dealing with an object or an array or\n// null.\n\n        case \"object\":\n\n// Due to a specification blunder in ECMAScript, typeof null is \"object\",\n// so watch out for that case.\n\n            if (!value) {\n                return \"null\";\n            }\n\n// Make an array to hold the partial results of stringifying this object value.\n\n            gap += indent;\n            partial = [];\n\n// Is the value an array?\n\n            if (Object.prototype.toString.apply(value) === \"[object Array]\") {\n\n// The value is an array. Stringify every element. Use null as a placeholder\n// for non-JSON values.\n\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || \"null\";\n                }\n\n// Join all of the elements together, separated with commas, and wrap them in\n// brackets.\n\n                v = partial.length === 0\n                    ? \"[]\"\n                    : gap\n                        ? \"[\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"]\"\n                        : \"[\" + partial.join(\",\") + \"]\";\n                gap = mind;\n                return v;\n            }\n\n// If the replacer is an array, use it to select the members to be stringified.\n\n            if (rep && typeof rep === \"object\") {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    if (typeof rep[i] === \"string\") {\n                        k = rep[i];\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (\n                                gap\n                                    ? \": \"\n                                    : \":\"\n                            ) + v);\n                        }\n                    }\n                }\n            } else {\n\n// Otherwise, iterate through all of the keys in the object.\n\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (\n                                gap\n                                    ? \": \"\n                                    : \":\"\n                            ) + v);\n                        }\n                    }\n                }\n            }\n\n// Join all of the member texts together, separated with commas,\n// and wrap them in braces.\n\n            v = partial.length === 0\n                ? \"{}\"\n                : gap\n                    ? \"{\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"}\"\n                    : \"{\" + partial.join(\",\") + \"}\";\n            gap = mind;\n            return v;\n        }\n    }\n\n// If the JSON object does not yet have a stringify method, give it one.\n\n    if (typeof JSON.stringify !== \"function\") {\n        meta = {    // table of character substitutions\n            \"\\b\": \"\\\\b\",\n            \"\\t\": \"\\\\t\",\n            \"\\n\": \"\\\\n\",\n            \"\\f\": \"\\\\f\",\n            \"\\r\": \"\\\\r\",\n            \"\\\"\": \"\\\\\\\"\",\n            \"\\\\\": \"\\\\\\\\\"\n        };\n        JSON.stringify = function (value, replacer, space) {\n\n// The stringify method takes a value and an optional replacer, and an optional\n// space parameter, and returns a JSON text. The replacer can be a function\n// that can replace values, or an array of strings that will select the keys.\n// A default replacer method can be provided. Use of the space parameter can\n// produce text that is more easily readable.\n\n            var i;\n            gap = \"\";\n            indent = \"\";\n\n// If the space parameter is a number, make an indent string containing that\n// many spaces.\n\n            if (typeof space === \"number\") {\n                for (i = 0; i < space; i += 1) {\n                    indent += \" \";\n                }\n\n// If the space parameter is a string, it will be used as the indent string.\n\n            } else if (typeof space === \"string\") {\n                indent = space;\n            }\n\n// If there is a replacer, it must be a function or an array.\n// Otherwise, throw an error.\n\n            rep = replacer;\n            if (replacer && typeof replacer !== \"function\" &&\n                    (typeof replacer !== \"object\" ||\n                    typeof replacer.length !== \"number\")) {\n                throw new Error(\"JSON.stringify\");\n            }\n\n// Make a fake root object containing our value under the key of \"\".\n// Return the result of stringifying the value.\n\n            return str(\"\", {\"\": value});\n        };\n    }\n\n\n// If the JSON object does not yet have a parse method, give it one.\n\n    if (typeof JSON.parse !== \"function\") {\n        JSON.parse = function (text, reviver) {\n\n// The parse method takes a text and an optional reviver function, and returns\n// a JavaScript value if the text is a valid JSON text.\n\n            var j;\n\n            function walk(holder, key) {\n\n// The walk method is used to recursively walk the resulting structure so\n// that modifications can be made.\n\n                var k;\n                var v;\n                var value = holder[key];\n                if (value && typeof value === \"object\") {\n                    for (k in value) {\n                        if (Object.prototype.hasOwnProperty.call(value, k)) {\n                            v = walk(value, k);\n                            if (v !== undefined) {\n                                value[k] = v;\n                            } else {\n                                delete value[k];\n                            }\n                        }\n                    }\n                }\n                return reviver.call(holder, key, value);\n            }\n\n\n// Parsing happens in four stages. In the first stage, we replace certain\n// Unicode characters with escape sequences. JavaScript handles many characters\n// incorrectly, either silently deleting them, or treating them as line endings.\n\n            text = String(text);\n            rx_dangerous.lastIndex = 0;\n            if (rx_dangerous.test(text)) {\n                text = text.replace(rx_dangerous, function (a) {\n                    return \"\\\\u\" +\n                            (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n                });\n            }\n\n// In the second stage, we run the text against regular expressions that look\n// for non-JSON patterns. We are especially concerned with \"()\" and \"new\"\n// because they can cause invocation, and \"=\" because it can cause mutation.\n// But just to be safe, we want to reject all unexpected forms.\n\n// We split the second stage into 4 regexp operations in order to work around\n// crippling inefficiencies in IE's and Safari's regexp engines. First we\n// replace the JSON backslash pairs with \"@\" (a non-JSON character). Second, we\n// replace all simple value tokens with \"]\" characters. Third, we delete all\n// open brackets that follow a colon or comma or that begin the text. Finally,\n// we look to see that the remaining characters are only whitespace or \"]\" or\n// \",\" or \":\" or \"{\" or \"}\". If that is so, then the text is safe for eval.\n\n            if (\n                rx_one.test(\n                    text\n                        .replace(rx_two, \"@\")\n                        .replace(rx_three, \"]\")\n                        .replace(rx_four, \"\")\n                )\n            ) {\n\n// In the third stage we use the eval function to compile the text into a\n// JavaScript structure. The \"{\" operator is subject to a syntactic ambiguity\n// in JavaScript: it can begin a block or an object literal. We wrap the text\n// in parens to eliminate the ambiguity.\n\n                j = eval(\"(\" + text + \")\");\n\n// In the optional fourth stage, we recursively walk the new structure, passing\n// each name/value pair to a reviver function for possible transformation.\n\n                return (typeof reviver === \"function\")\n                    ? walk({\"\": j}, \"\")\n                    : j;\n            }\n\n// If the text is not JSON parseable, then a SyntaxError is thrown.\n\n            throw new SyntaxError(\"JSON.parse\");\n        };\n    }\n}());","var util = require('./util')\nvar slice = util.slice\nvar pluck = util.pluck\nvar each = util.each\nvar bind = util.bind\nvar create = util.create\nvar isList = util.isList\nvar isFunction = util.isFunction\nvar isObject = util.isObject\n\nmodule.exports = {\n\tcreateStore: createStore\n}\n\nvar storeAPI = {\n\tversion: '2.0.12',\n\tenabled: false,\n\t\n\t// get returns the value of the given key. If that value\n\t// is undefined, it returns optionalDefaultValue instead.\n\tget: function(key, optionalDefaultValue) {\n\t\tvar data = this.storage.read(this._namespacePrefix + key)\n\t\treturn this._deserialize(data, optionalDefaultValue)\n\t},\n\n\t// set will store the given value at key and returns value.\n\t// Calling set with value === undefined is equivalent to calling remove.\n\tset: function(key, value) {\n\t\tif (value === undefined) {\n\t\t\treturn this.remove(key)\n\t\t}\n\t\tthis.storage.write(this._namespacePrefix + key, this._serialize(value))\n\t\treturn value\n\t},\n\n\t// remove deletes the key and value stored at the given key.\n\tremove: function(key) {\n\t\tthis.storage.remove(this._namespacePrefix + key)\n\t},\n\n\t// each will call the given callback once for each key-value pair\n\t// in this store.\n\teach: function(callback) {\n\t\tvar self = this\n\t\tthis.storage.each(function(val, namespacedKey) {\n\t\t\tcallback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))\n\t\t})\n\t},\n\n\t// clearAll will remove all the stored key-value pairs in this store.\n\tclearAll: function() {\n\t\tthis.storage.clearAll()\n\t},\n\n\t// additional functionality that can't live in plugins\n\t// ---------------------------------------------------\n\n\t// hasNamespace returns true if this store instance has the given namespace.\n\thasNamespace: function(namespace) {\n\t\treturn (this._namespacePrefix == '__storejs_'+namespace+'_')\n\t},\n\n\t// createStore creates a store.js instance with the first\n\t// functioning storage in the list of storage candidates,\n\t// and applies the the given mixins to the instance.\n\tcreateStore: function() {\n\t\treturn createStore.apply(this, arguments)\n\t},\n\t\n\taddPlugin: function(plugin) {\n\t\tthis._addPlugin(plugin)\n\t},\n\t\n\tnamespace: function(namespace) {\n\t\treturn createStore(this.storage, this.plugins, namespace)\n\t}\n}\n\nfunction _warn() {\n\tvar _console = (typeof console == 'undefined' ? null : console)\n\tif (!_console) { return }\n\tvar fn = (_console.warn ? _console.warn : _console.log)\n\tfn.apply(_console, arguments)\n}\n\nfunction createStore(storages, plugins, namespace) {\n\tif (!namespace) {\n\t\tnamespace = ''\n\t}\n\tif (storages && !isList(storages)) {\n\t\tstorages = [storages]\n\t}\n\tif (plugins && !isList(plugins)) {\n\t\tplugins = [plugins]\n\t}\n\n\tvar namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')\n\tvar namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)\n\tvar legalNamespaces = /^[a-zA-Z0-9_\\-]*$/ // alpha-numeric + underscore and dash\n\tif (!legalNamespaces.test(namespace)) {\n\t\tthrow new Error('store.js namespaces can only have alphanumerics + underscores and dashes')\n\t}\n\t\n\tvar _privateStoreProps = {\n\t\t_namespacePrefix: namespacePrefix,\n\t\t_namespaceRegexp: namespaceRegexp,\n\n\t\t_testStorage: function(storage) {\n\t\t\ttry {\n\t\t\t\tvar testStr = '__storejs__test__'\n\t\t\t\tstorage.write(testStr, testStr)\n\t\t\t\tvar ok = (storage.read(testStr) === testStr)\n\t\t\t\tstorage.remove(testStr)\n\t\t\t\treturn ok\n\t\t\t} catch(e) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t},\n\n\t\t_assignPluginFnProp: function(pluginFnProp, propName) {\n\t\t\tvar oldFn = this[propName]\n\t\t\tthis[propName] = function pluginFn() {\n\t\t\t\tvar args = slice(arguments, 0)\n\t\t\t\tvar self = this\n\n\t\t\t\t// super_fn calls the old function which was overwritten by\n\t\t\t\t// this mixin.\n\t\t\t\tfunction super_fn() {\n\t\t\t\t\tif (!oldFn) { return }\n\t\t\t\t\teach(arguments, function(arg, i) {\n\t\t\t\t\t\targs[i] = arg\n\t\t\t\t\t})\n\t\t\t\t\treturn oldFn.apply(self, args)\n\t\t\t\t}\n\n\t\t\t\t// Give mixing function access to super_fn by prefixing all mixin function\n\t\t\t\t// arguments with super_fn.\n\t\t\t\tvar newFnArgs = [super_fn].concat(args)\n\n\t\t\t\treturn pluginFnProp.apply(self, newFnArgs)\n\t\t\t}\n\t\t},\n\n\t\t_serialize: function(obj) {\n\t\t\treturn JSON.stringify(obj)\n\t\t},\n\n\t\t_deserialize: function(strVal, defaultVal) {\n\t\t\tif (!strVal) { return defaultVal }\n\t\t\t// It is possible that a raw string value has been previously stored\n\t\t\t// in a storage without using store.js, meaning it will be a raw\n\t\t\t// string value instead of a JSON serialized string. By defaulting\n\t\t\t// to the raw string value in case of a JSON parse error, we allow\n\t\t\t// for past stored values to be forwards-compatible with store.js\n\t\t\tvar val = ''\n\t\t\ttry { val = JSON.parse(strVal) }\n\t\t\tcatch(e) { val = strVal }\n\n\t\t\treturn (val !== undefined ? val : defaultVal)\n\t\t},\n\t\t\n\t\t_addStorage: function(storage) {\n\t\t\tif (this.enabled) { return }\n\t\t\tif (this._testStorage(storage)) {\n\t\t\t\tthis.storage = storage\n\t\t\t\tthis.enabled = true\n\t\t\t}\n\t\t},\n\n\t\t_addPlugin: function(plugin) {\n\t\t\tvar self = this\n\n\t\t\t// If the plugin is an array, then add all plugins in the array.\n\t\t\t// This allows for a plugin to depend on other plugins.\n\t\t\tif (isList(plugin)) {\n\t\t\t\teach(plugin, function(plugin) {\n\t\t\t\t\tself._addPlugin(plugin)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Keep track of all plugins we've seen so far, so that we\n\t\t\t// don't add any of them twice.\n\t\t\tvar seenPlugin = pluck(this.plugins, function(seenPlugin) {\n\t\t\t\treturn (plugin === seenPlugin)\n\t\t\t})\n\t\t\tif (seenPlugin) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tthis.plugins.push(plugin)\n\n\t\t\t// Check that the plugin is properly formed\n\t\t\tif (!isFunction(plugin)) {\n\t\t\t\tthrow new Error('Plugins must be function values that return objects')\n\t\t\t}\n\n\t\t\tvar pluginProperties = plugin.call(this)\n\t\t\tif (!isObject(pluginProperties)) {\n\t\t\t\tthrow new Error('Plugins must return an object of function properties')\n\t\t\t}\n\n\t\t\t// Add the plugin function properties to this store instance.\n\t\t\teach(pluginProperties, function(pluginFnProp, propName) {\n\t\t\t\tif (!isFunction(pluginFnProp)) {\n\t\t\t\t\tthrow new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')\n\t\t\t\t}\n\t\t\t\tself._assignPluginFnProp(pluginFnProp, propName)\n\t\t\t})\n\t\t},\n\t\t\n\t\t// Put deprecated properties in the private API, so as to not expose it to accidential\n\t\t// discovery through inspection of the store object.\n\t\t\n\t\t// Deprecated: addStorage\n\t\taddStorage: function(storage) {\n\t\t\t_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')\n\t\t\tthis._addStorage(storage)\n\t\t}\n\t}\n\n\tvar store = create(_privateStoreProps, storeAPI, {\n\t\tplugins: []\n\t})\n\tstore.raw = {}\n\teach(store, function(prop, propName) {\n\t\tif (isFunction(prop)) {\n\t\t\tstore.raw[propName] = bind(store, prop)\t\t\t\n\t\t}\n\t})\n\teach(storages, function(storage) {\n\t\tstore._addStorage(storage)\n\t})\n\teach(plugins, function(plugin) {\n\t\tstore._addPlugin(plugin)\n\t})\n\treturn store\n}\n","var assign = make_assign()\nvar create = make_create()\nvar trim = make_trim()\nvar Global = (typeof window !== 'undefined' ? window : global)\n\nmodule.exports = {\n\tassign: assign,\n\tcreate: create,\n\ttrim: trim,\n\tbind: bind,\n\tslice: slice,\n\teach: each,\n\tmap: map,\n\tpluck: pluck,\n\tisList: isList,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tGlobal: Global\n}\n\nfunction make_assign() {\n\tif (Object.assign) {\n\t\treturn Object.assign\n\t} else {\n\t\treturn function shimAssign(obj, props1, props2, etc) {\n\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\teach(Object(arguments[i]), function(val, key) {\n\t\t\t\t\tobj[key] = val\n\t\t\t\t})\n\t\t\t}\t\t\t\n\t\t\treturn obj\n\t\t}\n\t}\n}\n\nfunction make_create() {\n\tif (Object.create) {\n\t\treturn function create(obj, assignProps1, assignProps2, etc) {\n\t\t\tvar assignArgsList = slice(arguments, 1)\n\t\t\treturn assign.apply(this, [Object.create(obj)].concat(assignArgsList))\n\t\t}\n\t} else {\n\t\tfunction F() {} // eslint-disable-line no-inner-declarations\n\t\treturn function create(obj, assignProps1, assignProps2, etc) {\n\t\t\tvar assignArgsList = slice(arguments, 1)\n\t\t\tF.prototype = obj\n\t\t\treturn assign.apply(this, [new F()].concat(assignArgsList))\n\t\t}\n\t}\n}\n\nfunction make_trim() {\n\tif (String.prototype.trim) {\n\t\treturn function trim(str) {\n\t\t\treturn String.prototype.trim.call(str)\n\t\t}\n\t} else {\n\t\treturn function trim(str) {\n\t\t\treturn str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '')\n\t\t}\n\t}\n}\n\nfunction bind(obj, fn) {\n\treturn function() {\n\t\treturn fn.apply(obj, Array.prototype.slice.call(arguments, 0))\n\t}\n}\n\nfunction slice(arr, index) {\n\treturn Array.prototype.slice.call(arr, index || 0)\n}\n\nfunction each(obj, fn) {\n\tpluck(obj, function(val, key) {\n\t\tfn(val, key)\n\t\treturn false\n\t})\n}\n\nfunction map(obj, fn) {\n\tvar res = (isList(obj) ? [] : {})\n\tpluck(obj, function(v, k) {\n\t\tres[k] = fn(v, k)\n\t\treturn false\n\t})\n\treturn res\n}\n\nfunction pluck(obj, fn) {\n\tif (isList(obj)) {\n\t\tfor (var i=0; i<obj.length; i++) {\n\t\t\tif (fn(obj[i], i)) {\n\t\t\t\treturn obj[i]\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (var key in obj) {\n\t\t\tif (obj.hasOwnProperty(key)) {\n\t\t\t\tif (fn(obj[key], key)) {\n\t\t\t\t\treturn obj[key]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction isList(val) {\n\treturn (val != null && typeof val != 'function' && typeof val.length == 'number')\n}\n\nfunction isFunction(val) {\n\treturn val && {}.toString.call(val) === '[object Function]'\n}\n\nfunction isObject(val) {\n\treturn val && {}.toString.call(val) === '[object Object]'\n}\n","module.exports = [\n\t// Listed in order of usage preference\n\trequire('./localStorage'),\n\trequire('./oldFF-globalStorage'),\n\trequire('./oldIE-userDataStorage'),\n\trequire('./cookieStorage'),\n\trequire('./sessionStorage'),\n\trequire('./memoryStorage')\n]\n","// cookieStorage is useful Safari private browser mode, where localStorage\n// doesn't work but cookies do. This implementation is adopted from\n// https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage\n\nvar util = require('../src/util')\nvar Global = util.Global\nvar trim = util.trim\n\nmodule.exports = {\n\tname: 'cookieStorage',\n\tread: read,\n\twrite: write,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll,\n}\n\nvar doc = Global.document\n\nfunction read(key) {\n\tif (!key || !_has(key)) { return null }\n\tvar regexpStr = \"(?:^|.*;\\\\s*)\" +\n\t\tescape(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") +\n\t\t\"\\\\s*\\\\=\\\\s*((?:[^;](?!;))*[^;]?).*\"\n\treturn unescape(doc.cookie.replace(new RegExp(regexpStr), \"$1\"))\n}\n\nfunction each(callback) {\n\tvar cookies = doc.cookie.split(/; ?/g)\n\tfor (var i = cookies.length - 1; i >= 0; i--) {\n\t\tif (!trim(cookies[i])) {\n\t\t\tcontinue\n\t\t}\n\t\tvar kvp = cookies[i].split('=')\n\t\tvar key = unescape(kvp[0])\n\t\tvar val = unescape(kvp[1])\n\t\tcallback(val, key)\n\t}\n}\n\nfunction write(key, data) {\n\tif(!key) { return }\n\tdoc.cookie = escape(key) + \"=\" + escape(data) + \"; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/\"\n}\n\nfunction remove(key) {\n\tif (!key || !_has(key)) {\n\t\treturn\n\t}\n\tdoc.cookie = escape(key) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/\"\n}\n\nfunction clearAll() {\n\teach(function(_, key) {\n\t\tremove(key)\n\t})\n}\n\nfunction _has(key) {\n\treturn (new RegExp(\"(?:^|;\\\\s*)\" + escape(key).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&\") + \"\\\\s*\\\\=\")).test(doc.cookie)\n}\n","var util = require('../src/util')\nvar Global = util.Global\n\nmodule.exports = {\n\tname: 'localStorage',\n\tread: read,\n\twrite: write,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll,\n}\n\nfunction localStorage() {\n\treturn Global.localStorage\n}\n\nfunction read(key) {\n\treturn localStorage().getItem(key)\n}\n\nfunction write(key, data) {\n\treturn localStorage().setItem(key, data)\n}\n\nfunction each(fn) {\n\tfor (var i = localStorage().length - 1; i >= 0; i--) {\n\t\tvar key = localStorage().key(i)\n\t\tfn(read(key), key)\n\t}\n}\n\nfunction remove(key) {\n\treturn localStorage().removeItem(key)\n}\n\nfunction clearAll() {\n\treturn localStorage().clear()\n}\n","// memoryStorage is a useful last fallback to ensure that the store\n// is functions (meaning store.get(), store.set(), etc will all function).\n// However, stored values will not persist when the browser navigates to\n// a new page or reloads the current page.\n\nmodule.exports = {\n\tname: 'memoryStorage',\n\tread: read,\n\twrite: write,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll,\n}\n\nvar memoryStorage = {}\n\nfunction read(key) {\n\treturn memoryStorage[key]\n}\n\nfunction write(key, data) {\n\tmemoryStorage[key] = data\n}\n\nfunction each(callback) {\n\tfor (var key in memoryStorage) {\n\t\tif (memoryStorage.hasOwnProperty(key)) {\n\t\t\tcallback(memoryStorage[key], key)\n\t\t}\n\t}\n}\n\nfunction remove(key) {\n\tdelete memoryStorage[key]\n}\n\nfunction clearAll(key) {\n\tmemoryStorage = {}\n}\n","// oldFF-globalStorage provides storage for Firefox\n// versions 6 and 7, where no localStorage, etc\n// is available.\n\nvar util = require('../src/util')\nvar Global = util.Global\n\nmodule.exports = {\n\tname: 'oldFF-globalStorage',\n\tread: read,\n\twrite: write,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll,\n}\n\nvar globalStorage = Global.globalStorage\n\nfunction read(key) {\n\treturn globalStorage[key]\n}\n\nfunction write(key, data) {\n\tglobalStorage[key] = data\n}\n\nfunction each(fn) {\n\tfor (var i = globalStorage.length - 1; i >= 0; i--) {\n\t\tvar key = globalStorage.key(i)\n\t\tfn(globalStorage[key], key)\n\t}\n}\n\nfunction remove(key) {\n\treturn globalStorage.removeItem(key)\n}\n\nfunction clearAll() {\n\teach(function(key, _) {\n\t\tdelete globalStorage[key]\n\t})\n}\n","// oldIE-userDataStorage provides storage for Internet Explorer\n// versions 6 and 7, where no localStorage, sessionStorage, etc\n// is available.\n\nvar util = require('../src/util')\nvar Global = util.Global\n\nmodule.exports = {\n\tname: 'oldIE-userDataStorage',\n\twrite: write,\n\tread: read,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll,\n}\n\nvar storageName = 'storejs'\nvar doc = Global.document\nvar _withStorageEl = _makeIEStorageElFunction()\nvar disable = (Global.navigator ? Global.navigator.userAgent : '').match(/ (MSIE 8|MSIE 9|MSIE 10)\\./) // MSIE 9.x, MSIE 10.x\n\nfunction write(unfixedKey, data) {\n\tif (disable) { return }\n\tvar fixedKey = fixKey(unfixedKey)\n\t_withStorageEl(function(storageEl) {\n\t\tstorageEl.setAttribute(fixedKey, data)\n\t\tstorageEl.save(storageName)\n\t})\n}\n\nfunction read(unfixedKey) {\n\tif (disable) { return }\n\tvar fixedKey = fixKey(unfixedKey)\n\tvar res = null\n\t_withStorageEl(function(storageEl) {\n\t\tres = storageEl.getAttribute(fixedKey)\n\t})\n\treturn res\n}\n\nfunction each(callback) {\n\t_withStorageEl(function(storageEl) {\n\t\tvar attributes = storageEl.XMLDocument.documentElement.attributes\n\t\tfor (var i=attributes.length-1; i>=0; i--) {\n\t\t\tvar attr = attributes[i]\n\t\t\tcallback(storageEl.getAttribute(attr.name), attr.name)\n\t\t}\n\t})\n}\n\nfunction remove(unfixedKey) {\n\tvar fixedKey = fixKey(unfixedKey)\n\t_withStorageEl(function(storageEl) {\n\t\tstorageEl.removeAttribute(fixedKey)\n\t\tstorageEl.save(storageName)\n\t})\n}\n\nfunction clearAll() {\n\t_withStorageEl(function(storageEl) {\n\t\tvar attributes = storageEl.XMLDocument.documentElement.attributes\n\t\tstorageEl.load(storageName)\n\t\tfor (var i=attributes.length-1; i>=0; i--) {\n\t\t\tstorageEl.removeAttribute(attributes[i].name)\n\t\t}\n\t\tstorageEl.save(storageName)\n\t})\n}\n\n// Helpers\n//////////\n\n// In IE7, keys cannot start with a digit or contain certain chars.\n// See https://github.com/marcuswestin/store.js/issues/40\n// See https://github.com/marcuswestin/store.js/issues/83\nvar forbiddenCharsRegex = new RegExp(\"[!\\\"#$%&'()*+,/\\\\\\\\:;<=>?@[\\\\]^`{|}~]\", \"g\")\nfunction fixKey(key) {\n\treturn key.replace(/^\\d/, '___$&').replace(forbiddenCharsRegex, '___')\n}\n\nfunction _makeIEStorageElFunction() {\n\tif (!doc || !doc.documentElement || !doc.documentElement.addBehavior) {\n\t\treturn null\n\t}\n\tvar scriptTag = 'script',\n\t\tstorageOwner,\n\t\tstorageContainer,\n\t\tstorageEl\n\n\t// Since #userData storage applies only to specific paths, we need to\n\t// somehow link our data to a specific path.  We choose /favicon.ico\n\t// as a pretty safe option, since all browsers already make a request to\n\t// this URL anyway and being a 404 will not hurt us here.  We wrap an\n\t// iframe pointing to the favicon in an ActiveXObject(htmlfile) object\n\t// (see: http://msdn.microsoft.com/en-us/library/aa752574(v=VS.85).aspx)\n\t// since the iframe access rules appear to allow direct access and\n\t// manipulation of the document element, even for a 404 page.  This\n\t// document can be used instead of the current document (which would\n\t// have been limited to the current path) to perform #userData storage.\n\ttry {\n\t\t/* global ActiveXObject */\n\t\tstorageContainer = new ActiveXObject('htmlfile')\n\t\tstorageContainer.open()\n\t\tstorageContainer.write('<'+scriptTag+'>document.w=window</'+scriptTag+'><iframe src=\"/favicon.ico\"></iframe>')\n\t\tstorageContainer.close()\n\t\tstorageOwner = storageContainer.w.frames[0].document\n\t\tstorageEl = storageOwner.createElement('div')\n\t} catch(e) {\n\t\t// somehow ActiveXObject instantiation failed (perhaps some special\n\t\t// security settings or otherwse), fall back to per-path storage\n\t\tstorageEl = doc.createElement('div')\n\t\tstorageOwner = doc.body\n\t}\n\n\treturn function(storeFunction) {\n\t\tvar args = [].slice.call(arguments, 0)\n\t\targs.unshift(storageEl)\n\t\t// See http://msdn.microsoft.com/en-us/library/ms531081(v=VS.85).aspx\n\t\t// and http://msdn.microsoft.com/en-us/library/ms531424(v=VS.85).aspx\n\t\tstorageOwner.appendChild(storageEl)\n\t\tstorageEl.addBehavior('#default#userData')\n\t\tstorageEl.load(storageName)\n\t\tstoreFunction.apply(this, args)\n\t\tstorageOwner.removeChild(storageEl)\n\t\treturn\n\t}\n}\n","var util = require('../src/util')\nvar Global = util.Global\n\nmodule.exports = {\n\tname: 'sessionStorage',\n\tread: read,\n\twrite: write,\n\teach: each,\n\tremove: remove,\n\tclearAll: clearAll\n}\n\nfunction sessionStorage() {\n\treturn Global.sessionStorage\n}\n\nfunction read(key) {\n\treturn sessionStorage().getItem(key)\n}\n\nfunction write(key, data) {\n\treturn sessionStorage().setItem(key, data)\n}\n\nfunction each(fn) {\n\tfor (var i = sessionStorage().length - 1; i >= 0; i--) {\n\t\tvar key = sessionStorage().key(i)\n\t\tfn(read(key), key)\n\t}\n}\n\nfunction remove(key) {\n\treturn sessionStorage().removeItem(key)\n}\n\nfunction clearAll() {\n\treturn sessionStorage().clear()\n}\n","'use strict';\nconst os = require('os');\nconst hasFlag = require('has-flag');\n\nconst env = process.env;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor ? 1 : 0;\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors. Windows 10 build 14931 is the first release\n\t\t// that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n(() => {\n    /**\n        * Class representing an annotation loader\n        * @memberof module:API.cvat.classes\n        * @hideconstructor\n    */\n    class Loader {\n        constructor(initialData) {\n            const data = {\n                display_name: initialData.display_name,\n                format: initialData.format,\n                handler: initialData.handler,\n                version: initialData.version,\n            };\n\n            Object.defineProperties(this, {\n                name: {\n                    /**\n                        * @name name\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.Loader\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.display_name,\n                },\n                format: {\n                    /**\n                        * @name format\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.Loader\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.format,\n                },\n                handler: {\n                    /**\n                        * @name handler\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.Loader\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.handler,\n                },\n                version: {\n                    /**\n                        * @name version\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.Loader\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.version,\n                },\n            });\n        }\n    }\n\n    /**\n        * Class representing an annotation dumper\n        * @memberof module:API.cvat.classes\n        * @hideconstructor\n    */\n    class Dumper {\n        constructor(initialData) {\n            const data = {\n                display_name: initialData.display_name,\n                format: initialData.format,\n                handler: initialData.handler,\n                version: initialData.version,\n            };\n\n            Object.defineProperties(this, {\n                name: {\n                    /**\n                        * @name name\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.Dumper\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.display_name,\n                },\n                format: {\n                    /**\n                        * @name format\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.Dumper\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.format,\n                },\n                handler: {\n                    /**\n                        * @name handler\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.Dumper\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.handler,\n                },\n                version: {\n                    /**\n                        * @name version\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.Dumper\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.version,\n                },\n            });\n        }\n    }\n\n    /**\n        * Class representing an annotation format\n        * @memberof module:API.cvat.classes\n        * @hideconstructor\n    */\n    class AnnotationFormat {\n        constructor(initialData) {\n            const data = {\n                created_date: initialData.created_date,\n                updated_date: initialData.updated_date,\n                id: initialData.id,\n                owner: initialData.owner,\n                name: initialData.name,\n                handler_file: initialData.handler_file,\n            };\n\n            data.dumpers = initialData.dumpers.map(el => new Dumper(el));\n            data.loaders = initialData.loaders.map(el => new Loader(el));\n\n            // Now all fields are readonly\n            Object.defineProperties(this, {\n                id: {\n                    /**\n                        * @name id\n                        * @type {integer}\n                        * @memberof module:API.cvat.classes.AnnotationFormat\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.id,\n                },\n                owner: {\n                    /**\n                        * @name owner\n                        * @type {integer}\n                        * @memberof module:API.cvat.classes.AnnotationFormat\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.owner,\n                },\n                name: {\n                    /**\n                        * @name name\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.AnnotationFormat\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.name,\n                },\n                createdDate: {\n                    /**\n                        * @name createdDate\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.AnnotationFormat\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.created_date,\n                },\n                updatedDate: {\n                    /**\n                        * @name updatedDate\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.AnnotationFormat\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.updated_date,\n                },\n                handlerFile: {\n                    /**\n                        * @name handlerFile\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.AnnotationFormat\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.handler_file,\n                },\n                loaders: {\n                    /**\n                        * @name loaders\n                        * @type {module:API.cvat.classes.Loader[]}\n                        * @memberof module:API.cvat.classes.AnnotationFormat\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => [...data.loaders],\n                },\n                dumpers: {\n                    /**\n                        * @name dumpers\n                        * @type {module:API.cvat.classes.Dumper[]}\n                        * @memberof module:API.cvat.classes.AnnotationFormat\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => [...data.dumpers],\n                },\n            });\n        }\n    }\n\n    module.exports = {\n        AnnotationFormat,\n        Loader,\n        Dumper,\n    };\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n(() => {\n    const {\n        RectangleShape,\n        PolygonShape,\n        PolylineShape,\n        PointsShape,\n        RectangleTrack,\n        PolygonTrack,\n        PolylineTrack,\n        PointsTrack,\n        Track,\n        Shape,\n        Tag,\n        objectStateFactory,\n    } = require('./annotations-objects');\n    const { checkObjectType } = require('./common');\n    const Statistics = require('./statistics');\n    const { Label } = require('./labels');\n    const {\n        DataError,\n        ArgumentError,\n        ScriptingError,\n    } = require('./exceptions');\n\n    const {\n        ObjectShape,\n        ObjectType,\n    } = require('./enums');\n    const ObjectState = require('./object-state');\n\n    const colors = [\n        '#0066FF', '#AF593E', '#01A368', '#FF861F', '#ED0A3F', '#FF3F34', '#76D7EA',\n        '#8359A3', '#FBE870', '#C5E17A', '#03BB85', '#FFDF00', '#8B8680', '#0A6B0D',\n        '#8FD8D8', '#A36F40', '#F653A6', '#CA3435', '#FFCBA4', '#FF99CC', '#FA9D5A',\n        '#FFAE42', '#A78B00', '#788193', '#514E49', '#1164B4', '#F4FA9F', '#FED8B1',\n        '#C32148', '#01796F', '#E90067', '#FF91A4', '#404E5A', '#6CDAE7', '#FFC1CC',\n        '#006A93', '#867200', '#E2B631', '#6EEB6E', '#FFC800', '#CC99BA', '#FF007C',\n        '#BC6CAC', '#DCCCD7', '#EBE1C2', '#A6AAAE', '#B99685', '#0086A7', '#5E4330',\n        '#C8A2C8', '#708EB3', '#BC8777', '#B2592D', '#497E48', '#6A2963', '#E6335F',\n        '#00755E', '#B5A895', '#0048ba', '#EED9C4', '#C88A65', '#FF6E4A', '#87421F',\n        '#B2BEB5', '#926F5B', '#00B9FB', '#6456B7', '#DB5079', '#C62D42', '#FA9C44',\n        '#DA8A67', '#FD7C6E', '#93CCEA', '#FCF686', '#503E32', '#FF5470', '#9DE093',\n        '#FF7A00', '#4F69C6', '#A50B5E', '#F0E68C', '#FDFF00', '#F091A9', '#FFFF66',\n        '#6F9940', '#FC74FD', '#652DC1', '#D6AEDD', '#EE34D2', '#BB3385', '#6B3FA0',\n        '#33CC99', '#FFDB00', '#87FF2A', '#6EEB6E', '#FFC800', '#CC99BA', '#7A89B8',\n        '#006A93', '#867200', '#E2B631', '#D9D6CF',\n    ];\n\n    function shapeFactory(shapeData, clientID, injection) {\n        const { type } = shapeData;\n        const color = colors[clientID % colors.length];\n\n        let shapeModel = null;\n        switch (type) {\n        case 'rectangle':\n            shapeModel = new RectangleShape(shapeData, clientID, color, injection);\n            break;\n        case 'polygon':\n            shapeModel = new PolygonShape(shapeData, clientID, color, injection);\n            break;\n        case 'polyline':\n            shapeModel = new PolylineShape(shapeData, clientID, color, injection);\n            break;\n        case 'points':\n            shapeModel = new PointsShape(shapeData, clientID, color, injection);\n            break;\n        default:\n            throw new DataError(\n                `An unexpected type of shape \"${type}\"`,\n            );\n        }\n\n        return shapeModel;\n    }\n\n\n    function trackFactory(trackData, clientID, injection) {\n        if (trackData.shapes.length) {\n            const { type } = trackData.shapes[0];\n            const color = colors[clientID % colors.length];\n\n            let trackModel = null;\n            switch (type) {\n            case 'rectangle':\n                trackModel = new RectangleTrack(trackData, clientID, color, injection);\n                break;\n            case 'polygon':\n                trackModel = new PolygonTrack(trackData, clientID, color, injection);\n                break;\n            case 'polyline':\n                trackModel = new PolylineTrack(trackData, clientID, color, injection);\n                break;\n            case 'points':\n                trackModel = new PointsTrack(trackData, clientID, color, injection);\n                break;\n            default:\n                throw new DataError(\n                    `An unexpected type of track \"${type}\"`,\n                );\n            }\n\n            return trackModel;\n        }\n\n        console.warn('The track without any shapes had been found. It was ignored.');\n        return null;\n    }\n\n    class Collection {\n        constructor(data) {\n            this.startFrame = data.startFrame;\n            this.stopFrame = data.stopFrame;\n            this.frameMeta = data.frameMeta;\n\n            this.labels = data.labels.reduce((labelAccumulator, label) => {\n                labelAccumulator[label.id] = label;\n                return labelAccumulator;\n            }, {});\n\n            this.shapes = {}; // key is a frame\n            this.tags = {}; // key is a frame\n            this.tracks = [];\n            this.objects = {}; // key is a client id\n            this.count = 0;\n            this.flush = false;\n            this.collectionZ = {}; // key is a frame, {max, min} are values\n            this.groups = {\n                max: 0,\n            }; // it is an object to we can pass it as an argument by a reference\n            this.injection = {\n                labels: this.labels,\n                collectionZ: this.collectionZ,\n                groups: this.groups,\n                frameMeta: this.frameMeta,\n            };\n        }\n\n        import(data) {\n            for (const tag of data.tags) {\n                const clientID = ++this.count;\n                const tagModel = new Tag(tag, clientID, this.injection);\n                this.tags[tagModel.frame] = this.tags[tagModel.frame] || [];\n                this.tags[tagModel.frame].push(tagModel);\n                this.objects[clientID] = tagModel;\n            }\n\n            for (const shape of data.shapes) {\n                const clientID = ++this.count;\n                const shapeModel = shapeFactory(shape, clientID, this.injection);\n                this.shapes[shapeModel.frame] = this.shapes[shapeModel.frame] || [];\n                this.shapes[shapeModel.frame].push(shapeModel);\n                this.objects[clientID] = shapeModel;\n            }\n\n            for (const track of data.tracks) {\n                const clientID = ++this.count;\n                const trackModel = trackFactory(track, clientID, this.injection);\n                // The function can return null if track doesn't have any shapes.\n                // In this case a corresponded message will be sent to the console\n                if (trackModel) {\n                    this.tracks.push(trackModel);\n                    this.objects[clientID] = trackModel;\n                }\n            }\n\n            return this;\n        }\n\n        export() {\n            const data = {\n                tracks: this.tracks.filter(track => !track.removed)\n                    .map(track => track.toJSON()),\n                shapes: Object.values(this.shapes)\n                    .reduce((accumulator, value) => {\n                        accumulator.push(...value);\n                        return accumulator;\n                    }, []).filter(shape => !shape.removed)\n                    .map(shape => shape.toJSON()),\n                tags: Object.values(this.tags).reduce((accumulator, value) => {\n                    accumulator.push(...value);\n                    return accumulator;\n                }, []).filter(tag => !tag.removed)\n                    .map(tag => tag.toJSON()),\n            };\n\n            return data;\n        }\n\n        get(frame) {\n            const { tracks } = this;\n            const shapes = this.shapes[frame] || [];\n            const tags = this.tags[frame] || [];\n\n            const objects = tracks.concat(shapes).concat(tags).filter(object => !object.removed);\n            // filtering here\n\n            const objectStates = [];\n            for (const object of objects) {\n                const stateData = object.get(frame);\n                if (stateData.outside && !stateData.keyframe) {\n                    continue;\n                }\n\n                const objectState = objectStateFactory.call(object, frame, stateData);\n                objectStates.push(objectState);\n            }\n\n            return objectStates;\n        }\n\n        merge(objectStates) {\n            checkObjectType('shapes for merge', objectStates, null, Array);\n            if (!objectStates.length) return;\n            const objectsForMerge = objectStates.map((state) => {\n                checkObjectType('object state', state, null, ObjectState);\n                const object = this.objects[state.clientID];\n                if (typeof (object) === 'undefined') {\n                    throw new ArgumentError(\n                        'The object has not been saved yet. Call ObjectState.put([state]) before you can merge it',\n                    );\n                }\n                return object;\n            });\n\n            const keyframes = {}; // frame: position\n            const { label, shapeType } = objectStates[0];\n            if (!(label.id in this.labels)) {\n                throw new ArgumentError(\n                    `Unknown label for the task: ${label.id}`,\n                );\n            }\n\n            if (!Object.values(ObjectShape).includes(shapeType)) {\n                throw new ArgumentError(\n                    `Got unknown shapeType \"${shapeType}\"`,\n                );\n            }\n\n            const labelAttributes = label.attributes.reduce((accumulator, attribute) => {\n                accumulator[attribute.id] = attribute;\n                return accumulator;\n            }, {});\n\n            for (let i = 0; i < objectsForMerge.length; i++) {\n                // For each state get corresponding object\n                const object = objectsForMerge[i];\n                const state = objectStates[i];\n                if (state.label.id !== label.id) {\n                    throw new ArgumentError(\n                        `All shape labels are expected to be ${label.name}, but got ${state.label.name}`,\n                    );\n                }\n\n                if (state.shapeType !== shapeType) {\n                    throw new ArgumentError(\n                        `All shapes are expected to be ${shapeType}, but got ${state.shapeType}`,\n                    );\n                }\n\n                // If this object is shape, get it position and save as a keyframe\n                if (object instanceof Shape) {\n                    // Frame already saved and it is not outside\n                    if (object.frame in keyframes && !keyframes[object.frame].outside) {\n                        throw new ArgumentError(\n                            'Expected only one visible shape per frame',\n                        );\n                    }\n\n                    keyframes[object.frame] = {\n                        type: shapeType,\n                        frame: object.frame,\n                        points: [...object.points],\n                        occluded: object.occluded,\n                        zOrder: object.zOrder,\n                        outside: false,\n                        attributes: Object.keys(object.attributes).reduce((accumulator, attrID) => {\n                            // We save only mutable attributes inside a keyframe\n                            if (attrID in labelAttributes && labelAttributes[attrID].mutable) {\n                                accumulator.push({\n                                    spec_id: +attrID,\n                                    value: object.attributes[attrID],\n                                });\n                            }\n                            return accumulator;\n                        }, []),\n                    };\n\n                    // Push outside shape after each annotation shape\n                    // Any not outside shape rewrites it\n                    if (!((object.frame + 1) in keyframes)) {\n                        keyframes[object.frame + 1] = JSON\n                            .parse(JSON.stringify(keyframes[object.frame]));\n                        keyframes[object.frame + 1].outside = true;\n                        keyframes[object.frame + 1].frame++;\n                    }\n                } else if (object instanceof Track) {\n                    // If this object is track, iterate through all its\n                    // keyframes and push copies to new keyframes\n                    const attributes = {}; // id:value\n                    for (const keyframe of Object.keys(object.shapes)) {\n                        const shape = object.shapes[keyframe];\n                        // Frame already saved and it is not outside\n                        if (keyframe in keyframes && !keyframes[keyframe].outside) {\n                            // This shape is outside and non-outside shape already exists\n                            if (shape.outside) {\n                                continue;\n                            }\n\n                            throw new ArgumentError(\n                                'Expected only one visible shape per frame',\n                            );\n                        }\n\n                        // We do not save an attribute if it has the same value\n                        // We save only updates\n                        let updatedAttributes = false;\n                        for (const attrID in shape.attributes) {\n                            if (!(attrID in attributes)\n                                || attributes[attrID] !== shape.attributes[attrID]) {\n                                updatedAttributes = true;\n                                attributes[attrID] = shape.attributes[attrID];\n                            }\n                        }\n\n                        keyframes[keyframe] = {\n                            type: shapeType,\n                            frame: +keyframe,\n                            points: [...shape.points],\n                            occluded: shape.occluded,\n                            outside: shape.outside,\n                            zOrder: shape.zOrder,\n                            attributes: updatedAttributes ? Object.keys(attributes)\n                                .reduce((accumulator, attrID) => {\n                                    accumulator.push({\n                                        spec_id: +attrID,\n                                        value: attributes[attrID],\n                                    });\n\n                                    return accumulator;\n                                }, []) : [],\n                        };\n                    }\n                } else {\n                    throw new ArgumentError(\n                        `Trying to merge unknown object type: ${object.constructor.name}. `\n                            + 'Only shapes and tracks are expected.',\n                    );\n                }\n            }\n\n            let firstNonOutside = false;\n            for (const frame of Object.keys(keyframes).sort((a, b) => +a - +b)) {\n                // Remove all outside frames at the begin\n                firstNonOutside = firstNonOutside || keyframes[frame].outside;\n                if (!firstNonOutside && keyframes[frame].outside) {\n                    delete keyframes[frame];\n                } else {\n                    break;\n                }\n            }\n\n            const clientID = ++this.count;\n            const track = {\n                frame: Math.min.apply(null, Object.keys(keyframes).map(frame => +frame)),\n                shapes: Object.values(keyframes),\n                group: 0,\n                label_id: label.id,\n                attributes: Object.keys(objectStates[0].attributes)\n                    .reduce((accumulator, attrID) => {\n                        if (!labelAttributes[attrID].mutable) {\n                            accumulator.push({\n                                spec_id: +attrID,\n                                value: objectStates[0].attributes[attrID],\n                            });\n                        }\n\n                        return accumulator;\n                    }, []),\n            };\n\n            const trackModel = trackFactory(track, clientID, this.injection);\n            this.tracks.push(trackModel);\n            this.objects[clientID] = trackModel;\n\n            // Remove other shapes\n            for (const object of objectsForMerge) {\n                object.removed = true;\n                if (typeof (object.resetCache) === 'function') {\n                    object.resetCache();\n                }\n            }\n        }\n\n        split(objectState, frame) {\n            checkObjectType('object state', objectState, null, ObjectState);\n            checkObjectType('frame', frame, 'integer', null);\n\n            const object = this.objects[objectState.clientID];\n            if (typeof (object) === 'undefined') {\n                throw new ArgumentError(\n                    'The object has not been saved yet. Call annotations.put([state]) before',\n                );\n            }\n\n            if (objectState.objectType !== ObjectType.TRACK) {\n                return;\n            }\n\n            const keyframes = Object.keys(object.shapes).sort((a, b) => +a - +b);\n            if (frame <= +keyframes[0] || frame > keyframes[keyframes.length - 1]) {\n                return;\n            }\n\n            const labelAttributes = object.label.attributes.reduce((accumulator, attribute) => {\n                accumulator[attribute.id] = attribute;\n                return accumulator;\n            }, {});\n\n            const exported = object.toJSON();\n            const position = {\n                type: objectState.shapeType,\n                points: [...objectState.points],\n                occluded: objectState.occluded,\n                outside: objectState.outside,\n                zOrder: 0,\n                attributes: Object.keys(objectState.attributes)\n                    .reduce((accumulator, attrID) => {\n                        if (!labelAttributes[attrID].mutable) {\n                            accumulator.push({\n                                spec_id: +attrID,\n                                value: objectState.attributes[attrID],\n                            });\n                        }\n\n                        return accumulator;\n                    }, []),\n                frame,\n            };\n\n            const prev = {\n                frame: exported.frame,\n                group: 0,\n                label_id: exported.label_id,\n                attributes: exported.attributes,\n                shapes: [],\n            };\n\n            const next = JSON.parse(JSON.stringify(prev));\n            next.frame = frame;\n\n            next.shapes.push(JSON.parse(JSON.stringify(position)));\n            exported.shapes.map((shape) => {\n                delete shape.id;\n                if (shape.frame < frame) {\n                    prev.shapes.push(JSON.parse(JSON.stringify(shape)));\n                } else if (shape.frame > frame) {\n                    next.shapes.push(JSON.parse(JSON.stringify(shape)));\n                }\n\n                return shape;\n            });\n            prev.shapes.push(position);\n            prev.shapes[prev.shapes.length - 1].outside = true;\n\n            let clientID = ++this.count;\n            const prevTrack = trackFactory(prev, clientID, this.injection);\n            this.tracks.push(prevTrack);\n            this.objects[clientID] = prevTrack;\n\n            clientID = ++this.count;\n            const nextTrack = trackFactory(next, clientID, this.injection);\n            this.tracks.push(nextTrack);\n            this.objects[clientID] = nextTrack;\n\n            // Remove source object\n            object.removed = true;\n            object.resetCache();\n        }\n\n        group(objectStates, reset) {\n            checkObjectType('shapes for group', objectStates, null, Array);\n\n            const objectsForGroup = objectStates.map((state) => {\n                checkObjectType('object state', state, null, ObjectState);\n                const object = this.objects[state.clientID];\n                if (typeof (object) === 'undefined') {\n                    throw new ArgumentError(\n                        'The object has not been saved yet. Call annotations.put([state]) before',\n                    );\n                }\n                return object;\n            });\n\n            const groupIdx = reset ? 0 : ++this.groups.max;\n            for (const object of objectsForGroup) {\n                object.group = groupIdx;\n                if (typeof (object.resetCache) === 'function') {\n                    object.resetCache();\n                }\n            }\n\n            return groupIdx;\n        }\n\n        clear() {\n            this.shapes = {};\n            this.tags = {};\n            this.tracks = [];\n            this.objects = {}; // by id\n            this.count = 0;\n\n            this.flush = true;\n        }\n\n        statistics() {\n            const labels = {};\n            const skeleton = {\n                rectangle: {\n                    shape: 0,\n                    track: 0,\n                },\n                polygon: {\n                    shape: 0,\n                    track: 0,\n                },\n                polyline: {\n                    shape: 0,\n                    track: 0,\n                },\n                points: {\n                    shape: 0,\n                    track: 0,\n                },\n                tags: 0,\n                manually: 0,\n                interpolated: 0,\n                total: 0,\n            };\n\n            const total = JSON.parse(JSON.stringify(skeleton));\n            for (const label of Object.values(this.labels)) {\n                const { name } = label;\n                labels[name] = JSON.parse(JSON.stringify(skeleton));\n            }\n\n            for (const object of Object.values(this.objects)) {\n                let objectType = null;\n                if (object instanceof Shape) {\n                    objectType = 'shape';\n                } else if (object instanceof Track) {\n                    objectType = 'track';\n                } else if (object instanceof Tag) {\n                    objectType = 'tag';\n                } else {\n                    throw new ScriptingError(\n                        `Unexpected object type: \"${objectType}\"`,\n                    );\n                }\n\n                const label = object.label.name;\n                if (objectType === 'tag') {\n                    labels[label].tags++;\n                    labels[label].manually++;\n                    labels[label].total++;\n                } else {\n                    const { shapeType } = object;\n                    labels[label][shapeType][objectType]++;\n\n                    if (objectType === 'track') {\n                        const keyframes = Object.keys(object.shapes)\n                            .sort((a, b) => +a - +b).map(el => +el);\n\n                        let prevKeyframe = keyframes[0];\n                        let visible = false;\n\n                        for (const keyframe of keyframes) {\n                            if (visible) {\n                                const interpolated = keyframe - prevKeyframe - 1;\n                                labels[label].interpolated += interpolated;\n                                labels[label].total += interpolated;\n                            }\n                            visible = !object.shapes[keyframe].outside;\n                            prevKeyframe = keyframe;\n\n                            if (visible) {\n                                labels[label].manually++;\n                                labels[label].total++;\n                            }\n                        }\n\n                        const lastKey = keyframes[keyframes.length - 1];\n                        if (lastKey !== this.stopFrame && !object.shapes[lastKey].outside) {\n                            const interpolated = this.stopFrame - lastKey;\n                            labels[label].interpolated += interpolated;\n                            labels[label].total += interpolated;\n                        }\n                    } else {\n                        labels[label].manually++;\n                        labels[label].total++;\n                    }\n                }\n            }\n\n            for (const label of Object.keys(labels)) {\n                for (const key of Object.keys(labels[label])) {\n                    if (typeof (labels[label][key]) === 'object') {\n                        for (const objectType of Object.keys(labels[label][key])) {\n                            total[key][objectType] += labels[label][key][objectType];\n                        }\n                    } else {\n                        total[key] += labels[label][key];\n                    }\n                }\n            }\n\n            return new Statistics(labels, total);\n        }\n\n        put(objectStates) {\n            checkObjectType('shapes for put', objectStates, null, Array);\n            const constructed = {\n                shapes: [],\n                tracks: [],\n                tags: [],\n            };\n\n            function convertAttributes(accumulator, attrID) {\n                const specID = +attrID;\n                const value = this.attributes[attrID];\n\n                checkObjectType('attribute id', specID, 'integer', null);\n                checkObjectType('attribute value', value, 'string', null);\n\n                accumulator.push({\n                    spec_id: specID,\n                    value,\n                });\n\n                return accumulator;\n            }\n\n            for (const state of objectStates) {\n                checkObjectType('object state', state, null, ObjectState);\n                checkObjectType('state client ID', state.clientID, 'undefined', null);\n                checkObjectType('state frame', state.frame, 'integer', null);\n                checkObjectType('state attributes', state.attributes, null, Object);\n                checkObjectType('state label', state.label, null, Label);\n\n                const attributes = Object.keys(state.attributes)\n                    .reduce(convertAttributes.bind(state), []);\n                const labelAttributes = state.label.attributes.reduce((accumulator, attribute) => {\n                    accumulator[attribute.id] = attribute;\n                    return accumulator;\n                }, {});\n\n                // Construct whole objects from states\n                if (state.objectType === 'tag') {\n                    constructed.tags.push({\n                        attributes,\n                        frame: state.frame,\n                        label_id: state.label.id,\n                        group: 0,\n                    });\n                } else {\n                    checkObjectType('state occluded', state.occluded, 'boolean', null);\n                    checkObjectType('state points', state.points, null, Array);\n\n                    for (const coord of state.points) {\n                        checkObjectType('point coordinate', coord, 'number', null);\n                    }\n\n                    if (!Object.values(ObjectShape).includes(state.shapeType)) {\n                        throw new ArgumentError(\n                            'Object shape must be one of: '\n                                + `${JSON.stringify(Object.values(ObjectShape))}`,\n                        );\n                    }\n\n                    if (state.objectType === 'shape') {\n                        constructed.shapes.push({\n                            attributes,\n                            frame: state.frame,\n                            group: 0,\n                            label_id: state.label.id,\n                            occluded: state.occluded || false,\n                            points: [...state.points],\n                            type: state.shapeType,\n                            z_order: 0,\n                        });\n                    } else if (state.objectType === 'track') {\n                        constructed.tracks.push({\n                            attributes: attributes\n                                .filter(attr => !labelAttributes[attr.spec_id].mutable),\n                            frame: state.frame,\n                            group: 0,\n                            label_id: state.label.id,\n                            shapes: [{\n                                attributes: attributes\n                                    .filter(attr => labelAttributes[attr.spec_id].mutable),\n                                frame: state.frame,\n                                occluded: state.occluded || false,\n                                outside: false,\n                                points: [...state.points],\n                                type: state.shapeType,\n                                z_order: 0,\n                            }],\n                        });\n                    } else {\n                        throw new ArgumentError(\n                            'Object type must be one of: '\n                                + `${JSON.stringify(Object.values(ObjectType))}`,\n                        );\n                    }\n                }\n            }\n\n            // Add constructed objects to a collection\n            this.import(constructed);\n        }\n\n        select(objectStates, x, y) {\n            checkObjectType('shapes for select', objectStates, null, Array);\n            checkObjectType('x coordinate', x, 'number', null);\n            checkObjectType('y coordinate', y, 'number', null);\n\n            let minimumDistance = null;\n            let minimumState = null;\n            for (const state of objectStates) {\n                checkObjectType('object state', state, null, ObjectState);\n                if (state.outside) continue;\n\n                const object = this.objects[state.clientID];\n                if (typeof (object) === 'undefined') {\n                    throw new ArgumentError(\n                        'The object has not been saved yet. Call annotations.put([state]) before',\n                    );\n                }\n\n                const distance = object.constructor.distance(state.points, x, y);\n                if (distance !== null && (minimumDistance === null || distance < minimumDistance)) {\n                    minimumDistance = distance;\n                    minimumState = state;\n                }\n            }\n\n            return {\n                state: minimumState,\n                distance: minimumDistance,\n            };\n        }\n    }\n\n    module.exports = Collection;\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n(() => {\n    const ObjectState = require('./object-state');\n    const {\n        checkObjectType,\n        isEnum,\n    } = require('./common');\n    const {\n        ObjectShape,\n        ObjectType,\n        AttributeType,\n        VisibleState,\n    } = require('./enums');\n\n    const {\n        DataError,\n        ArgumentError,\n        ScriptingError,\n    } = require('./exceptions');\n\n    const { Label } = require('./labels');\n\n    // Called with the Annotation context\n    function objectStateFactory(frame, data) {\n        const objectState = new ObjectState(data);\n\n        objectState.hidden = {\n            save: this.save.bind(this, frame, objectState),\n            delete: this.delete.bind(this),\n            up: this.up.bind(this, frame, objectState),\n            down: this.down.bind(this, frame, objectState),\n        };\n\n        return objectState;\n    }\n\n    function checkNumberOfPoints(shapeType, points) {\n        if (shapeType === ObjectShape.RECTANGLE) {\n            if (points.length / 2 !== 2) {\n                throw new DataError(\n                    `Rectangle must have 2 points, but got ${points.length / 2}`,\n                );\n            }\n        } else if (shapeType === ObjectShape.POLYGON) {\n            if (points.length / 2 < 3) {\n                throw new DataError(\n                    `Polygon must have at least 3 points, but got ${points.length / 2}`,\n                );\n            }\n        } else if (shapeType === ObjectShape.POLYLINE) {\n            if (points.length / 2 < 2) {\n                throw new DataError(\n                    `Polyline must have at least 2 points, but got ${points.length / 2}`,\n                );\n            }\n        } else if (shapeType === ObjectShape.POINTS) {\n            if (points.length / 2 < 1) {\n                throw new DataError(\n                    `Points must have at least 1 points, but got ${points.length / 2}`,\n                );\n            }\n        } else {\n            throw new ArgumentError(\n                `Unknown value of shapeType has been recieved ${shapeType}`,\n            );\n        }\n    }\n\n    function checkShapeArea(shapeType, points) {\n        const MIN_SHAPE_LENGTH = 3;\n        const MIN_SHAPE_AREA = 9;\n\n        if (shapeType === ObjectShape.POINTS) {\n            return true;\n        }\n\n        let xmin = Number.MAX_SAFE_INTEGER;\n        let xmax = Number.MIN_SAFE_INTEGER;\n        let ymin = Number.MAX_SAFE_INTEGER;\n        let ymax = Number.MIN_SAFE_INTEGER;\n\n        for (let i = 0; i < points.length - 1; i += 2) {\n            xmin = Math.min(xmin, points[i]);\n            xmax = Math.max(xmax, points[i]);\n            ymin = Math.min(ymin, points[i + 1]);\n            ymax = Math.max(ymax, points[i + 1]);\n        }\n\n        if (shapeType === ObjectShape.POLYLINE) {\n            const length = Math.max(\n                xmax - xmin,\n                ymax - ymin,\n            );\n\n            return length >= MIN_SHAPE_LENGTH;\n        }\n\n        const area = (xmax - xmin) * (ymax - ymin);\n        return area >= MIN_SHAPE_AREA;\n    }\n\n    function validateAttributeValue(value, attr) {\n        const { values } = attr;\n        const type = attr.inputType;\n\n        if (typeof (value) !== 'string') {\n            throw new ArgumentError(\n                `Attribute value is expected to be string, but got ${typeof (value)}`,\n            );\n        }\n\n        if (type === AttributeType.NUMBER) {\n            return +value >= +values[0]\n                && +value <= +values[1]\n                && !((+value - +values[0]) % +values[2]);\n        }\n\n        if (type === AttributeType.CHECKBOX) {\n            return ['true', 'false'].includes(value.toLowerCase());\n        }\n\n        return values.includes(value);\n    }\n\n    class Annotation {\n        constructor(data, clientID, injection) {\n            this.taskLabels = injection.labels;\n            this.clientID = clientID;\n            this.serverID = data.id;\n            this.group = data.group;\n            this.label = this.taskLabels[data.label_id];\n            this.frame = data.frame;\n            this.removed = false;\n            this.lock = false;\n            this.attributes = data.attributes.reduce((attributeAccumulator, attr) => {\n                attributeAccumulator[attr.spec_id] = attr.value;\n                return attributeAccumulator;\n            }, {});\n            this.appendDefaultAttributes(this.label);\n\n            injection.groups.max = Math.max(injection.groups.max, this.group);\n        }\n\n        appendDefaultAttributes(label) {\n            const labelAttributes = label.attributes;\n            for (const attribute of labelAttributes) {\n                if (!(attribute.id in this.attributes)) {\n                    this.attributes[attribute.id] = attribute.defaultValue;\n                }\n            }\n        }\n\n        delete(force) {\n            if (!this.lock || force) {\n                this.removed = true;\n            }\n\n            return true;\n        }\n    }\n\n    class Drawn extends Annotation {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, injection);\n\n            this.frameMeta = injection.frameMeta;\n            this.collectionZ = injection.collectionZ;\n            this.visibility = VisibleState.SHAPE;\n\n            this.color = color;\n            this.shapeType = null;\n        }\n\n        _getZ(frame) {\n            this.collectionZ[frame] = this.collectionZ[frame] || {\n                max: 0,\n                min: 0,\n            };\n\n            return this.collectionZ[frame];\n        }\n\n        save() {\n            throw new ScriptingError(\n                'Is not implemented',\n            );\n        }\n\n        get() {\n            throw new ScriptingError(\n                'Is not implemented',\n            );\n        }\n\n        toJSON() {\n            throw new ScriptingError(\n                'Is not implemented',\n            );\n        }\n\n        // Increase ZOrder within frame\n        up(frame, objectState) {\n            const z = this._getZ(frame);\n            z.max++;\n            objectState.zOrder = z.max;\n        }\n\n        // Decrease ZOrder within frame\n        down(frame, objectState) {\n            const z = this._getZ(frame);\n            z.min--;\n            objectState.zOrder = z.min;\n        }\n    }\n\n    class Shape extends Drawn {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n            this.points = data.points;\n            this.occluded = data.occluded;\n            this.zOrder = data.z_order;\n\n            const z = this._getZ(this.frame);\n            z.max = Math.max(z.max, this.zOrder || 0);\n            z.min = Math.min(z.min, this.zOrder || 0);\n        }\n\n        // Method is used to export data to the server\n        toJSON() {\n            return {\n                type: this.shapeType,\n                clientID: this.clientID,\n                occluded: this.occluded,\n                z_order: this.zOrder,\n                points: [...this.points],\n                attributes: Object.keys(this.attributes).reduce((attributeAccumulator, attrId) => {\n                    attributeAccumulator.push({\n                        spec_id: attrId,\n                        value: this.attributes[attrId],\n                    });\n\n                    return attributeAccumulator;\n                }, []),\n                id: this.serverID,\n                frame: this.frame,\n                label_id: this.label.id,\n                group: this.group,\n            };\n        }\n\n        // Method is used to construct ObjectState objects\n        get(frame) {\n            if (frame !== this.frame) {\n                throw new ScriptingError(\n                    'Got frame is not equal to the frame of the shape',\n                );\n            }\n\n            return {\n                objectType: ObjectType.SHAPE,\n                shapeType: this.shapeType,\n                clientID: this.clientID,\n                serverID: this.serverID,\n                occluded: this.occluded,\n                lock: this.lock,\n                zOrder: this.zOrder,\n                points: [...this.points],\n                attributes: Object.assign({}, this.attributes),\n                label: this.label,\n                group: this.group,\n                color: this.color,\n                visibility: this.visibility,\n            };\n        }\n\n        save(frame, data) {\n            if (frame !== this.frame) {\n                throw new ScriptingError(\n                    'Got frame is not equal to the frame of the shape',\n                );\n            }\n\n            if (this.lock && data.lock) {\n                return objectStateFactory.call(this, frame, this.get(frame));\n            }\n\n            // All changes are done in this temporary object\n            const copy = this.get(frame);\n            const updated = data.updateFlags;\n\n            if (updated.label) {\n                checkObjectType('label', data.label, null, Label);\n                copy.label = data.label;\n                copy.attributes = {};\n                this.appendDefaultAttributes.call(copy, copy.label);\n            }\n\n            if (updated.attributes) {\n                const labelAttributes = copy.label.attributes\n                    .reduce((accumulator, value) => {\n                        accumulator[value.id] = value;\n                        return accumulator;\n                    }, {});\n\n                for (const attrID of Object.keys(data.attributes)) {\n                    const value = data.attributes[attrID];\n                    if (attrID in labelAttributes\n                        && validateAttributeValue(value, labelAttributes[attrID])) {\n                        copy.attributes[attrID] = value;\n                    } else {\n                        throw new ArgumentError(\n                            `Trying to save unknown attribute with id ${attrID} and value ${value}`,\n                        );\n                    }\n                }\n            }\n\n            if (updated.points) {\n                checkObjectType('points', data.points, null, Array);\n                checkNumberOfPoints(this.shapeType, data.points);\n\n                // cut points\n                const { width, height } = this.frameMeta[frame];\n                const cutPoints = [];\n                for (let i = 0; i < data.points.length - 1; i += 2) {\n                    const x = data.points[i];\n                    const y = data.points[i + 1];\n\n                    checkObjectType('coordinate', x, 'number', null);\n                    checkObjectType('coordinate', y, 'number', null);\n\n                    cutPoints.push(\n                        Math.clamp(x, 0, width),\n                        Math.clamp(y, 0, height),\n                    );\n                }\n\n                if (checkShapeArea(this.shapeType, cutPoints)) {\n                    copy.points = cutPoints;\n                }\n            }\n\n            if (updated.occluded) {\n                checkObjectType('occluded', data.occluded, 'boolean', null);\n                copy.occluded = data.occluded;\n            }\n\n            if (updated.group) {\n                checkObjectType('group', data.group, 'integer', null);\n                copy.group = data.group;\n            }\n\n            if (updated.zOrder) {\n                checkObjectType('zOrder', data.zOrder, 'integer', null);\n                copy.zOrder = data.zOrder;\n            }\n\n            if (updated.lock) {\n                checkObjectType('lock', data.lock, 'boolean', null);\n                copy.lock = data.lock;\n            }\n\n            if (updated.color) {\n                checkObjectType('color', data.color, 'string', null);\n                if (/^#[0-9A-F]{6}$/i.test(data.color)) {\n                    throw new ArgumentError(\n                        `Got invalid color value: \"${data.color}\"`,\n                    );\n                }\n\n                copy.color = data.color;\n            }\n\n            if (updated.visibility) {\n                if (!isEnum.call(VisibleState, data.visibility)) {\n                    throw new ArgumentError(\n                        `Got invalid visibility value: \"${data.visibility}\"`,\n                    );\n                }\n\n                copy.visibility = data.visibility;\n            }\n\n            // Reset flags and commit all changes\n            updated.reset();\n            for (const prop of Object.keys(copy)) {\n                if (prop in this) {\n                    this[prop] = copy[prop];\n                }\n            }\n\n            return objectStateFactory.call(this, frame, this.get(frame));\n        }\n    }\n\n    class Track extends Drawn {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n            this.shapes = data.shapes.reduce((shapeAccumulator, value) => {\n                shapeAccumulator[value.frame] = {\n                    serverID: value.id,\n                    occluded: value.occluded,\n                    zOrder: value.z_order,\n                    points: value.points,\n                    outside: value.outside,\n                    attributes: value.attributes.reduce((attributeAccumulator, attr) => {\n                        attributeAccumulator[attr.spec_id] = attr.value;\n                        return attributeAccumulator;\n                    }, {}),\n                };\n\n                const z = this._getZ(value.frame);\n                z.max = Math.max(z.max, value.z_order);\n                z.min = Math.min(z.min, value.z_order);\n\n                return shapeAccumulator;\n            }, {});\n\n            this.cache = {};\n        }\n\n        // Method is used to export data to the server\n        toJSON() {\n            const labelAttributes = this.label.attributes.reduce((accumulator, attribute) => {\n                accumulator[attribute.id] = attribute;\n                return accumulator;\n            }, {});\n\n            return {\n                clientID: this.clientID,\n                id: this.serverID,\n                frame: this.frame,\n                label_id: this.label.id,\n                group: this.group,\n                attributes: Object.keys(this.attributes).reduce((attributeAccumulator, attrId) => {\n                    if (!labelAttributes[attrId].mutable) {\n                        attributeAccumulator.push({\n                            spec_id: attrId,\n                            value: this.attributes[attrId],\n                        });\n                    }\n\n                    return attributeAccumulator;\n                }, []),\n                shapes: Object.keys(this.shapes).reduce((shapesAccumulator, frame) => {\n                    shapesAccumulator.push({\n                        type: this.shapeType,\n                        occluded: this.shapes[frame].occluded,\n                        z_order: this.shapes[frame].zOrder,\n                        points: [...this.shapes[frame].points],\n                        outside: this.shapes[frame].outside,\n                        attributes: Object.keys(this.shapes[frame].attributes)\n                            .reduce((attributeAccumulator, attrId) => {\n                                if (labelAttributes[attrId].mutable) {\n                                    attributeAccumulator.push({\n                                        spec_id: attrId,\n                                        value: this.shapes[frame].attributes[attrId],\n                                    });\n                                }\n\n                                return attributeAccumulator;\n                            }, []),\n                        id: this.shapes[frame].serverID,\n                        frame: +frame,\n                    });\n\n                    return shapesAccumulator;\n                }, []),\n            };\n        }\n\n        // Method is used to construct ObjectState objects\n        get(frame) {\n            if (!(frame in this.cache)) {\n                const interpolation = Object.assign(\n                    {}, this.getPosition(frame),\n                    {\n                        attributes: this.getAttributes(frame),\n                        group: this.group,\n                        objectType: ObjectType.TRACK,\n                        shapeType: this.shapeType,\n                        clientID: this.clientID,\n                        serverID: this.serverID,\n                        lock: this.lock,\n                        color: this.color,\n                        visibility: this.visibility,\n                    },\n                );\n\n                this.cache[frame] = interpolation;\n            }\n\n            const result = JSON.parse(JSON.stringify(this.cache[frame]));\n            result.label = this.label;\n            return result;\n        }\n\n        neighborsFrames(targetFrame) {\n            const frames = Object.keys(this.shapes).map(frame => +frame);\n            let lDiff = Number.MAX_SAFE_INTEGER;\n            let rDiff = Number.MAX_SAFE_INTEGER;\n\n            for (const frame of frames) {\n                const diff = Math.abs(targetFrame - frame);\n                if (frame <= targetFrame && diff < lDiff) {\n                    lDiff = diff;\n                } else if (diff < rDiff) {\n                    rDiff = diff;\n                }\n            }\n\n            const leftFrame = lDiff === Number.MAX_SAFE_INTEGER ? null : targetFrame - lDiff;\n            const rightFrame = rDiff === Number.MAX_SAFE_INTEGER ? null : targetFrame + rDiff;\n\n            return {\n                leftFrame,\n                rightFrame,\n            };\n        }\n\n        getAttributes(targetFrame) {\n            const result = {};\n\n            // First of all copy all unmutable attributes\n            for (const attrID in this.attributes) {\n                if (Object.prototype.hasOwnProperty.call(this.attributes, attrID)) {\n                    result[attrID] = this.attributes[attrID];\n                }\n            }\n\n            // Secondly get latest mutable attributes up to target frame\n            const frames = Object.keys(this.shapes).sort((a, b) => +a - +b);\n            for (const frame of frames) {\n                if (frame <= targetFrame) {\n                    const { attributes } = this.shapes[frame];\n\n                    for (const attrID in attributes) {\n                        if (Object.prototype.hasOwnProperty.call(attributes, attrID)) {\n                            result[attrID] = attributes[attrID];\n                        }\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        save(frame, data) {\n            if (this.lock && data.lock) {\n                return objectStateFactory.call(this, frame, this.get(frame));\n            }\n\n            // All changes are done in this temporary object\n            const copy = Object.assign(this.get(frame));\n            copy.attributes = Object.assign(copy.attributes);\n            copy.points = [...copy.points];\n\n            const updated = data.updateFlags;\n            let positionUpdated = false;\n\n            if (updated.label) {\n                checkObjectType('label', data.label, null, Label);\n                copy.label = data.label;\n                copy.attributes = {};\n\n                // Shape attributes will be removed later after all checks\n                this.appendDefaultAttributes.call(copy, copy.label);\n            }\n\n            const labelAttributes = copy.label.attributes\n                .reduce((accumulator, value) => {\n                    accumulator[value.id] = value;\n                    return accumulator;\n                }, {});\n\n            if (updated.attributes) {\n                for (const attrID of Object.keys(data.attributes)) {\n                    const value = data.attributes[attrID];\n                    if (attrID in labelAttributes\n                        && validateAttributeValue(value, labelAttributes[attrID])) {\n                        copy.attributes[attrID] = value;\n                    } else {\n                        throw new ArgumentError(\n                            `Trying to save unknown attribute with id ${attrID} and value ${value}`,\n                        );\n                    }\n                }\n            }\n\n            if (updated.points) {\n                checkObjectType('points', data.points, null, Array);\n                checkNumberOfPoints(this.shapeType, data.points);\n\n                // cut points\n                const { width, height } = this.frameMeta[frame];\n                const cutPoints = [];\n                for (let i = 0; i < data.points.length - 1; i += 2) {\n                    const x = data.points[i];\n                    const y = data.points[i + 1];\n\n                    checkObjectType('coordinate', x, 'number', null);\n                    checkObjectType('coordinate', y, 'number', null);\n\n                    cutPoints.push(\n                        Math.clamp(x, 0, width),\n                        Math.clamp(y, 0, height),\n                    );\n                }\n\n                if (checkShapeArea(this.shapeType, cutPoints)) {\n                    copy.points = cutPoints;\n                    positionUpdated = true;\n                }\n            }\n\n            if (updated.occluded) {\n                checkObjectType('occluded', data.occluded, 'boolean', null);\n                copy.occluded = data.occluded;\n                positionUpdated = true;\n            }\n\n            if (updated.outside) {\n                checkObjectType('outside', data.outside, 'boolean', null);\n                copy.outside = data.outside;\n                positionUpdated = true;\n            }\n\n            if (updated.group) {\n                checkObjectType('group', data.group, 'integer', null);\n                copy.group = data.group;\n            }\n\n            if (updated.zOrder) {\n                checkObjectType('zOrder', data.zOrder, 'integer', null);\n                copy.zOrder = data.zOrder;\n                positionUpdated = true;\n            }\n\n            if (updated.lock) {\n                checkObjectType('lock', data.lock, 'boolean', null);\n                copy.lock = data.lock;\n            }\n\n            if (updated.color) {\n                checkObjectType('color', data.color, 'string', null);\n                if (/^#[0-9A-F]{6}$/i.test(data.color)) {\n                    throw new ArgumentError(\n                        `Got invalid color value: \"${data.color}\"`,\n                    );\n                }\n\n                copy.color = data.color;\n            }\n\n            if (updated.visibility) {\n                if (!isEnum.call(VisibleState, data.visibility)) {\n                    throw new ArgumentError(\n                        `Got invalid visibility value: \"${data.visibility}\"`,\n                    );\n                }\n\n                copy.visibility = data.visibility;\n            }\n\n            if (updated.keyframe) {\n                // Just check here\n                checkObjectType('keyframe', data.keyframe, 'boolean', null);\n            }\n\n            // Commit all changes\n            for (const prop of Object.keys(copy)) {\n                if (prop in this) {\n                    this[prop] = copy[prop];\n                }\n\n                this.cache[frame][prop] = copy[prop];\n            }\n\n            if (updated.attributes) {\n                // Mutable attributes will be updated below\n                for (const attrID of Object.keys(copy.attributes)) {\n                    if (!labelAttributes[attrID].mutable) {\n                        this.shapes[frame].attributes[attrID] = data.attributes[attrID];\n                        this.shapes[frame].attributes[attrID] = data.attributes[attrID];\n                    }\n                }\n            }\n\n            if (updated.label) {\n                for (const shape of Object.values(this.shapes)) {\n                    shape.attributes = {};\n                }\n            }\n\n            // Remove keyframe\n            if (updated.keyframe && !data.keyframe) {\n                // Remove all cache after this keyframe because it have just become outdated\n                for (const cacheFrame in this.cache) {\n                    if (+cacheFrame > frame) {\n                        delete this.cache[cacheFrame];\n                    }\n                }\n\n                this.cache[frame].keyframe = false;\n                delete this.shapes[frame];\n                updated.reset();\n\n                return objectStateFactory.call(this, frame, this.get(frame));\n            }\n\n            // Add/update keyframe\n            if (positionUpdated || (updated.keyframe && data.keyframe)) {\n                // Remove all cache after this keyframe because it have just become outdated\n                for (const cacheFrame in this.cache) {\n                    if (+cacheFrame > frame) {\n                        delete this.cache[cacheFrame];\n                    }\n                }\n\n                this.cache[frame].keyframe = true;\n                data.keyframe = true;\n\n                this.shapes[frame] = {\n                    frame,\n                    zOrder: copy.zOrder,\n                    points: copy.points,\n                    outside: copy.outside,\n                    occluded: copy.occluded,\n                    attributes: {},\n                };\n\n                if (updated.attributes) {\n                    // Unmutable attributes were updated above\n                    for (const attrID of Object.keys(copy.attributes)) {\n                        if (labelAttributes[attrID].mutable) {\n                            this.shapes[frame].attributes[attrID] = data.attributes[attrID];\n                            this.shapes[frame].attributes[attrID] = data.attributes[attrID];\n                        }\n                    }\n                }\n            }\n\n            updated.reset();\n\n            return objectStateFactory.call(this, frame, this.get(frame));\n        }\n\n        getPosition(targetFrame) {\n            const {\n                leftFrame,\n                rightFrame,\n            } = this.neighborsFrames(targetFrame);\n\n            const rightPosition = Number.isInteger(rightFrame) ? this.shapes[rightFrame] : null;\n            const leftPosition = Number.isInteger(leftFrame) ? this.shapes[leftFrame] : null;\n\n            if (leftPosition && leftFrame === targetFrame) {\n                return {\n                    points: [...leftPosition.points],\n                    occluded: leftPosition.occluded,\n                    outside: leftPosition.outside,\n                    zOrder: leftPosition.zOrder,\n                    keyframe: true,\n                };\n            }\n\n            if (rightPosition && leftPosition) {\n                return Object.assign({}, this.interpolatePosition(\n                    leftPosition,\n                    rightPosition,\n                    (targetFrame - leftFrame) / (rightFrame - leftFrame),\n                ), {\n                    keyframe: false,\n                });\n            }\n\n            if (rightPosition) {\n                return {\n                    points: [...rightPosition.points],\n                    occluded: rightPosition.occluded,\n                    outside: true,\n                    zOrder: 0,\n                    keyframe: false,\n                };\n            }\n\n            if (leftPosition) {\n                return {\n                    points: [...leftPosition.points],\n                    occluded: leftPosition.occluded,\n                    outside: leftPosition.outside,\n                    zOrder: 0,\n                    keyframe: false,\n                };\n            }\n\n            throw new ScriptingError(\n                `No one neightbour frame found for the track with client ID: \"${this.id}\"`,\n            );\n        }\n\n        delete(force) {\n            if (!this.lock || force) {\n                this.removed = true;\n                this.resetCache();\n            }\n\n            return true;\n        }\n\n        resetCache() {\n            this.cache = {};\n        }\n    }\n\n    class Tag extends Annotation {\n        constructor(data, clientID, injection) {\n            super(data, clientID, injection);\n        }\n\n        // Method is used to export data to the server\n        toJSON() {\n            return {\n                clientID: this.clientID,\n                id: this.serverID,\n                frame: this.frame,\n                label_id: this.label.id,\n                group: this.group,\n                attributes: Object.keys(this.attributes).reduce((attributeAccumulator, attrId) => {\n                    attributeAccumulator.push({\n                        spec_id: attrId,\n                        value: this.attributes[attrId],\n                    });\n\n                    return attributeAccumulator;\n                }, []),\n            };\n        }\n\n        // Method is used to construct ObjectState objects\n        get(frame) {\n            if (frame !== this.frame) {\n                throw new ScriptingError(\n                    'Got frame is not equal to the frame of the shape',\n                );\n            }\n\n            return {\n                objectType: ObjectType.TAG,\n                clientID: this.clientID,\n                serverID: this.serverID,\n                lock: this.lock,\n                attributes: Object.assign({}, this.attributes),\n                label: this.label,\n                group: this.group,\n            };\n        }\n\n        save(frame, data) {\n            if (frame !== this.frame) {\n                throw new ScriptingError(\n                    'Got frame is not equal to the frame of the shape',\n                );\n            }\n\n            if (this.lock && data.lock) {\n                return objectStateFactory.call(this, frame, this.get(frame));\n            }\n\n            // All changes are done in this temporary object\n            const copy = this.get(frame);\n            const updated = data.updateFlags;\n\n            if (updated.label) {\n                checkObjectType('label', data.label, null, Label);\n                copy.label = data.label;\n                copy.attributes = {};\n                this.appendDefaultAttributes.call(copy, copy.label);\n            }\n\n            if (updated.attributes) {\n                const labelAttributes = copy.label\n                    .attributes.map(attr => `${attr.id}`);\n\n                for (const attrID of Object.keys(data.attributes)) {\n                    if (labelAttributes.includes(attrID)) {\n                        copy.attributes[attrID] = data.attributes[attrID];\n                    }\n                }\n            }\n\n            if (updated.group) {\n                checkObjectType('group', data.group, 'integer', null);\n                copy.group = data.group;\n            }\n\n            if (updated.lock) {\n                checkObjectType('lock', data.lock, 'boolean', null);\n                copy.lock = data.lock;\n            }\n\n            // Reset flags and commit all changes\n            updated.reset();\n            for (const prop of Object.keys(copy)) {\n                if (prop in this) {\n                    this[prop] = copy[prop];\n                }\n            }\n\n            return objectStateFactory.call(this, frame, this.get(frame));\n        }\n    }\n\n    class RectangleShape extends Shape {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n            this.shapeType = ObjectShape.RECTANGLE;\n            checkNumberOfPoints(this.shapeType, this.points);\n        }\n\n        static distance(points, x, y) {\n            const [xtl, ytl, xbr, ybr] = points;\n\n            if (!(x >= xtl && x <= xbr && y >= ytl && y <= ybr)) {\n                // Cursor is outside of a box\n                return null;\n            }\n\n            // The shortest distance from point to an edge\n            return Math.min.apply(null, [x - xtl, y - ytl, xbr - x, ybr - y]);\n        }\n    }\n\n    class PolyShape extends Shape {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n        }\n    }\n\n    class PolygonShape extends PolyShape {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n            this.shapeType = ObjectShape.POLYGON;\n            checkNumberOfPoints(this.shapeType, this.points);\n        }\n\n        static distance(points, x, y) {\n            function position(x1, y1, x2, y2) {\n                return ((x2 - x1) * (y - y1) - (x - x1) * (y2 - y1));\n            }\n\n            let wn = 0;\n            const distances = [];\n\n            for (let i = 0, j = points.length - 2; i < points.length - 1; j = i, i += 2) {\n                // Current point\n                const x1 = points[j];\n                const y1 = points[j + 1];\n\n                // Next point\n                const x2 = points[i];\n                const y2 = points[i + 1];\n\n                // Check if a point is inside a polygon\n                // with a winding numbers algorithm\n                // https://en.wikipedia.org/wiki/Point_in_polygon#Winding_number_algorithm\n                if (y1 <= y) {\n                    if (y2 > y) {\n                        if (position(x1, y1, x2, y2) > 0) {\n                            wn++;\n                        }\n                    }\n                } else if (y2 <= y) {\n                    if (position(x1, y1, x2, y2) < 0) {\n                        wn--;\n                    }\n                }\n\n                // Find the shortest distance from point to an edge\n                // Get an equation of a line in general\n                const aCoef = (y1 - y2);\n                const bCoef = (x2 - x1);\n\n                // Vector (aCoef, bCoef) is a perpendicular to line\n                // Now find the point where two lines\n                // (edge and its perpendicular through the point (x,y)) are cross\n                const xCross = x - aCoef;\n                const yCross = y - bCoef;\n\n                if (((xCross - x1) * (x2 - xCross)) >= 0\n                    && ((yCross - y1) * (y2 - yCross)) >= 0) {\n                    // Cross point is on segment between p1(x1,y1) and p2(x2,y2)\n                    distances.push(Math.sqrt(\n                        Math.pow(x - xCross, 2)\n                        + Math.pow(y - yCross, 2),\n                    ));\n                } else {\n                    distances.push(\n                        Math.min(\n                            Math.sqrt(Math.pow(x1 - x, 2) + Math.pow(y1 - y, 2)),\n                            Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2)),\n                        ),\n                    );\n                }\n            }\n\n            if (wn !== 0) {\n                return Math.min.apply(null, distances);\n            }\n\n            return null;\n        }\n    }\n\n    class PolylineShape extends PolyShape {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n            this.shapeType = ObjectShape.POLYLINE;\n            checkNumberOfPoints(this.shapeType, this.points);\n        }\n\n        static distance(points, x, y) {\n            const distances = [];\n            for (let i = 0; i < points.length - 2; i += 2) {\n                // Current point\n                const x1 = points[i];\n                const y1 = points[i + 1];\n\n                // Next point\n                const x2 = points[i + 2];\n                const y2 = points[i + 3];\n\n                // Find the shortest distance from point to an edge\n                if (((x - x1) * (x2 - x)) >= 0 && ((y - y1) * (y2 - y)) >= 0) {\n                    // Find the length of a perpendicular\n                    // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line\n                    distances.push(\n                        Math.abs((y2 - y1) * x - (x2 - x1) * y + x2 * y1 - y2 * x1) / Math\n                            .sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2)),\n                    );\n                } else {\n                    // The link below works for lines (which have infinit length)\n                    // There is a case when perpendicular doesn't cross the edge\n                    // In this case we don't use the computed distance\n                    // Instead we use just distance to the nearest point\n                    distances.push(\n                        Math.min(\n                            Math.sqrt(Math.pow(x1 - x, 2) + Math.pow(y1 - y, 2)),\n                            Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2)),\n                        ),\n                    );\n                }\n            }\n\n            return Math.min.apply(null, distances);\n        }\n    }\n\n    class PointsShape extends PolyShape {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n            this.shapeType = ObjectShape.POINTS;\n            checkNumberOfPoints(this.shapeType, this.points);\n        }\n\n        static distance(points, x, y) {\n            const distances = [];\n            for (let i = 0; i < points.length; i += 2) {\n                const x1 = points[i];\n                const y1 = points[i + 1];\n\n                distances.push(\n                    Math.sqrt(Math.pow(x1 - x, 2) + Math.pow(y1 - y, 2)),\n                );\n            }\n\n            return Math.min.apply(null, distances);\n        }\n    }\n\n    class RectangleTrack extends Track {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n            this.shapeType = ObjectShape.RECTANGLE;\n            for (const shape of Object.values(this.shapes)) {\n                checkNumberOfPoints(this.shapeType, shape.points);\n            }\n        }\n\n        interpolatePosition(leftPosition, rightPosition, offset) {\n            const positionOffset = [\n                rightPosition.points[0] - leftPosition.points[0],\n                rightPosition.points[1] - leftPosition.points[1],\n                rightPosition.points[2] - leftPosition.points[2],\n                rightPosition.points[3] - leftPosition.points[3],\n            ];\n\n            return { // xtl, ytl, xbr, ybr\n                points: [\n                    leftPosition.points[0] + positionOffset[0] * offset,\n                    leftPosition.points[1] + positionOffset[1] * offset,\n                    leftPosition.points[2] + positionOffset[2] * offset,\n                    leftPosition.points[3] + positionOffset[3] * offset,\n                ],\n                occluded: leftPosition.occluded,\n                outside: leftPosition.outside,\n                zOrder: leftPosition.zOrder,\n            };\n        }\n    }\n\n    class PolyTrack extends Track {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n        }\n\n        interpolatePosition(leftPosition, rightPosition, offset) {\n            function findBox(points) {\n                let xmin = Number.MAX_SAFE_INTEGER;\n                let ymin = Number.MAX_SAFE_INTEGER;\n                let xmax = Number.MIN_SAFE_INTEGER;\n                let ymax = Number.MIN_SAFE_INTEGER;\n\n                for (let i = 0; i < points.length; i += 2) {\n                    if (points[i] < xmin) xmin = points[i];\n                    if (points[i + 1] < ymin) ymin = points[i + 1];\n                    if (points[i] > xmax) xmax = points[i];\n                    if (points[i + 1] > ymax) ymax = points[i + 1];\n                }\n\n                return {\n                    xmin,\n                    ymin,\n                    xmax,\n                    ymax,\n                };\n            }\n\n            function normalize(points, box) {\n                const normalized = [];\n                const width = box.xmax - box.xmin;\n                const height = box.ymax - box.ymin;\n\n                for (let i = 0; i < points.length; i += 2) {\n                    normalized.push(\n                        (points[i] - box.xmin) / width,\n                        (points[i + 1] - box.ymin) / height,\n                    );\n                }\n\n                return normalized;\n            }\n\n            function denormalize(points, box) {\n                const denormalized = [];\n                const width = box.xmax - box.xmin;\n                const height = box.ymax - box.ymin;\n\n                for (let i = 0; i < points.length; i += 2) {\n                    denormalized.push(\n                        points[i] * width + box.xmin,\n                        points[i + 1] * height + box.ymin,\n                    );\n                }\n\n                return denormalized;\n            }\n\n            function toPoints(array) {\n                const points = [];\n                for (let i = 0; i < array.length; i += 2) {\n                    points.push({\n                        x: array[i],\n                        y: array[i + 1],\n                    });\n                }\n\n                return points;\n            }\n\n            function toArray(points) {\n                const array = [];\n                for (const point of points) {\n                    array.push(point.x, point.y);\n                }\n\n                return array;\n            }\n\n            function computeDistances(source, target) {\n                const distances = {};\n                for (let i = 0; i < source.length; i++) {\n                    distances[i] = distances[i] || {};\n                    for (let j = 0; j < target.length; j++) {\n                        const dx = source[i].x - target[j].x;\n                        const dy = source[i].y - target[j].y;\n\n                        distances[i][j] = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n                    }\n                }\n\n                return distances;\n            }\n\n            function truncateByThreshold(mapping, threshold) {\n                for (const key of Object.keys(mapping)) {\n                    if (mapping[key].distance > threshold) {\n                        delete mapping[key];\n                    }\n                }\n            }\n\n            // https://en.wikipedia.org/wiki/Stable_marriage_problem\n            // TODO: One of important part of the algorithm is to correctly match\n            // \"corner\" points. Thus it is possible for each of such point calculate\n            // a descriptor (d) and use (x, y, d) to calculate the distance. One more\n            // idea is to be sure that order or matched points is preserved. For example,\n            // if p1 matches q1 and p2 matches q2 and between p1 and p2 we don't have any\n            // points thus we should not have points between q1 and q2 as well.\n            function stableMarriageProblem(men, women, distances) {\n                const menPreferences = {};\n                for (const man of men) {\n                    menPreferences[man] = women.concat()\n                        .sort((w1, w2) => distances[man][w1] - distances[man][w2]);\n                }\n\n                // Start alghoritm with max N^2 complexity\n                const womenMaybe = {}; // id woman:id man,distance\n                const menBusy = {}; // id man:boolean\n                let prefIndex = 0;\n\n                // While there is at least one free man\n                while (Object.values(menBusy).length !== men.length) {\n                    // Every man makes offer to the best woman\n                    for (const man of men) {\n                        // The man have already found a woman\n                        if (menBusy[man]) {\n                            continue;\n                        }\n\n                        const woman = menPreferences[man][prefIndex];\n                        const distance = distances[man][woman];\n\n                        // A women chooses the best offer and says \"maybe\"\n                        if (woman in womenMaybe && womenMaybe[woman].distance > distance) {\n                            // A woman got better offer\n                            const prevChoice = womenMaybe[woman].value;\n                            delete womenMaybe[woman];\n                            delete menBusy[prevChoice];\n                        }\n\n                        if (!(woman in womenMaybe)) {\n                            womenMaybe[woman] = {\n                                value: man,\n                                distance,\n                            };\n\n                            menBusy[man] = true;\n                        }\n                    }\n\n                    prefIndex++;\n                }\n\n                const result = {};\n                for (const woman of Object.keys(womenMaybe)) {\n                    result[womenMaybe[woman].value] = {\n                        value: woman,\n                        distance: womenMaybe[woman].distance,\n                    };\n                }\n\n                return result;\n            }\n\n            function getMapping(source, target) {\n                function sumEdges(points) {\n                    let result = 0;\n                    for (let i = 1; i < points.length; i += 2) {\n                        const distance = Math.sqrt(Math.pow(points[i].x - points[i - 1].x, 2)\n                            + Math.pow(points[i].y - points[i - 1].y, 2));\n                        result += distance;\n                    }\n\n                    // Corner case when work with one point\n                    // Mapping in this case can't be wrong\n                    if (!result) {\n                        return Number.MAX_SAFE_INTEGER;\n                    }\n\n                    return result;\n                }\n\n                function computeDeviation(points, average) {\n                    let result = 0;\n                    for (let i = 1; i < points.length; i += 2) {\n                        const distance = Math.sqrt(Math.pow(points[i].x - points[i - 1].x, 2)\n                            + Math.pow(points[i].y - points[i - 1].y, 2));\n                        result += Math.pow(distance - average, 2);\n                    }\n\n                    return result;\n                }\n\n                const processedSource = [];\n                const processedTarget = [];\n\n                const distances = computeDistances(source, target);\n                const mapping = stableMarriageProblem(Array.from(source.keys()),\n                    Array.from(target.keys()), distances);\n\n                const average = (sumEdges(target)\n                    + sumEdges(source)) / (target.length + source.length);\n                const meanSquareDeviation = Math.sqrt((computeDeviation(source, average)\n                    + computeDeviation(target, average)) / (source.length + target.length));\n                const threshold = average + 3 * meanSquareDeviation; // 3 sigma rule\n                truncateByThreshold(mapping, threshold);\n                for (const key of Object.keys(mapping)) {\n                    mapping[key] = mapping[key].value;\n                }\n\n                // const receivingOrder = Object.keys(mapping).map(x => +x).sort((a,b) => a - b);\n                const receivingOrder = this.appendMapping(mapping, source, target);\n\n                for (const pointIdx of receivingOrder) {\n                    processedSource.push(source[pointIdx]);\n                    processedTarget.push(target[mapping[pointIdx]]);\n                }\n\n                return [processedSource, processedTarget];\n            }\n\n            let leftBox = findBox(leftPosition.points);\n            let rightBox = findBox(rightPosition.points);\n\n            // Sometimes (if shape has one point or shape is line),\n            // We can get box with zero area\n            // Next computation will be with NaN in this case\n            // We have to prevent it\n            const delta = 1;\n            if (leftBox.xmax - leftBox.xmin < delta || rightBox.ymax - rightBox.ymin < delta) {\n                leftBox = {\n                    xmin: 0,\n                    xmax: 1024, // TODO: Get actual image size\n                    ymin: 0,\n                    ymax: 768,\n                };\n\n                rightBox = leftBox;\n            }\n\n            const leftPoints = toPoints(normalize(leftPosition.points, leftBox));\n            const rightPoints = toPoints(normalize(rightPosition.points, rightBox));\n\n            let newLeftPoints = [];\n            let newRightPoints = [];\n            if (leftPoints.length > rightPoints.length) {\n                const [\n                    processedRight,\n                    processedLeft,\n                ] = getMapping.call(this, rightPoints, leftPoints);\n                newLeftPoints = processedLeft;\n                newRightPoints = processedRight;\n            } else {\n                const [\n                    processedLeft,\n                    processedRight,\n                ] = getMapping.call(this, leftPoints, rightPoints);\n                newLeftPoints = processedLeft;\n                newRightPoints = processedRight;\n            }\n\n            const absoluteLeftPoints = denormalize(toArray(newLeftPoints), leftBox);\n            const absoluteRightPoints = denormalize(toArray(newRightPoints), rightBox);\n\n            const interpolation = [];\n            for (let i = 0; i < absoluteLeftPoints.length; i++) {\n                interpolation.push(absoluteLeftPoints[i] + (\n                    absoluteRightPoints[i] - absoluteLeftPoints[i]) * offset);\n            }\n\n            return {\n                points: interpolation,\n                occluded: leftPosition.occluded,\n                outside: leftPosition.outside,\n                zOrder: leftPosition.zOrder,\n            };\n        }\n\n        // mapping is predicted order of points sourse_idx:target_idx\n        // some points from source and target can absent in mapping\n        // source, target - arrays of points. Target array size >= sourse array size\n        appendMapping(mapping, source, target) {\n            const targetMatched = Object.values(mapping).map(x => +x);\n            const sourceMatched = Object.keys(mapping).map(x => +x);\n            const orderForReceive = [];\n\n            function findNeighbors(point) {\n                let prev = point;\n                let next = point;\n\n                if (!targetMatched.length) {\n                    // Prevent infinity loop\n                    throw new ScriptingError('Interpolation mapping is empty');\n                }\n\n                while (!targetMatched.includes(prev)) {\n                    prev--;\n                    if (prev < 0) {\n                        prev = target.length - 1;\n                    }\n                }\n\n                while (!targetMatched.includes(next)) {\n                    next++;\n                    if (next >= target.length) {\n                        next = 0;\n                    }\n                }\n\n                return [prev, next];\n            }\n\n            function computeOffset(point, prev, next) {\n                const pathPoints = [];\n\n                while (prev !== next) {\n                    pathPoints.push(target[prev]);\n                    prev++;\n                    if (prev >= target.length) {\n                        prev = 0;\n                    }\n                }\n                pathPoints.push(target[next]);\n\n                let curveLength = 0;\n                let offset = 0;\n                let iCrossed = false;\n                for (let k = 1; k < pathPoints.length; k++) {\n                    const p1 = pathPoints[k];\n                    const p2 = pathPoints[k - 1];\n                    const distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n\n                    if (!iCrossed) {\n                        offset += distance;\n                    }\n                    curveLength += distance;\n                    if (target[point] === pathPoints[k]) {\n                        iCrossed = true;\n                    }\n                }\n\n                if (!curveLength) {\n                    return 0;\n                }\n\n                return offset / curveLength;\n            }\n\n            for (let i = 0; i < target.length; i++) {\n                const index = targetMatched.indexOf(i);\n                if (index === -1) {\n                    // We have to find a neighbours which have been mapped\n                    const [prev, next] = findNeighbors(i);\n\n                    // Now compute edge offset\n                    const offset = computeOffset(i, prev, next);\n\n                    // Get point between two neighbors points\n                    const prevPoint = target[prev];\n                    const nextPoint = target[next];\n                    const autoPoint = {\n                        x: prevPoint.x + (nextPoint.x - prevPoint.x) * offset,\n                        y: prevPoint.y + (nextPoint.y - prevPoint.y) * offset,\n                    };\n\n                    // Put it into matched\n                    source.push(autoPoint);\n                    mapping[source.length - 1] = i;\n                    orderForReceive.push(source.length - 1);\n                } else {\n                    orderForReceive.push(sourceMatched[index]);\n                }\n            }\n\n            return orderForReceive;\n        }\n    }\n\n    class PolygonTrack extends PolyTrack {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n            this.shapeType = ObjectShape.POLYGON;\n            for (const shape of Object.values(this.shapes)) {\n                checkNumberOfPoints(this.shapeType, shape.points);\n            }\n        }\n    }\n\n    class PolylineTrack extends PolyTrack {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n            this.shapeType = ObjectShape.POLYLINE;\n            for (const shape of Object.values(this.shapes)) {\n                checkNumberOfPoints(this.shapeType, shape.points);\n            }\n        }\n    }\n\n    class PointsTrack extends PolyTrack {\n        constructor(data, clientID, color, injection) {\n            super(data, clientID, color, injection);\n            this.shapeType = ObjectShape.POINTS;\n            for (const shape of Object.values(this.shapes)) {\n                checkNumberOfPoints(this.shapeType, shape.points);\n            }\n        }\n    }\n\n    RectangleTrack.distance = RectangleShape.distance;\n    PolygonTrack.distance = PolygonShape.distance;\n    PolylineTrack.distance = PolylineShape.distance;\n    PointsTrack.distance = PointsShape.distance;\n\n    module.exports = {\n        RectangleShape,\n        PolygonShape,\n        PolylineShape,\n        PointsShape,\n        RectangleTrack,\n        PolygonTrack,\n        PolylineTrack,\n        PointsTrack,\n        Track,\n        Shape,\n        Tag,\n        objectStateFactory,\n    };\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n(() => {\n    const serverProxy = require('./server-proxy');\n    const { Task } = require('./session');\n    const { ScriptingError } = ('./exceptions');\n\n    class AnnotationsSaver {\n        constructor(version, collection, session) {\n            this.sessionType = session instanceof Task ? 'task' : 'job';\n            this.id = session.id;\n            this.version = version;\n            this.collection = collection;\n            this.initialObjects = {};\n            this.hash = this._getHash();\n\n            // We need use data from export instead of initialData\n            // Otherwise we have differ keys order and JSON comparison code incorrect\n            const exported = this.collection.export();\n\n            this._resetState();\n            for (const shape of exported.shapes) {\n                this.initialObjects.shapes[shape.id] = shape;\n            }\n\n            for (const track of exported.tracks) {\n                this.initialObjects.tracks[track.id] = track;\n            }\n\n            for (const tag of exported.tags) {\n                this.initialObjects.tags[tag.id] = tag;\n            }\n        }\n\n        _resetState() {\n            this.initialObjects = {\n                shapes: {},\n                tracks: {},\n                tags: {},\n            };\n        }\n\n        _getHash() {\n            const exported = this.collection.export();\n            return JSON.stringify(exported);\n        }\n\n        async _request(data, action) {\n            const result = await serverProxy.annotations.updateAnnotations(\n                this.sessionType,\n                this.id,\n                data,\n                action,\n            );\n\n            return result;\n        }\n\n        async _put(data) {\n            const result = await this._request(data, 'put');\n            return result;\n        }\n\n        async _create(created) {\n            const result = await this._request(created, 'create');\n            return result;\n        }\n\n        async _update(updated) {\n            const result = await this._request(updated, 'update');\n            return result;\n        }\n\n        async _delete(deleted) {\n            const result = await this._request(deleted, 'delete');\n            return result;\n        }\n\n        _split(exported) {\n            const splitted = {\n                created: {\n                    shapes: [],\n                    tracks: [],\n                    tags: [],\n                },\n                updated: {\n                    shapes: [],\n                    tracks: [],\n                    tags: [],\n                },\n                deleted: {\n                    shapes: [],\n                    tracks: [],\n                    tags: [],\n                },\n            };\n\n            // Find created and updated objects\n            for (const type of Object.keys(exported)) {\n                for (const object of exported[type]) {\n                    if (object.id in this.initialObjects[type]) {\n                        const exportedHash = JSON.stringify(object);\n                        const initialHash = JSON.stringify(this.initialObjects[type][object.id]);\n                        if (exportedHash !== initialHash) {\n                            splitted.updated[type].push(object);\n                        }\n                    } else if (typeof (object.id) === 'undefined') {\n                        splitted.created[type].push(object);\n                    } else {\n                        throw new ScriptingError(\n                            `Id of object is defined \"${object.id}\"`\n                            + 'but it absents in initial state',\n                        );\n                    }\n                }\n            }\n\n            // Now find deleted objects\n            const indexes = {\n                shapes: exported.shapes.map((object) => +object.id),\n                tracks: exported.tracks.map((object) => +object.id),\n                tags: exported.tags.map((object) => +object.id),\n            };\n\n            for (const type of Object.keys(this.initialObjects)) {\n                for (const id of Object.keys(this.initialObjects[type])) {\n                    if (!indexes[type].includes(+id)) {\n                        const object = this.initialObjects[type][id];\n                        splitted.deleted[type].push(object);\n                    }\n                }\n            }\n\n\n            return splitted;\n        }\n\n        _updateCreatedObjects(saved, indexes) {\n            const savedLength = saved.tracks.length\n                + saved.shapes.length + saved.tags.length;\n\n            const indexesLength = indexes.tracks.length\n                + indexes.shapes.length + indexes.tags.length;\n\n            if (indexesLength !== savedLength) {\n                throw new ScriptingError(\n                    'Number of indexes is differed by number of saved objects'\n                        + `${indexesLength} vs ${savedLength}`,\n                );\n            }\n\n            // Updated IDs of created objects\n            for (const type of Object.keys(indexes)) {\n                for (let i = 0; i < indexes[type].length; i++) {\n                    const clientID = indexes[type][i];\n                    this.collection.objects[clientID].serverID = saved[type][i].id;\n                    if (type === 'tracks') {\n                        // We have to reset cache because of old value of serverID was saved there\n                        this.collection.objects[clientID].resetCache();\n                    }\n                }\n            }\n        }\n\n        _receiveIndexes(exported) {\n            // Receive client indexes before saving\n            const indexes = {\n                tracks: exported.tracks.map((track) => track.clientID),\n                shapes: exported.shapes.map((shape) => shape.clientID),\n                tags: exported.tags.map((tag) => tag.clientID),\n            };\n\n            // Remove them from the request body\n            exported.tracks.concat(exported.shapes).concat(exported.tags)\n                .map((value) => {\n                    delete value.clientID;\n                    return value;\n                });\n\n            return indexes;\n        }\n\n        async save(onUpdate) {\n            if (typeof onUpdate !== 'function') {\n                onUpdate = (message) => {\n                    console.log(message);\n                };\n            }\n\n            try {\n                const exported = this.collection.export();\n                const { flush } = this.collection;\n                if (flush) {\n                    onUpdate('New objects are being saved..');\n                    const indexes = this._receiveIndexes(exported);\n                    const savedData = await this._put({ ...exported, version: this.version });\n                    this.version = savedData.version;\n                    this.collection.flush = false;\n\n                    onUpdate('Saved objects are being updated in the client');\n                    this._updateCreatedObjects(savedData, indexes);\n\n                    onUpdate('Initial state is being updated');\n\n                    this._resetState();\n                    for (const type of Object.keys(this.initialObjects)) {\n                        for (const object of savedData[type]) {\n                            this.initialObjects[type][object.id] = object;\n                        }\n                    }\n                } else {\n                    const {\n                        created,\n                        updated,\n                        deleted,\n                    } = this._split(exported);\n\n                    onUpdate('New objects are being saved..');\n                    const indexes = this._receiveIndexes(created);\n                    const createdData = await this._create({ ...created, version: this.version });\n                    this.version = createdData.version;\n\n                    onUpdate('Saved objects are being updated in the client');\n                    this._updateCreatedObjects(createdData, indexes);\n\n                    onUpdate('Initial state is being updated');\n                    for (const type of Object.keys(this.initialObjects)) {\n                        for (const object of createdData[type]) {\n                            this.initialObjects[type][object.id] = object;\n                        }\n                    }\n\n                    onUpdate('Changed objects are being saved..');\n                    this._receiveIndexes(updated);\n                    const updatedData = await this._update({ ...updated, version: this.version });\n                    this.version = updatedData.version;\n\n                    onUpdate('Initial state is being updated');\n                    for (const type of Object.keys(this.initialObjects)) {\n                        for (const object of updatedData[type]) {\n                            this.initialObjects[type][object.id] = object;\n                        }\n                    }\n\n                    onUpdate('Changed objects are being saved..');\n                    this._receiveIndexes(deleted);\n                    const deletedData = await this._delete({ ...deleted, version: this.version });\n                    this._version = deletedData.version;\n\n                    onUpdate('Initial state is being updated');\n                    for (const type of Object.keys(this.initialObjects)) {\n                        for (const object of deletedData[type]) {\n                            delete this.initialObjects[type][object.id];\n                        }\n                    }\n                }\n\n                this.hash = this._getHash();\n                onUpdate('Saving is done');\n            } catch (error) {\n                onUpdate(`Can not save annotations: ${error.message}`);\n                throw error;\n            }\n        }\n\n        hasUnsavedChanges() {\n            return this._getHash() !== this.hash;\n        }\n    }\n\n    module.exports = AnnotationsSaver;\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n(() => {\n    const serverProxy = require('./server-proxy');\n    const Collection = require('./annotations-collection');\n    const AnnotationsSaver = require('./annotations-saver');\n    const { checkObjectType } = require('./common');\n    const { Task } = require('./session');\n    const {\n        Loader,\n        Dumper,\n    } = require('./annotation-format.js');\n    const {\n        ScriptingError,\n        DataError,\n        ArgumentError,\n    } = require('./exceptions');\n\n    const jobCache = new WeakMap();\n    const taskCache = new WeakMap();\n\n    function getCache(sessionType) {\n        if (sessionType === 'task') {\n            return taskCache;\n        }\n\n        if (sessionType === 'job') {\n            return jobCache;\n        }\n\n        throw new ScriptingError(\n            `Unknown session type was received ${sessionType}`,\n        );\n    }\n\n    async function getAnnotationsFromServer(session) {\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        const cache = getCache(sessionType);\n\n        if (!cache.has(session)) {\n            const rawAnnotations = await serverProxy.annotations\n                .getAnnotations(sessionType, session.id);\n\n            // Get meta information about frames\n            const startFrame = sessionType === 'job' ? session.startFrame : 0;\n            const stopFrame = sessionType === 'job' ? session.stopFrame : session.size - 1;\n            const frameMeta = {};\n            for (let i = startFrame; i <= stopFrame; i++) {\n                frameMeta[i] = await session.frames.get(i);\n            }\n\n            const collection = new Collection({\n                labels: session.labels || session.task.labels,\n                startFrame,\n                stopFrame,\n                frameMeta,\n            }).import(rawAnnotations);\n\n            const saver = new AnnotationsSaver(rawAnnotations.version, collection, session);\n\n            cache.set(session, {\n                collection,\n                saver,\n\n            });\n        }\n    }\n\n    async function getAnnotations(session, frame, filter) {\n        await getAnnotationsFromServer(session);\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        const cache = getCache(sessionType);\n        return cache.get(session).collection.get(frame, filter);\n    }\n\n    async function saveAnnotations(session, onUpdate) {\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        const cache = getCache(sessionType);\n\n        if (cache.has(session)) {\n            await cache.get(session).saver.save(onUpdate);\n        }\n\n        // If a collection wasn't uploaded, than it wasn't changed, finally we shouldn't save it\n    }\n\n    function mergeAnnotations(session, objectStates) {\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        const cache = getCache(sessionType);\n\n        if (cache.has(session)) {\n            return cache.get(session).collection.merge(objectStates);\n        }\n\n        throw new DataError(\n            'Collection has not been initialized yet. Call annotations.get() or annotations.clear(true) before',\n        );\n    }\n\n    function splitAnnotations(session, objectState, frame) {\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        const cache = getCache(sessionType);\n\n        if (cache.has(session)) {\n            return cache.get(session).collection.split(objectState, frame);\n        }\n\n        throw new DataError(\n            'Collection has not been initialized yet. Call annotations.get() or annotations.clear(true) before',\n        );\n    }\n\n    function groupAnnotations(session, objectStates, reset) {\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        const cache = getCache(sessionType);\n\n        if (cache.has(session)) {\n            return cache.get(session).collection.group(objectStates, reset);\n        }\n\n        throw new DataError(\n            'Collection has not been initialized yet. Call annotations.get() or annotations.clear(true) before',\n        );\n    }\n\n    function hasUnsavedChanges(session) {\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        const cache = getCache(sessionType);\n\n        if (cache.has(session)) {\n            return cache.get(session).saver.hasUnsavedChanges();\n        }\n\n        return false;\n    }\n\n    async function clearAnnotations(session, reload) {\n        checkObjectType('reload', reload, 'boolean', null);\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        const cache = getCache(sessionType);\n\n        if (cache.has(session)) {\n            cache.get(session).collection.clear();\n        }\n\n        if (reload) {\n            cache.delete(session);\n            await getAnnotationsFromServer(session);\n        }\n    }\n\n    function annotationsStatistics(session) {\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        const cache = getCache(sessionType);\n\n        if (cache.has(session)) {\n            return cache.get(session).collection.statistics();\n        }\n\n        throw new DataError(\n            'Collection has not been initialized yet. Call annotations.get() or annotations.clear(true) before',\n        );\n    }\n\n    function putAnnotations(session, objectStates) {\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        const cache = getCache(sessionType);\n\n        if (cache.has(session)) {\n            return cache.get(session).collection.put(objectStates);\n        }\n\n        throw new DataError(\n            'Collection has not been initialized yet. Call annotations.get() or annotations.clear(true) before',\n        );\n    }\n\n    function selectObject(session, objectStates, x, y) {\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        const cache = getCache(sessionType);\n\n        if (cache.has(session)) {\n            return cache.get(session).collection.select(objectStates, x, y);\n        }\n\n        throw new DataError(\n            'Collection has not been initialized yet. Call annotations.get() or annotations.clear(true) before',\n        );\n    }\n\n    async function uploadAnnotations(session, file, loader) {\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        if (!(loader instanceof Loader)) {\n            throw new ArgumentError(\n                'A loader must be instance of Loader class',\n            );\n        }\n        await serverProxy.annotations.uploadAnnotations(sessionType, session.id, file, loader.name);\n    }\n\n    async function dumpAnnotations(session, name, dumper) {\n        if (!(dumper instanceof Dumper)) {\n            throw new ArgumentError(\n                'A dumper must be instance of Dumper class',\n            );\n        }\n\n        let result = null;\n        const sessionType = session instanceof Task ? 'task' : 'job';\n        if (sessionType === 'job') {\n            result = await serverProxy.annotations\n                .dumpAnnotations(session.task.id, name, dumper.name);\n        } else {\n            result = await serverProxy.annotations\n                .dumpAnnotations(session.id, name, dumper.name);\n        }\n\n        return result;\n    }\n\n    module.exports = {\n        getAnnotations,\n        putAnnotations,\n        saveAnnotations,\n        hasUnsavedChanges,\n        mergeAnnotations,\n        splitAnnotations,\n        groupAnnotations,\n        clearAnnotations,\n        annotationsStatistics,\n        selectObject,\n        uploadAnnotations,\n        dumpAnnotations,\n    };\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* eslint prefer-arrow-callback: [ \"error\", { \"allowNamedFunctions\": true } ] */\n\n/* global\n    require:false\n*/\n\n\n(() => {\n    const PluginRegistry = require('./plugins');\n    const serverProxy = require('./server-proxy');\n    const {\n        isBoolean,\n        isInteger,\n        isEnum,\n        isString,\n        checkFilter,\n    } = require('./common');\n\n    const {\n        TaskStatus,\n        TaskMode,\n    } = require('./enums');\n\n    const User = require('./user');\n    const { AnnotationFormat } = require('./annotation-format.js');\n    const { ArgumentError } = require('./exceptions');\n    const { Task } = require('./session');\n\n    function implementAPI(cvat) {\n        cvat.plugins.list.implementation = PluginRegistry.list;\n        cvat.plugins.register.implementation = PluginRegistry.register.bind(cvat);\n\n        cvat.server.about.implementation = async () => {\n            const result = await serverProxy.server.about();\n            return result;\n        };\n\n        cvat.server.share.implementation = async (directory) => {\n            const result = await serverProxy.server.share(directory);\n            return result;\n        };\n\n        cvat.server.formats.implementation = async () => {\n            const result = await serverProxy.server.formats();\n            return result.map(el => new AnnotationFormat(el));\n        };\n\n        cvat.server.register.implementation = async (username, firstName, lastName,\n            email, password1, password2) => {\n            await serverProxy.server.register(username, firstName, lastName, email,\n                password1, password2);\n        };\n\n        cvat.server.login.implementation = async (username, password) => {\n            await serverProxy.server.login(username, password);\n        };\n\n        cvat.server.logout.implementation = async () => {\n            await serverProxy.server.logout();\n        };\n\n        cvat.server.authorized.implementation = async () => {\n            const result = await serverProxy.server.authorized();\n            return result;\n        };\n\n        cvat.users.get.implementation = async (filter) => {\n            checkFilter(filter, {\n                self: isBoolean,\n            });\n\n            let users = null;\n            if ('self' in filter && filter.self) {\n                users = await serverProxy.users.getSelf();\n                users = [users];\n            } else {\n                users = await serverProxy.users.getUsers();\n            }\n\n            users = users.map(user => new User(user));\n            return users;\n        };\n\n        cvat.jobs.get.implementation = async (filter) => {\n            checkFilter(filter, {\n                taskID: isInteger,\n                jobID: isInteger,\n            });\n\n            if (('taskID' in filter) && ('jobID' in filter)) {\n                throw new ArgumentError(\n                    'Only one of fields \"taskID\" and \"jobID\" allowed simultaneously',\n                );\n            }\n\n            if (!Object.keys(filter).length) {\n                throw new ArgumentError(\n                    'Job filter must not be empty',\n                );\n            }\n\n            let tasks = null;\n            if ('taskID' in filter) {\n                tasks = await serverProxy.tasks.getTasks(`id=${filter.taskID}`);\n            } else {\n                const job = await serverProxy.jobs.getJob(filter.jobID);\n                if (typeof (job.task_id) !== 'undefined') {\n                    tasks = await serverProxy.tasks.getTasks(`id=${job.task_id}`);\n                }\n            }\n\n            // If task was found by its id, then create task instance and get Job instance from it\n            if (tasks !== null && tasks.length) {\n                const task = new Task(tasks[0]);\n                return filter.jobID ? task.jobs.filter(job => job.id === filter.jobID) : task.jobs;\n            }\n\n            return [];\n        };\n\n        cvat.tasks.get.implementation = async (filter) => {\n            checkFilter(filter, {\n                page: isInteger,\n                name: isString,\n                id: isInteger,\n                owner: isString,\n                assignee: isString,\n                search: isString,\n                status: isEnum.bind(TaskStatus),\n                mode: isEnum.bind(TaskMode),\n            });\n\n            if ('search' in filter && Object.keys(filter).length > 1) {\n                if (!('page' in filter && Object.keys(filter).length === 2)) {\n                    throw new ArgumentError(\n                        'Do not use the filter field \"search\" with others',\n                    );\n                }\n            }\n\n            if ('id' in filter && Object.keys(filter).length > 1) {\n                if (!('page' in filter && Object.keys(filter).length === 2)) {\n                    throw new ArgumentError(\n                        'Do not use the filter field \"id\" with others',\n                    );\n                }\n            }\n\n            const searchParams = new URLSearchParams();\n            for (const field of ['name', 'owner', 'assignee', 'search', 'status', 'mode', 'id', 'page']) {\n                if (Object.prototype.hasOwnProperty.call(filter, field)) {\n                    searchParams.set(field, filter[field]);\n                }\n            }\n\n            const tasksData = await serverProxy.tasks.getTasks(searchParams.toString());\n            const tasks = tasksData.map(task => new Task(task));\n            tasks.count = tasksData.count;\n\n            return tasks;\n        };\n\n        return cvat;\n    }\n\n    module.exports = implementAPI;\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n/**\n    * External API which should be used by for development\n    * @module API\n*/\n\nfunction build() {\n    const PluginRegistry = require('./plugins');\n    const User = require('./user');\n    const ObjectState = require('./object-state');\n    const Statistics = require('./statistics');\n    const { Job, Task } = require('./session');\n    const { Attribute, Label } = require('./labels');\n\n    const {\n        ShareFileType,\n        TaskStatus,\n        TaskMode,\n        AttributeType,\n        ObjectType,\n        ObjectShape,\n        VisibleState,\n        LogType,\n    } = require('./enums');\n\n    const {\n        Exception,\n        ArgumentError,\n        DataError,\n        ScriptingError,\n        PluginError,\n        ServerError,\n    } = require('./exceptions');\n\n    const pjson = require('../package.json');\n    const config = require('./config');\n\n    /**\n        * API entrypoint\n        * @namespace cvat\n        * @memberof module:API\n    */\n    const cvat = {\n        /**\n            * Namespace is used for an interaction with a server\n            * @namespace server\n            * @package\n            * @memberof module:API.cvat\n        */\n        server: {\n            /**\n                * @typedef {Object} ServerInfo\n                * @property {string} name A name of the tool\n                * @property {string} description A description of the tool\n                * @property {string} version A version of the tool\n                * @global\n            */\n\n            /**\n                * Method returns some information about the annotation tool\n                * @method about\n                * @async\n                * @memberof module:API.cvat.server\n                * @return {ServerInfo}\n                * @throws {module:API.cvat.exceptions.ServerError}\n                * @throws {module:API.cvat.exceptions.PluginError}\n            */\n            async about() {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.server.about);\n                return result;\n            },\n            /**\n                * @typedef {Object} FileInfo\n                * @property {string} name A name of a file\n                * @property {module:API.cvat.enums.ShareFileType} type\n                * A type of a file\n                * @global\n            */\n\n            /**\n                * Method returns a list of files in a specified directory on a share\n                * @method share\n                * @async\n                * @memberof module:API.cvat.server\n                * @param {string} [directory=/] - Share directory path\n                * @returns {FileInfo[]}\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n            */\n            async share(directory = '/') {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.server.share, directory);\n                return result;\n            },\n            /**\n                * Method returns available annotation formats\n                * @method formats\n                * @async\n                * @memberof module:API.cvat.server\n                * @returns {module:API.cvat.classes.AnnotationFormat[]}\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n            */\n            async formats() {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.server.formats);\n                return result;\n            },\n            /**\n                * Method allows to register on a server\n                * @method register\n                * @async\n                * @memberof module:API.cvat.server\n                * @param {string} username An username for the new account\n                * @param {string} firstName A first name for the new account\n                * @param {string} lastName A last name for the new account\n                * @param {string} email A email address for the new account\n                * @param {string} password1 A password for the new account\n                * @param {string} password2 The confirmation password for the new account\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n            */\n            async register(username, firstName, lastName, email, password1, password2) {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.server.register, username, firstName,\n                        lastName, email, password1, password2);\n                return result;\n            },\n            /**\n                * Method allows to login on a server\n                * @method login\n                * @async\n                * @memberof module:API.cvat.server\n                * @param {string} username An username of an account\n                * @param {string} password A password of an account\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n            */\n            async login(username, password) {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.server.login, username, password);\n                return result;\n            },\n            /**\n                * Method allows to logout from the server\n                * @method logout\n                * @async\n                * @memberof module:API.cvat.server\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n            */\n            async logout() {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.server.logout);\n                return result;\n            },\n            /**\n                * Method allows to know whether you are authorized on the server\n                * @method authorized\n                * @async\n                * @memberof module:API.cvat.server\n                * @returns {boolean}\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n            */\n            async authorized() {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.server.authorized);\n                return result;\n            },\n        },\n        /**\n            * Namespace is used for getting tasks\n            * @namespace tasks\n            * @memberof module:API.cvat\n        */\n        tasks: {\n            /**\n                * @typedef {Object} TaskFilter\n                * @property {string} name Check if name contains this value\n                * @property {module:API.cvat.enums.TaskStatus} status\n                * Check if status contains this value\n                * @property {module:API.cvat.enums.TaskMode} mode\n                * Check if mode contains this value\n                * @property {integer} id Check if id equals this value\n                * @property {integer} page Get specific page\n                * (default REST API returns 20 tasks per request.\n                * In order to get more, it is need to specify next page)\n                * @property {string} owner Check if owner user contains this value\n                * @property {string} assignee Check if assigneed contains this value\n                * @property {string} search Combined search of contains among all fields\n                * @global\n            */\n\n            /**\n                * Method returns list of tasks corresponding to a filter\n                * @method get\n                * @async\n                * @memberof module:API.cvat.tasks\n                * @param {TaskFilter} [filter={}] task filter\n                * @returns {module:API.cvat.classes.Task[]}\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n            */\n            async get(filter = {}) {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.tasks.get, filter);\n                return result;\n            },\n        },\n        /**\n            * Namespace is used for getting jobs\n            * @namespace jobs\n            * @memberof module:API.cvat\n        */\n        jobs: {\n            /**\n                * @typedef {Object} JobFilter\n                * Only one of fields is allowed simultaneously\n                * @property {integer} taskID filter all jobs of specific task\n                * @property {integer} jobID filter job with a specific id\n                * @global\n            */\n\n            /**\n                * Method returns list of jobs corresponding to a filter\n                * @method get\n                * @async\n                * @memberof module:API.cvat.jobs\n                * @param {JobFilter} filter job filter\n                * @returns {module:API.cvat.classes.Job[]}\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n            */\n            async get(filter = {}) {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.jobs.get, filter);\n                return result;\n            },\n        },\n        /**\n            * Namespace is used for getting users\n            * @namespace users\n            * @memberof module:API.cvat\n        */\n        users: {\n            /**\n                * @typedef {Object} UserFilter\n                * @property {boolean} self get only self\n                * @global\n            */\n\n            /**\n                * Method returns list of users corresponding to a filter\n                * @method get\n                * @async\n                * @memberof module:API.cvat.users\n                * @param {UserFilter} [filter={}] user filter\n                * @returns {module:API.cvat.classes.User[]}\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n            */\n            async get(filter = {}) {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.users.get, filter);\n                return result;\n            },\n        },\n        /**\n            * Namespace is used for plugin management\n            * @namespace plugins\n            * @memberof module:API.cvat\n        */\n        plugins: {\n            /**\n                * @typedef {Object} Plugin\n                * A plugin is a Javascript object. It must have properties are listed below. <br>\n                * It also mustn't have property 'functions' which is used internally. <br>\n                * You can expand any API method including class methods. <br>\n                * In order to expand class method just use a class name\n                * in a cvat space (example is listed below).\n                *\n                * @property {string} name A name of a plugin\n                * @property {string} description A description of a plugin\n                * Example plugin implementation listed below:\n                * @example\n                * plugin = {\n                *   name: 'Example Plugin',\n                *   description: 'This example plugin demonstrates how plugin system in CVAT works',\n                *   cvat: {\n                *     server: {\n                *       about: {\n                *         // Plugin adds some actions after executing the cvat.server.about()\n                *         // For example it adds a field with installed plugins to a result\n                *         // An argument \"self\" is a plugin itself\n                *         // An argument \"result\" is a return value of cvat.server.about()\n                *         // All next arguments are arguments of a wrapped function\n                *         // (in this case the wrapped function doesn't have any arguments)\n                *         async leave(self, result) {\n                *           result.plugins = await self.internal.getPlugins();\n                *           // Note that a method leave must return \"result\" (changed or not)\n                *           // Otherwise API won't work as expected\n                *           return result;\n                *         },\n                *       },\n                *     },\n                *     // In this example plugin also wraps a class method\n                *     classes: {\n                *       Job: {\n                *         prototype: {\n                *           annotations: {\n                *             put: {\n                *               // The first argument \"self\" is a plugin, like in a case above\n                *               // The second argument is an argument of the\n                *               // Job.annotations.put()\n                *               // It contains an array of objects to put\n                *               // In this sample we round objects coordinates and save them\n                *               enter(self, objects) {\n                *                 for (const obj of objects) {\n                *                   if (obj.type != 'tag') {\n                *                     const points = obj.position.map((point) => {\n                *                       const roundPoint = {\n                *                         x: Math.round(point.x),\n                *                         y: Math.round(point.y),\n                *                       };\n                *                       return roundPoint;\n                *                     });\n                *                   }\n                *                 }\n                *               },\n                *             },\n                *           },\n                *         },\n                *       },\n                *     },\n                *   },\n                *   // In general you can add any others members to your plugin\n                *   // Members below are only examples\n                *   internal: {\n                *     async getPlugins() {\n                *       // Collect information about installed plugins\n                *       const plugins = await cvat.plugins.list();\n                *       return plugins.map((el) => {\n                *         return {\n                *           name: el.name,\n                *           description: el.description,\n                *         };\n                *       });\n                *     },\n                *   },\n                * };\n                * @global\n            */\n\n            /**\n                * Method returns list of installed plugins\n                * @method list\n                * @async\n                * @memberof module:API.cvat.plugins\n                * @returns {Plugin[]}\n                * @throws {module:API.cvat.exceptions.PluginError}\n            */\n            async list() {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.plugins.list);\n                return result;\n            },\n            /**\n                * Install plugin to CVAT\n                * @method register\n                * @async\n                * @memberof module:API.cvat.plugins\n                * @param {Plugin} [plugin] plugin for registration\n                * @throws {module:API.cvat.exceptions.PluginError}\n            */\n            async register(plugin) {\n                const result = await PluginRegistry\n                    .apiWrapper(cvat.plugins.register, plugin);\n                return result;\n            },\n        },\n        /**\n            * Namespace contains some changeable configurations\n            * @namespace config\n            * @memberof module:API.cvat\n        */\n        config: {\n            /**\n                * @memberof module:API.cvat.config\n                * @property {string} backendAPI host with a backend api\n                * @memberof module:API.cvat.config\n                * @property {string} proxy Axios proxy settings.\n                * For more details please read <a href=\"https://github.com/axios/axios\"> here </a>\n                * @memberof module:API.cvat.config\n                * @property {integer} taskID this value is displayed in a logs if available\n                * @memberof module:API.cvat.config\n                * @property {integer} jobID this value is displayed in a logs if available\n                * @memberof module:API.cvat.config\n                * @property {integer} clientID read only auto-generated\n                * value which is displayed in a logs\n                * @memberof module:API.cvat.config\n            */\n            get backendAPI() {\n                return config.backendAPI;\n            },\n            set backendAPI(value) {\n                config.backendAPI = value;\n            },\n            get proxy() {\n                return config.proxy;\n            },\n            set proxy(value) {\n                config.proxy = value;\n            },\n            get taskID() {\n                return config.taskID;\n            },\n            set taskID(value) {\n                config.taskID = value;\n            },\n            get jobID() {\n                return config.jobID;\n            },\n            set jobID(value) {\n                config.jobID = value;\n            },\n            get clientID() {\n                return config.clientID;\n            },\n        },\n        /**\n            * Namespace contains some library information e.g. api version\n            * @namespace client\n            * @memberof module:API.cvat\n        */\n        client: {\n            /**\n                * @property {string} version Client version.\n                * Format: <b>{major}.{minor}.{patch}</b>\n                * <li style=\"margin-left: 10px;\"> A major number is changed after an API becomes\n                * incompatible with a previous version\n                * <li style=\"margin-left: 10px;\"> A minor number is changed after an API expands\n                * <li style=\"margin-left: 10px;\"> A patch number is changed after an each build\n                * @memberof module:API.cvat.client\n                * @readonly\n            */\n            version: `${pjson.version}`,\n        },\n        /**\n            * Namespace is used for access to enums\n            * @namespace enums\n            * @memberof module:API.cvat\n        */\n        enums: {\n            ShareFileType,\n            TaskStatus,\n            TaskMode,\n            AttributeType,\n            ObjectType,\n            ObjectShape,\n            VisibleState,\n            LogType,\n        },\n        /**\n            * Namespace is used for access to exceptions\n            * @namespace exceptions\n            * @memberof module:API.cvat\n        */\n        exceptions: {\n            Exception,\n            ArgumentError,\n            DataError,\n            ScriptingError,\n            PluginError,\n            ServerError,\n        },\n        /**\n            * Namespace is used for access to classes\n            * @namespace classes\n            * @memberof module:API.cvat\n        */\n        classes: {\n            Task,\n            User,\n            Job,\n            Attribute,\n            Label,\n            Statistics,\n            ObjectState,\n        },\n    };\n\n    cvat.server = Object.freeze(cvat.server);\n    cvat.tasks = Object.freeze(cvat.tasks);\n    cvat.jobs = Object.freeze(cvat.jobs);\n    cvat.users = Object.freeze(cvat.users);\n    cvat.plugins = Object.freeze(cvat.plugins);\n    cvat.client = Object.freeze(cvat.client);\n    cvat.enums = Object.freeze(cvat.enums);\n\n    const implementAPI = require('./api-implementation');\n\n    Math.clamp = function (value, min, max) {\n        return Math.min(Math.max(value, min), max);\n    };\n\n    const implemented = Object.freeze(implementAPI(cvat));\n    return implemented;\n}\n\nmodule.exports = build();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n(() => {\n    const { ArgumentError } = require('./exceptions');\n\n    function isBoolean(value) {\n        return typeof (value) === 'boolean';\n    }\n\n    function isInteger(value) {\n        return typeof (value) === 'number' && Number.isInteger(value);\n    }\n\n    // Called with specific Enum context\n    function isEnum(value) {\n        for (const key in this) {\n            if (Object.prototype.hasOwnProperty.call(this, key)) {\n                if (this[key] === value) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    function isString(value) {\n        return typeof (value) === 'string';\n    }\n\n    function checkFilter(filter, fields) {\n        for (const prop in filter) {\n            if (Object.prototype.hasOwnProperty.call(filter, prop)) {\n                if (!(prop in fields)) {\n                    throw new ArgumentError(\n                        `Unsupported filter property has been recieved: \"${prop}\"`,\n                    );\n                } else if (!fields[prop](filter[prop])) {\n                    throw new ArgumentError(\n                        `Received filter property \"${prop}\" is not satisfied for checker`,\n                    );\n                }\n            }\n        }\n    }\n\n    function checkObjectType(name, value, type, instance) {\n        if (type) {\n            if (typeof (value) !== type) {\n                // specific case for integers which aren't native type in JS\n                if (type === 'integer' && Number.isInteger(value)) {\n                    return;\n                }\n\n                throw new ArgumentError(\n                    `\"${name}\" is expected to be \"${type}\", but \"${typeof (value)}\" has been got.`,\n                );\n            }\n        } else if (instance) {\n            if (!(value instanceof instance)) {\n                if (value !== undefined) {\n                    throw new ArgumentError(\n                        `\"${name}\" is expected to be ${instance.name}, but `\n                            + `\"${value.constructor.name}\" has been got`,\n                    );\n                }\n\n                throw new ArgumentError(\n                    `\"${name}\" is expected to be ${instance.name}, but \"undefined\" has been got.`,\n                );\n            }\n        }\n    }\n\n    module.exports = {\n        isBoolean,\n        isInteger,\n        isEnum,\n        isString,\n        checkFilter,\n        checkObjectType,\n    };\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\nmodule.exports = {\n    backendAPI: 'http://localhost:7000/api/v1',\n    proxy: false,\n    taskID: undefined,\n    jobID: undefined,\n    clientID: +Date.now().toString().substr(-6),\n};\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n(() => {\n    /**\n        * Share files types\n        * @enum {string}\n        * @name ShareFileType\n        * @memberof module:API.cvat.enums\n        * @property {string} DIR 'DIR'\n        * @property {string} REG 'REG'\n        * @readonly\n    */\n    const ShareFileType = Object.freeze({\n        DIR: 'DIR',\n        REG: 'REG',\n    });\n\n    /**\n        * Task statuses\n        * @enum {string}\n        * @name TaskStatus\n        * @memberof module:API.cvat.enums\n        * @property {string} ANNOTATION 'annotation'\n        * @property {string} VALIDATION 'validation'\n        * @property {string} COMPLETED 'completed'\n        * @readonly\n    */\n    const TaskStatus = Object.freeze({\n        ANNOTATION: 'annotation',\n        VALIDATION: 'validation',\n        COMPLETED: 'completed',\n    });\n\n    /**\n        * Task modes\n        * @enum {string}\n        * @name TaskMode\n        * @memberof module:API.cvat.enums\n        * @property {string} ANNOTATION 'annotation'\n        * @property {string} INTERPOLATION 'interpolation'\n        * @readonly\n    */\n    const TaskMode = Object.freeze({\n        ANNOTATION: 'annotation',\n        INTERPOLATION: 'interpolation',\n    });\n\n    /**\n        * Attribute types\n        * @enum {string}\n        * @name AttributeType\n        * @memberof module:API.cvat.enums\n        * @property {string} CHECKBOX 'checkbox'\n        * @property {string} SELECT 'select'\n        * @property {string} RADIO 'radio'\n        * @property {string} NUMBER 'number'\n        * @property {string} TEXT 'text'\n        * @readonly\n    */\n    const AttributeType = Object.freeze({\n        CHECKBOX: 'checkbox',\n        RADIO: 'radio',\n        SELECT: 'select',\n        NUMBER: 'number',\n        TEXT: 'text',\n    });\n\n    /**\n        * Object types\n        * @enum {string}\n        * @name ObjectType\n        * @memberof module:API.cvat.enums\n        * @property {string} TAG 'tag'\n        * @property {string} SHAPE 'shape'\n        * @property {string} TRACK 'track'\n        * @readonly\n    */\n    const ObjectType = Object.freeze({\n        TAG: 'tag',\n        SHAPE: 'shape',\n        TRACK: 'track',\n    });\n\n    /**\n        * Object shapes\n        * @enum {string}\n        * @name ObjectShape\n        * @memberof module:API.cvat.enums\n        * @property {string} RECTANGLE 'rectangle'\n        * @property {string} POLYGON 'polygon'\n        * @property {string} POLYLINE 'polyline'\n        * @property {string} POINTS 'points'\n        * @readonly\n    */\n    const ObjectShape = Object.freeze({\n        RECTANGLE: 'rectangle',\n        POLYGON: 'polygon',\n        POLYLINE: 'polyline',\n        POINTS: 'points',\n    });\n\n    /**\n        * Object visibility states\n        * @enum {string}\n        * @name ObjectShape\n        * @memberof module:API.cvat.enums\n        * @property {string} ALL 'all'\n        * @property {string} SHAPE 'shape'\n        * @property {string} NONE 'none'\n        * @readonly\n    */\n    const VisibleState = Object.freeze({\n        ALL: 'all',\n        SHAPE: 'shape',\n        NONE: 'none',\n    });\n\n    /**\n        * Event types\n        * @enum {number}\n        * @name LogType\n        * @memberof module:API.cvat.enums\n        * @property {number} pasteObject 0\n        * @property {number} changeAttribute 1\n        * @property {number} dragObject 2\n        * @property {number} deleteObject 3\n        * @property {number} pressShortcut 4\n        * @property {number} resizeObject 5\n        * @property {number} sendLogs 6\n        * @property {number} saveJob 7\n        * @property {number} jumpFrame 8\n        * @property {number} drawObject 9\n        * @property {number} changeLabel 10\n        * @property {number} sendTaskInfo 11\n        * @property {number} loadJob 12\n        * @property {number} moveImage 13\n        * @property {number} zoomImage 14\n        * @property {number} lockObject 15\n        * @property {number} mergeObjects 16\n        * @property {number} copyObject 17\n        * @property {number} propagateObject 18\n        * @property {number} undoAction 19\n        * @property {number} redoAction 20\n        * @property {number} sendUserActivity 21\n        * @property {number} sendException 22\n        * @property {number} changeFrame 23\n        * @property {number} debugInfo 24\n        * @property {number} fitImage 25\n        * @property {number} rotateImage 26\n        * @readonly\n    */\n    const LogType = {\n        pasteObject: 0,\n        changeAttribute: 1,\n        dragObject: 2,\n        deleteObject: 3,\n        pressShortcut: 4,\n        resizeObject: 5,\n        sendLogs: 6,\n        saveJob: 7,\n        jumpFrame: 8,\n        drawObject: 9,\n        changeLabel: 10,\n        sendTaskInfo: 11,\n        loadJob: 12,\n        moveImage: 13,\n        zoomImage: 14,\n        lockObject: 15,\n        mergeObjects: 16,\n        copyObject: 17,\n        propagateObject: 18,\n        undoAction: 19,\n        redoAction: 20,\n        sendUserActivity: 21,\n        sendException: 22,\n        changeFrame: 23,\n        debugInfo: 24,\n        fitImage: 25,\n        rotateImage: 26,\n    };\n\n    module.exports = {\n        ShareFileType,\n        TaskStatus,\n        TaskMode,\n        AttributeType,\n        ObjectType,\n        ObjectShape,\n        VisibleState,\n        LogType,\n    };\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n(() => {\n    const Platform = require('platform');\n    const ErrorStackParser = require('error-stack-parser');\n    const config = require('./config');\n\n    /**\n        * Base exception class\n        * @memberof module:API.cvat.exceptions\n        * @extends Error\n        * @ignore\n    */\n    class Exception extends Error {\n        /**\n            * @param {string} message - Exception message\n        */\n        constructor(message) {\n            super(message);\n\n            const time = new Date().toISOString();\n            const system = Platform.os.toString();\n            const client = `${Platform.name} ${Platform.version}`;\n            const info = ErrorStackParser.parse(this)[0];\n            const filename = `${info.fileName}`;\n            const line = info.lineNumber;\n            const column = info.columnNumber;\n            const {\n                jobID,\n                taskID,\n                clientID,\n            } = config;\n\n            const projID = undefined; // wasn't implemented\n\n            Object.defineProperties(this, Object.freeze({\n                system: {\n                    /**\n                        * @name system\n                        * @type {string}\n                        * @memberof module:API.cvat.exceptions.Exception\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => system,\n                },\n                client: {\n                    /**\n                        * @name client\n                        * @type {string}\n                        * @memberof module:API.cvat.exceptions.Exception\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => client,\n                },\n                time: {\n                    /**\n                        * @name time\n                        * @type {string}\n                        * @memberof module:API.cvat.exceptions.Exception\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => time,\n                },\n                jobID: {\n                    /**\n                        * @name jobID\n                        * @type {integer}\n                        * @memberof module:API.cvat.exceptions.Exception\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => jobID,\n                },\n                taskID: {\n                    /**\n                        * @name taskID\n                        * @type {integer}\n                        * @memberof module:API.cvat.exceptions.Exception\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => taskID,\n                },\n                projID: {\n                    /**\n                        * @name projID\n                        * @type {integer}\n                        * @memberof module:API.cvat.exceptions.Exception\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => projID,\n                },\n                clientID: {\n                    /**\n                        * @name clientID\n                        * @type {integer}\n                        * @memberof module:API.cvat.exceptions.Exception\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => clientID,\n                },\n                filename: {\n                    /**\n                        * @name filename\n                        * @type {string}\n                        * @memberof module:API.cvat.exceptions.Exception\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => filename,\n                },\n                line: {\n                    /**\n                        * @name line\n                        * @type {integer}\n                        * @memberof module:API.cvat.exceptions.Exception\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => line,\n                },\n                column: {\n                    /**\n                        * @name column\n                        * @type {integer}\n                        * @memberof module:API.cvat.exceptions.Exception\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => column,\n                },\n            }));\n        }\n\n        /**\n            * Save an exception on a server\n            * @name save\n            * @method\n            * @memberof Exception\n            * @instance\n            * @async\n        */\n        async save() {\n            const exceptionObject = {\n                system: this.system,\n                client: this.client,\n                time: this.time,\n                job_id: this.jobID,\n                task_id: this.taskID,\n                proj_id: this.projID,\n                client_id: this.clientID,\n                message: this.message,\n                filename: this.filename,\n                line: this.line,\n                column: this.column,\n                stack: this.stack,\n            };\n\n            try {\n                const serverProxy = require('./server-proxy');\n                await serverProxy.server.exception(exceptionObject);\n            } catch (exception) {\n                // add event\n            }\n        }\n    }\n\n    /**\n        * Exceptions are referred with arguments data\n        * @memberof module:API.cvat.exceptions\n        * @extends module:API.cvat.exceptions.Exception\n    */\n    class ArgumentError extends Exception {\n        /**\n            * @param {string} message - Exception message\n        */\n        constructor(message) {\n            super(message);\n        }\n    }\n\n    /**\n        * Unexpected problems with data which are not connected with a user input\n        * @memberof module:API.cvat.exceptions\n        * @extends module:API.cvat.exceptions.Exception\n    */\n    class DataError extends Exception {\n    /**\n        * @param {string} message - Exception message\n    */\n        constructor(message) {\n            super(message);\n        }\n    }\n\n    /**\n        * Unexpected situations in code\n        * @memberof module:API.cvat.exceptions\n        * @extends module:API.cvat.exceptions.Exception\n        */\n    class ScriptingError extends Exception {\n        /**\n            * @param {string} message - Exception message\n        */\n        constructor(message) {\n            super(message);\n        }\n    }\n\n    /**\n        * Plugin-referred exceptions\n        * @memberof module:API.cvat.exceptions\n        * @extends module:API.cvat.exceptions.Exception\n    */\n    class PluginError extends Exception {\n        /**\n            * @param {string} message - Exception message\n        */\n        constructor(message) {\n            super(message);\n        }\n    }\n\n    /**\n        * Exceptions in interaction with a server\n        * @memberof module:API.cvat.exceptions\n        * @extends module:API.cvat.exceptions.Exception\n    */\n    class ServerError extends Exception {\n        /**\n            * @param {string} message - Exception message\n            * @param {(string|integer)} code - Response code\n        */\n        constructor(message, code) {\n            super(message);\n\n            Object.defineProperties(this, Object.freeze({\n                /**\n                    * @name code\n                    * @type {(string|integer)}\n                    * @memberof module:API.cvat.exceptions.ServerError\n                    * @readonly\n                    * @instance\n                */\n                code: {\n                    get: () => code,\n                },\n            }));\n        }\n    }\n\n    module.exports = {\n        Exception,\n        ArgumentError,\n        DataError,\n        ScriptingError,\n        PluginError,\n        ServerError,\n    };\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n    global:false\n*/\n\n(() => {\n    const cvatData = require('../../cvat-data');\n    const PluginRegistry = require('./plugins');\n    const serverProxy = require('./server-proxy');\n    const {\n        Exception,\n        ArgumentError,\n    } = require('./exceptions');\n\n    // This is the frames storage\n    const frameDataCache = {};\n    const frameCache = {};\n\n    /**\n        * Class provides meta information about specific frame and frame itself\n        * @memberof module:API.cvat.classes\n        * @hideconstructor\n    */\n    class FrameData {\n        constructor(width, height, tid, number) {\n            Object.defineProperties(this, Object.freeze({\n                /**\n                    * @name width\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.FrameData\n                    * @readonly\n                    * @instance\n                */\n                width: {\n                    value: width,\n                    writable: false,\n                },\n                /**\n                    * @name height\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.FrameData\n                    * @readonly\n                    * @instance\n                */\n                height: {\n                    value: height,\n                    writable: false,\n                },\n                tid: {\n                    value: tid,\n                    writable: false,\n                },\n                number: {\n                    value: number,\n                    writable: false,\n                },\n            }));\n        }\n\n        /**\n            * Method returns URL encoded image which can be placed in the img tag\n            * @method data\n            * @returns {string}\n            * @memberof module:API.cvat.classes.FrameData\n            * @instance\n            * @async\n            * @param {function} [onServerRequest = () => {}]\n            * callback which will be called if data absences local\n            * @throws {module:API.cvat.exception.ServerError}\n            * @throws {module:API.cvat.exception.PluginError}\n        */\n        async data(onServerRequest = () => {}) {\n            const result = await PluginRegistry\n                .apiWrapper.call(this, FrameData.prototype.data, onServerRequest);\n            return result;\n        }\n    }\n\n    FrameData.prototype.data.implementation = async function (onServerRequest) {\n        async function getFrameData(resolve, reject) {\n            function onDecode(provider, frameNumber) {\n                if (frameNumber === this.number) {\n                    resolve(provider.frame(frameNumber));\n                }\n            }\n\n            try {\n                const { provider } = frameDataCache[this.tid];\n                const frame = provider.frame(this.number);\n                if (frame === null || frame === 'loading') {\n                    onServerRequest();\n                    const { chunkSize } = frameDataCache[this.tid];\n                    const start = parseInt(this.number / chunkSize, 10) * chunkSize;\n                    const stop = (parseInt(this.number / chunkSize, 10) + 1) * chunkSize - 1;\n                    const chunkNumber = Math.floor(this.number / chunkSize);\n                    let chunk = null;\n                    if (frame === null) {\n                        chunk = await serverProxy.frames.getData(this.tid, chunkNumber);\n                    }\n                    // if status is loading, a chunk has already been loaded\n                    // and it is being decoded now\n\n                    try {\n                        provider.startDecode(chunk, start, stop, onDecode.bind(this, provider));\n                    } catch (error) {\n                        if (error.donePromise) {\n                            try {\n                                await error.donePromise;\n                                provider.startDecode(chunk, start,\n                                    stop, onDecode.bind(this, provider));\n                            } catch (_) {\n                                reject(this.number);\n                            }\n                        }\n                    }\n                } else {\n                    resolve(frame);\n                }\n            } catch (exception) {\n                if (exception instanceof Exception) {\n                    reject(exception);\n                } else {\n                    reject(new Exception(exception.message));\n                }\n            }\n        }\n\n        return new Promise(getFrameData.bind(this));\n    };\n\n    async function getFrame(taskID, chunkSize, mode, frame) {\n        if (!(taskID in frameDataCache)) {\n            const blockType = mode === 'interpolation' ? cvatData.BlockType.TSVIDEO\n                : cvatData.BlockType.ARCHIVE;\n\n            const value = {\n                meta: await serverProxy.frames.getMeta(taskID),\n                chunkSize,\n                provider: new cvatData.FrameProvider(3, blockType),\n            };\n\n            frameCache[taskID] = {};\n            frameDataCache[taskID] = value;\n        }\n\n        if (!(frame in frameDataCache[taskID])) {\n            let size = null;\n            if (mode === 'interpolation') {\n                [size] = frameDataCache[taskID].meta;\n            } else if (mode === 'annotation') {\n                if (frame >= frameDataCache[taskID].meta.length) {\n                    throw new ArgumentError(\n                        `Meta information about frame ${frame} can't be received from the server`,\n                    );\n                } else {\n                    size = frameDataCache[taskID].meta[frame];\n                }\n            } else {\n                throw new ArgumentError(\n                    `Invalid mode is specified ${mode}`,\n                );\n            }\n\n            frameDataCache[taskID][frame] = new FrameData(size.width, size.height, taskID, frame);\n        }\n\n        return frameDataCache[taskID][frame];\n    }\n\n    function getRanges(taskID) {\n        if (!(taskID in frameDataCache)) {\n            return [];\n        }\n\n        return frameDataCache[taskID].provider.cachedFrames;\n    }\n\n    module.exports = {\n        FrameData,\n        getFrame,\n        getRanges,\n    };\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n(() => {\n    const { AttributeType } = require('./enums');\n    const { ArgumentError } = require('./exceptions');\n\n    /**\n        * Class representing an attribute\n        * @memberof module:API.cvat.classes\n        * @hideconstructor\n    */\n    class Attribute {\n        constructor(initialData) {\n            const data = {\n                id: undefined,\n                default_value: undefined,\n                input_type: undefined,\n                mutable: undefined,\n                name: undefined,\n                values: undefined,\n            };\n\n            for (const key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                    if (Object.prototype.hasOwnProperty.call(initialData, key)) {\n                        if (Array.isArray(initialData[key])) {\n                            data[key] = [...initialData[key]];\n                        } else {\n                            data[key] = initialData[key];\n                        }\n                    }\n                }\n            }\n\n            if (!Object.values(AttributeType).includes(data.input_type)) {\n                throw new ArgumentError(\n                    `Got invalid attribute type ${data.input_type}`,\n                );\n            }\n\n            Object.defineProperties(this, Object.freeze({\n                /**\n                    * @name id\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Attribute\n                    * @readonly\n                    * @instance\n                */\n                id: {\n                    get: () => data.id,\n                },\n                /**\n                    * @name defaultValue\n                    * @type {(string|integer|boolean)}\n                    * @memberof module:API.cvat.classes.Attribute\n                    * @readonly\n                    * @instance\n                */\n                defaultValue: {\n                    get: () => data.default_value,\n                },\n                /**\n                    * @name inputType\n                    * @type {module:API.cvat.enums.AttributeType}\n                    * @memberof module:API.cvat.classes.Attribute\n                    * @readonly\n                    * @instance\n                */\n                inputType: {\n                    get: () => data.input_type,\n                },\n                /**\n                    * @name mutable\n                    * @type {boolean}\n                    * @memberof module:API.cvat.classes.Attribute\n                    * @readonly\n                    * @instance\n                */\n                mutable: {\n                    get: () => data.mutable,\n                },\n                /**\n                    * @name name\n                    * @type {string}\n                    * @memberof module:API.cvat.classes.Attribute\n                    * @readonly\n                    * @instance\n                */\n                name: {\n                    get: () => data.name,\n                },\n                /**\n                    * @name values\n                    * @type {(string[]|integer[]|boolean[])}\n                    * @memberof module:API.cvat.classes.Attribute\n                    * @readonly\n                    * @instance\n                */\n                values: {\n                    get: () => [...data.values],\n                },\n            }));\n        }\n\n        toJSON() {\n            const object = {\n                name: this.name,\n                mutable: this.mutable,\n                input_type: this.inputType,\n                default_value: this.defaultValue,\n                values: this.values,\n            };\n\n            if (typeof (this.id) !== 'undefined') {\n                object.id = this.id;\n            }\n\n            return object;\n        }\n    }\n\n    /**\n        * Class representing a label\n        * @memberof module:API.cvat.classes\n        * @hideconstructor\n    */\n    class Label {\n        constructor(initialData) {\n            const data = {\n                id: undefined,\n                name: undefined,\n            };\n\n            for (const key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                    if (Object.prototype.hasOwnProperty.call(initialData, key)) {\n                        data[key] = initialData[key];\n                    }\n                }\n            }\n\n            data.attributes = [];\n\n            if (Object.prototype.hasOwnProperty.call(initialData, 'attributes')\n                && Array.isArray(initialData.attributes)) {\n                for (const attrData of initialData.attributes) {\n                    data.attributes.push(new Attribute(attrData));\n                }\n            }\n\n            Object.defineProperties(this, Object.freeze({\n                /**\n                    * @name id\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Label\n                    * @readonly\n                    * @instance\n                */\n                id: {\n                    get: () => data.id,\n                },\n                /**\n                    * @name name\n                    * @type {string}\n                    * @memberof module:API.cvat.classes.Label\n                    * @readonly\n                    * @instance\n                */\n                name: {\n                    get: () => data.name,\n                },\n                /**\n                    * @name attributes\n                    * @type {module:API.cvat.classes.Attribute[]}\n                    * @memberof module:API.cvat.classes.Label\n                    * @readonly\n                    * @instance\n                */\n                attributes: {\n                    get: () => [...data.attributes],\n                },\n            }));\n        }\n\n        toJSON() {\n            const object = {\n                name: this.name,\n                attributes: [...this.attributes.map(el => el.toJSON())],\n            };\n\n            if (typeof (this.id) !== 'undefined') {\n                object.id = this.id;\n            }\n\n            return object;\n        }\n    }\n\n    module.exports = {\n        Attribute,\n        Label,\n    };\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n(() => {\n    const PluginRegistry = require('./plugins');\n    const { ArgumentError } = require('./exceptions');\n\n    /**\n        * Class representing a state of an object on a specific frame\n        * @memberof module:API.cvat.classes\n    */\n    class ObjectState {\n        /**\n            * @param {Object} serialized - is an dictionary which contains\n            * initial information about an ObjectState;\n            * Necessary fields: objectType, shapeType\n            * (don't have setters)\n            * Necessary fields for objects which haven't been added to collection yet: frame\n            * (doesn't have setters)\n            * Optional fields: points, group, zOrder, outside, occluded,\n            * attributes, lock, label, mode, color, keyframe, clientID, serverID\n            * These fields can be set later via setters\n        */\n        constructor(serialized) {\n            const data = {\n                label: null,\n                attributes: {},\n\n                points: null,\n                outside: null,\n                occluded: null,\n                keyframe: null,\n\n                group: null,\n                zOrder: null,\n                lock: null,\n                color: null,\n                visibility: null,\n\n                clientID: serialized.clientID,\n                serverID: serialized.serverID,\n\n                frame: serialized.frame,\n                objectType: serialized.objectType,\n                shapeType: serialized.shapeType,\n                updateFlags: {},\n            };\n\n            // Shows whether any properties updated since last reset() or interpolation\n            Object.defineProperty(data.updateFlags, 'reset', {\n                value: function reset() {\n                    this.label = false;\n                    this.attributes = false;\n\n                    this.points = false;\n                    this.outside = false;\n                    this.occluded = false;\n                    this.keyframe = false;\n\n                    this.group = false;\n                    this.zOrder = false;\n                    this.lock = false;\n                    this.color = false;\n                    this.visibility = false;\n                },\n                writable: false,\n            });\n\n            Object.defineProperties(this, Object.freeze({\n                // Internal property. We don't need document it.\n                updateFlags: {\n                    get: () => data.updateFlags,\n                },\n                frame: {\n                    /**\n                        * @name frame\n                        * @type {integer}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.frame,\n                },\n                objectType: {\n                    /**\n                        * @name objectType\n                        * @type {module:API.cvat.enums.ObjectType}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.objectType,\n                },\n                shapeType: {\n                    /**\n                        * @name shapeType\n                        * @type {module:API.cvat.enums.ObjectShape}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.shapeType,\n                },\n                clientID: {\n                    /**\n                        * @name clientID\n                        * @type {integer}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.clientID,\n                },\n                serverID: {\n                    /**\n                        * @name serverID\n                        * @type {integer}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.serverID,\n                },\n                label: {\n                    /**\n                        * @name shape\n                        * @type {module:API.cvat.classes.Label}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @instance\n                    */\n                    get: () => data.label,\n                    set: (labelInstance) => {\n                        data.updateFlags.label = true;\n                        data.label = labelInstance;\n                    },\n                },\n                color: {\n                    /**\n                        * @name color\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @instance\n                    */\n                    get: () => data.color,\n                    set: (color) => {\n                        data.updateFlags.color = true;\n                        data.color = color;\n                    },\n                },\n                visibility: {\n                    /**\n                        * @name visibility\n                        * @type {module:API.cvat.enums.VisibleState}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @instance\n                    */\n                    get: () => data.visibility,\n                    set: (visibility) => {\n                        data.updateFlags.visibility = true;\n                        data.visibility = visibility;\n                    },\n                },\n                points: {\n                    /**\n                        * @name points\n                        * @type {number[]}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @throws {module:API.cvat.exceptions.ArgumentError}\n                        * @instance\n                    */\n                    get: () => data.points,\n                    set: (points) => {\n                        if (Array.isArray(points)) {\n                            data.updateFlags.points = true;\n                            data.points = [...points];\n                        } else {\n                            throw new ArgumentError(\n                                'Points are expected to be an array '\n                                    + `but got ${typeof (points) === 'object'\n                                        ? points.constructor.name : typeof (points)}`,\n                            );\n                        }\n                    },\n                },\n                group: {\n                    /**\n                        * @name group\n                        * @type {integer}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @instance\n                    */\n                    get: () => data.group,\n                    set: (group) => {\n                        data.updateFlags.group = true;\n                        data.group = group;\n                    },\n                },\n                zOrder: {\n                    /**\n                        * @name zOrder\n                        * @type {integer}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @instance\n                    */\n                    get: () => data.zOrder,\n                    set: (zOrder) => {\n                        data.updateFlags.zOrder = true;\n                        data.zOrder = zOrder;\n                    },\n                },\n                outside: {\n                    /**\n                        * @name outside\n                        * @type {boolean}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @instance\n                    */\n                    get: () => data.outside,\n                    set: (outside) => {\n                        data.updateFlags.outside = true;\n                        data.outside = outside;\n                    },\n                },\n                keyframe: {\n                    /**\n                        * @name keyframe\n                        * @type {boolean}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @instance\n                    */\n                    get: () => data.keyframe,\n                    set: (keyframe) => {\n                        data.updateFlags.keyframe = true;\n                        data.keyframe = keyframe;\n                    },\n                },\n                occluded: {\n                    /**\n                        * @name occluded\n                        * @type {boolean}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @instance\n                    */\n                    get: () => data.occluded,\n                    set: (occluded) => {\n                        data.updateFlags.occluded = true;\n                        data.occluded = occluded;\n                    },\n                },\n                lock: {\n                    /**\n                        * @name lock\n                        * @type {boolean}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @instance\n                    */\n                    get: () => data.lock,\n                    set: (lock) => {\n                        data.updateFlags.lock = true;\n                        data.lock = lock;\n                    },\n                },\n                attributes: {\n                    /**\n                        * Object is id:value pairs where \"id\" is an integer\n                        * attribute identifier and \"value\" is an attribute value\n                        * @name attributes\n                        * @type {Object}\n                        * @memberof module:API.cvat.classes.ObjectState\n                        * @throws {module:API.cvat.exceptions.ArgumentError}\n                        * @instance\n                    */\n                    get: () => data.attributes,\n                    set: (attributes) => {\n                        if (typeof (attributes) !== 'object') {\n                            throw new ArgumentError(\n                                'Attributes are expected to be an object '\n                                    + `but got ${typeof (attributes) === 'object'\n                                        ? attributes.constructor.name : typeof (attributes)}`,\n                            );\n                        }\n\n                        for (const attrID of Object.keys(attributes)) {\n                            data.updateFlags.attributes = true;\n                            data.attributes[attrID] = attributes[attrID];\n                        }\n                    },\n                },\n            }));\n\n            this.label = serialized.label;\n            this.group = serialized.group;\n            this.zOrder = serialized.zOrder;\n            this.outside = serialized.outside;\n            this.keyframe = serialized.keyframe;\n            this.occluded = serialized.occluded;\n            this.color = serialized.color;\n            this.lock = serialized.lock;\n            this.visibility = serialized.visibility;\n\n            // It can be undefined in a constructor and it can be defined later\n            if (typeof (serialized.points) !== 'undefined') {\n                this.points = serialized.points;\n            }\n            if (typeof (serialized.attributes) !== 'undefined') {\n                this.attributes = serialized.attributes;\n            }\n\n            data.updateFlags.reset();\n        }\n\n        /**\n            * Method saves/updates an object state in a collection\n            * @method save\n            * @memberof module:API.cvat.classes.ObjectState\n            * @readonly\n            * @instance\n            * @async\n            * @throws {module:API.cvat.exceptions.PluginError}\n            * @throws {module:API.cvat.exceptions.ArgumentError}\n            * @returns {module:API.cvat.classes.ObjectState} updated state of an object\n        */\n        async save() {\n            const result = await PluginRegistry\n                .apiWrapper.call(this, ObjectState.prototype.save);\n            return result;\n        }\n\n        /**\n            * Method deletes an object from a collection\n            * @method delete\n            * @memberof module:API.cvat.classes.ObjectState\n            * @readonly\n            * @instance\n            * @param {boolean} [force=false] delete object even if it is locked\n            * @async\n            * @returns {boolean} true if object has been deleted\n            * @throws {module:API.cvat.exceptions.PluginError}\n        */\n        async delete(force = false) {\n            const result = await PluginRegistry\n                .apiWrapper.call(this, ObjectState.prototype.delete, force);\n            return result;\n        }\n\n        /**\n            * Set the highest ZOrder within a frame\n            * @method up\n            * @memberof module:API.cvat.classes.ObjectState\n            * @readonly\n            * @instance\n            * @async\n            * @throws {module:API.cvat.exceptions.PluginError}\n        */\n        async up() {\n            const result = await PluginRegistry\n                .apiWrapper.call(this, ObjectState.prototype.up);\n            return result;\n        }\n\n        /**\n            * Set the lowest ZOrder within a frame\n            * @method down\n            * @memberof module:API.cvat.classes.ObjectState\n            * @readonly\n            * @instance\n            * @async\n            * @throws {module:API.cvat.exceptions.PluginError}\n        */\n        async down() {\n            const result = await PluginRegistry\n                .apiWrapper.call(this, ObjectState.prototype.down);\n            return result;\n        }\n    }\n\n    // Updates element in collection which contains it\n    ObjectState.prototype.save.implementation = async function () {\n        if (this.hidden && this.hidden.save) {\n            return this.hidden.save();\n        }\n\n        return this;\n    };\n\n    // Delete element from a collection which contains it\n    ObjectState.prototype.delete.implementation = async function (force) {\n        if (this.hidden && this.hidden.delete) {\n            return this.hidden.delete(force);\n        }\n\n        return false;\n    };\n\n    ObjectState.prototype.up.implementation = async function () {\n        if (this.hidden && this.hidden.up) {\n            return this.hidden.up();\n        }\n\n        return false;\n    };\n\n    ObjectState.prototype.down.implementation = async function () {\n        if (this.hidden && this.hidden.down) {\n            return this.hidden.down();\n        }\n\n        return false;\n    };\n\n\n    module.exports = ObjectState;\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n(() => {\n    const { PluginError } = require('./exceptions');\n\n    const plugins = [];\n    class PluginRegistry {\n        static async apiWrapper(wrappedFunc, ...args) {\n            // I have to optimize the wrapper\n            const pluginList = await PluginRegistry.list();\n            for (const plugin of pluginList) {\n                const pluginDecorators = plugin.functions\n                    .filter(obj => obj.callback === wrappedFunc)[0];\n                if (pluginDecorators && pluginDecorators.enter) {\n                    try {\n                        await pluginDecorators.enter.call(this, plugin, ...args);\n                    } catch (exception) {\n                        if (exception instanceof PluginError) {\n                            throw exception;\n                        } else {\n                            throw new PluginError(`Exception in plugin ${plugin.name}: ${exception.toString()}`);\n                        }\n                    }\n                }\n            }\n\n            let result = await wrappedFunc.implementation.call(this, ...args);\n\n            for (const plugin of pluginList) {\n                const pluginDecorators = plugin.functions\n                    .filter(obj => obj.callback === wrappedFunc)[0];\n                if (pluginDecorators && pluginDecorators.leave) {\n                    try {\n                        result = await pluginDecorators.leave.call(this, plugin, result, ...args);\n                    } catch (exception) {\n                        if (exception instanceof PluginError) {\n                            throw exception;\n                        } else {\n                            throw new PluginError(`Exception in plugin ${plugin.name}: ${exception.toString()}`);\n                        }\n                    }\n                }\n            }\n\n            return result;\n        }\n\n        // Called with cvat context\n        static async register(plug) {\n            const functions = [];\n\n            if (typeof (plug) !== 'object') {\n                throw new PluginError(`Plugin should be an object, but got \"${typeof (plug)}\"`);\n            }\n\n            if (!('name' in plug) || typeof (plug.name) !== 'string') {\n                throw new PluginError('Plugin must contain a \"name\" field and it must be a string');\n            }\n\n            if (!('description' in plug) || typeof (plug.description) !== 'string') {\n                throw new PluginError('Plugin must contain a \"description\" field and it must be a string');\n            }\n\n            if ('functions' in plug) {\n                throw new PluginError('Plugin must not contain a \"functions\" field');\n            }\n\n            (function traverse(plugin, api) {\n                const decorator = {};\n                for (const key in plugin) {\n                    if (Object.prototype.hasOwnProperty.call(plugin, key)) {\n                        if (typeof (plugin[key]) === 'object') {\n                            if (Object.prototype.hasOwnProperty.call(api, key)) {\n                                traverse(plugin[key], api[key]);\n                            }\n                        } else if (['enter', 'leave'].includes(key)\n                            && typeof (api) === 'function'\n                            && typeof (plugin[key] === 'function')) {\n                            decorator.callback = api;\n                            decorator[key] = plugin[key];\n                        }\n                    }\n                }\n\n                if (Object.keys(decorator).length) {\n                    functions.push(decorator);\n                }\n            }(plug, {\n                cvat: this,\n            }));\n\n            Object.defineProperty(plug, 'functions', {\n                value: functions,\n                writable: false,\n            });\n\n            plugins.push(plug);\n        }\n\n        static async list() {\n            return plugins;\n        }\n    }\n\n    module.exports = PluginRegistry;\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n(() => {\n    const FormData = require('form-data');\n    const {\n        ServerError,\n    } = require('./exceptions');\n    const store = require('store');\n    const config = require('./config');\n\n    function generateError(errorData, baseMessage) {\n        if (errorData.response) {\n            const message = `${baseMessage}. `\n                + `${errorData.message}. ${JSON.stringify(errorData.response.data) || ''}.`;\n            return new ServerError(message, errorData.response.status);\n        }\n\n        // Server is unavailable (no any response)\n        const message = `${baseMessage}. `\n        + `${errorData.message}.`; // usually is \"Error Network\"\n        return new ServerError(message, 0);\n    }\n\n    class ServerProxy {\n        constructor() {\n            const Axios = require('axios');\n            Axios.defaults.withCredentials = true;\n            Axios.defaults.xsrfHeaderName = 'X-CSRFTOKEN';\n            Axios.defaults.xsrfCookieName = 'csrftoken';\n\n            let token = store.get('token');\n            if (token) {\n                Axios.defaults.headers.common.Authorization = `Token ${token}`;\n            }\n\n            async function about() {\n                const { backendAPI } = config;\n\n                let response = null;\n                try {\n                    response = await Axios.get(`${backendAPI}/server/about`, {\n                        proxy: config.proxy,\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not get \"about\" information from the server',\n                        code,\n                    );\n                }\n\n                return response.data;\n            }\n\n            async function share(directory) {\n                const { backendAPI } = config;\n                directory = encodeURIComponent(directory);\n\n                let response = null;\n                try {\n                    response = await Axios.get(`${backendAPI}/server/share?directory=${directory}`, {\n                        proxy: config.proxy,\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not get \"share\" information from the server',\n                        code,\n                    );\n                }\n\n                return response.data;\n            }\n\n            async function exception(exceptionObject) {\n                const { backendAPI } = config;\n\n                try {\n                    await Axios.post(`${backendAPI}/server/exception`, JSON.stringify(exceptionObject), {\n                        proxy: config.proxy,\n                        headers: {\n                            'Content-Type': 'application/json',\n                        },\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not send an exception to the server',\n                        code,\n                    );\n                }\n            }\n\n            async function formats() {\n                const { backendAPI } = config;\n\n                let response = null;\n                try {\n                    response = await Axios.get(`${backendAPI}/server/annotation/formats`, {\n                        proxy: config.proxy,\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not get annotation formats from the server',\n                        code,\n                    );\n                }\n\n                return response.data;\n            }\n\n            async function register(username, firstName, lastName, email, password1, password2) {\n                let response = null;\n                try {\n                    const data = JSON.stringify({\n                        username,\n                        first_name: firstName,\n                        last_name: lastName,\n                        email,\n                        password1,\n                        password2,\n                    });\n                    response = await Axios.post(`${config.backendAPI}/auth/register`, data, {\n                        proxy: config.proxy,\n                        headers: {\n                            'Content-Type': 'application/json',\n                        },\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        `Could not register '${username}' user on the server`,\n                        code,\n                    );\n                }\n\n                return response.data;\n            }\n\n            async function login(username, password) {\n                const authenticationData = ([\n                    `${encodeURIComponent('username')}=${encodeURIComponent(username)}`,\n                    `${encodeURIComponent('password')}=${encodeURIComponent(password)}`,\n                ]).join('&').replace(/%20/g, '+');\n\n                let authenticationResponse = null;\n                try {\n                    authenticationResponse = await Axios.post(\n                        `${config.backendAPI}/auth/login`,\n                        authenticationData, {\n                            proxy: config.proxy,\n                        },\n                    );\n                } catch (errorData) {\n                    const code = errorData.response\n                        ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not login on a server',\n                        code,\n                    );\n                }\n\n                if (authenticationResponse.headers['set-cookie']) {\n                    // Browser itself setup cookie and header is none\n                    // In NodeJS we need do it manually\n                    const cookies = authenticationResponse.headers['set-cookie'].join(';');\n                    Axios.defaults.headers.common.Cookie = cookies;\n                }\n\n                token = authenticationResponse.data.key;\n                store.set('token', token);\n                Axios.defaults.headers.common.Authorization = `Token ${token}`;\n            }\n\n            async function logout() {\n                try {\n                    await Axios.post(`${config.backendAPI}/auth/logout`, {\n                        proxy: config.proxy,\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not logout from the server',\n                        code,\n                    );\n                }\n\n                store.remove('token');\n                Axios.defaults.headers.common.Authorization = '';\n            }\n\n            async function authorized() {\n                try {\n                    await module.exports.users.getSelf();\n                } catch (serverError) {\n                    if (serverError.code === 401) {\n                        return false;\n                    }\n\n                    throw serverError;\n                }\n\n                return true;\n            }\n\n            async function getTasks(filter = '') {\n                const { backendAPI } = config;\n\n                let response = null;\n                try {\n                    response = await Axios.get(`${backendAPI}/tasks?${filter}`, {\n                        proxy: config.proxy,\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not get tasks from a server',\n                        code,\n                    );\n                }\n\n                response.data.results.count = response.data.count;\n                return response.data.results;\n            }\n\n            async function saveTask(id, taskData) {\n                const { backendAPI } = config;\n\n                try {\n                    await Axios.patch(`${backendAPI}/tasks/${id}`, JSON.stringify(taskData), {\n                        proxy: config.proxy,\n                        headers: {\n                            'Content-Type': 'application/json',\n                        },\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not save the task on the server',\n                        code,\n                    );\n                }\n            }\n\n            async function deleteTask(id) {\n                const { backendAPI } = config;\n\n                try {\n                    await Axios.delete(`${backendAPI}/tasks/${id}`);\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not delete the task from the server',\n                        code,\n                    );\n                }\n            }\n\n            async function createTask(taskData, files, onUpdate) {\n                const { backendAPI } = config;\n\n                async function wait(id) {\n                    return new Promise((resolve, reject) => {\n                        async function checkStatus() {\n                            try {\n                                const response = await Axios.get(`${backendAPI}/tasks/${id}/status`);\n                                if (['Queued', 'Started'].includes(response.data.state)) {\n                                    if (response.data.message !== '') {\n                                        onUpdate(response.data.message);\n                                    }\n                                    setTimeout(checkStatus, 1000);\n                                } else if (response.data.state === 'Finished') {\n                                    resolve();\n                                } else if (response.data.state === 'Failed') {\n                                    // If request has been successful, but task hasn't been created\n                                    // Then passed data is wrong and we can pass code 400\n                                    reject(new ServerError(\n                                        'Could not create the task on the server',\n                                        400,\n                                    ));\n                                } else {\n                                    // If server has another status, it is unexpected\n                                    // Therefore it is server error and we can pass code 500\n                                    reject(new ServerError(\n                                        `Unknown task state has been received: ${response.data.state}`,\n                                        500,\n                                    ));\n                                }\n                            } catch (errorData) {\n                                const code = errorData.response\n                                    ? errorData.response.status : errorData.code;\n\n                                reject(new ServerError(\n                                    'Data uploading error occurred',\n                                    code,\n                                ));\n                            }\n                        }\n\n                        setTimeout(checkStatus, 1000);\n                    });\n                }\n\n                const batchOfFiles = new FormData();\n                for (const key in files) {\n                    if (Object.prototype.hasOwnProperty.call(files, key)) {\n                        for (let i = 0; i < files[key].length; i++) {\n                            batchOfFiles.append(`${key}[${i}]`, files[key][i]);\n                        }\n                    }\n                }\n\n                let response = null;\n\n                onUpdate('The task is being created on the server..');\n                try {\n                    response = await Axios.post(`${backendAPI}/tasks`, JSON.stringify(taskData), {\n                        proxy: config.proxy,\n                        headers: {\n                            'Content-Type': 'application/json',\n                        },\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not put task to the server',\n                        code,\n                    );\n                }\n\n                onUpdate('The data is being uploaded to the server..');\n                try {\n                    await Axios.post(`${backendAPI}/tasks/${response.data.id}/data`, batchOfFiles, {\n                        proxy: config.proxy,\n                    });\n                } catch (errorData) {\n                    await deleteTask(response.data.id);\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not put data to the server',\n                        code,\n                    );\n                }\n\n                try {\n                    await wait(response.data.id);\n                } catch (createException) {\n                    await deleteTask(response.data.id);\n                    throw createException;\n                }\n\n                const createdTask = await getTasks(`?id=${response.id}`);\n                return createdTask[0];\n            }\n\n            async function getJob(jobID) {\n                const { backendAPI } = config;\n\n                let response = null;\n                try {\n                    response = await Axios.get(`${backendAPI}/jobs/${jobID}`, {\n                        proxy: config.proxy,\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not get jobs from a server',\n                        code,\n                    );\n                }\n\n                return response.data;\n            }\n\n            async function saveJob(id, jobData) {\n                const { backendAPI } = config;\n\n                try {\n                    await Axios.patch(`${backendAPI}/jobs/${id}`, JSON.stringify(jobData), {\n                        proxy: config.proxy,\n                        headers: {\n                            'Content-Type': 'application/json',\n                        },\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not save the job on the server',\n                        code,\n                    );\n                }\n            }\n\n            async function getUsers() {\n                const { backendAPI } = config;\n\n                let response = null;\n                try {\n                    response = await Axios.get(`${backendAPI}/users`, {\n                        proxy: config.proxy,\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not get users from the server',\n                        code,\n                    );\n                }\n\n                return response.data.results;\n            }\n\n            async function getSelf() {\n                const { backendAPI } = config;\n\n                let response = null;\n                try {\n                    response = await Axios.get(`${backendAPI}/users/self`, {\n                        proxy: config.proxy,\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        'Could not get user data from the server',\n                        code,\n                    );\n                }\n\n                return response.data;\n            }\n\n            async function getPreview(tid) {\n                const { backendAPI } = config;\n\n                let response = null;\n                try {\n                    response = await Axios.get(`${backendAPI}/tasks/${tid}/frames/preview`, {\n                        proxy: config.proxy,\n                        responseType: 'blob',\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        `Could not get preview frame for the task ${tid} from the server`,\n                        code,\n                    );\n                }\n\n                return response.data;\n            }\n\n            async function getData(tid, chunk) {\n                const { backendAPI } = config;\n\n                let response = null;\n                try {\n                    response = await Axios.get(`${backendAPI}/tasks/${tid}/frames/chunk/${chunk}`, {\n                        proxy: config.proxy,\n                        responseType: 'arraybuffer',\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        `Could not get chunk ${chunk} for the task ${tid} from the server`,\n                        code,\n                    );\n                }\n\n                return response.data;\n            }\n\n            async function getMeta(tid) {\n                const { backendAPI } = config;\n\n                let response = null;\n                try {\n                    response = await Axios.get(`${backendAPI}/tasks/${tid}/frames/meta`, {\n                        proxy: config.proxy,\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        `Could not get frame meta info for the task ${tid} from the server`,\n                        code,\n                    );\n                }\n\n                return response.data;\n            }\n\n            // Session is 'task' or 'job'\n            async function getAnnotations(session, id) {\n                const { backendAPI } = config;\n\n                let response = null;\n                try {\n                    response = await Axios.get(`${backendAPI}/${session}s/${id}/annotations`, {\n                        proxy: config.proxy,\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        `Could not get annotations for the ${session} ${id} from the server`,\n                        code,\n                    );\n                }\n\n                return response.data;\n            }\n\n            // Session is 'task' or 'job'\n            async function updateAnnotations(session, id, data, action) {\n                const { backendAPI } = config;\n                let requestFunc = null;\n                let url = null;\n                if (action.toUpperCase() === 'PUT') {\n                    requestFunc = Axios.put.bind(Axios);\n                    url = `${backendAPI}/${session}s/${id}/annotations`;\n                } else {\n                    requestFunc = Axios.patch.bind(Axios);\n                    url = `${backendAPI}/${session}s/${id}/annotations?action=${action}`;\n                }\n\n                let response = null;\n                try {\n                    response = await requestFunc(url, JSON.stringify(data), {\n                        proxy: config.proxy,\n                        headers: {\n                            'Content-Type': 'application/json',\n                        },\n                    });\n                } catch (errorData) {\n                    const code = errorData.response ? errorData.response.status : errorData.code;\n                    throw new ServerError(\n                        `Could not updated annotations for the ${session} ${id} on the server`,\n                        code,\n                    );\n                }\n\n                return response.data;\n            }\n\n            // Session is 'task' or 'job'\n            async function uploadAnnotations(session, id, file, format) {\n                const { backendAPI } = config;\n\n                let annotationData = new FormData();\n                annotationData.append('annotation_file', file);\n\n                return new Promise((resolve, reject) => {\n                    async function request() {\n                        try {\n                            const response = await Axios\n                                .put(`${backendAPI}/${session}s/${id}/annotations?format=${format}`, annotationData, {\n                                    proxy: config.proxy,\n                                });\n                            if (response.status === 202) {\n                                annotationData = new FormData();\n                                setTimeout(request, 3000);\n                            } else {\n                                resolve();\n                            }\n                        } catch (errorData) {\n                            const code = errorData.response\n                                ? errorData.response.status : errorData.code;\n                            const error = new ServerError(\n                                `Could not upload annotations for the ${session} ${id}`,\n                                code,\n                            );\n                            reject(error);\n                        }\n                    }\n\n                    setTimeout(request);\n                });\n            }\n\n            // Session is 'task' or 'job'\n            async function dumpAnnotations(id, name, format) {\n                const { backendAPI } = config;\n                const filename = name.replace(/\\//g, '_');\n                let url = `${backendAPI}/tasks/${id}/annotations/${filename}?format=${format}`;\n\n                return new Promise((resolve, reject) => {\n                    async function request() {\n                        try {\n                            const response = await Axios\n                                .get(`${url}`, {\n                                    proxy: config.proxy,\n                                });\n                            if (response.status === 202) {\n                                setTimeout(request, 3000);\n                            } else {\n                                url = `${url}&action=download`;\n                                resolve(url);\n                            }\n                        } catch (errorData) {\n                            const code = errorData.response\n                                ? errorData.response.status : errorData.code;\n                            const error = new ServerError(\n                                `Could not dump annotations for the task ${id} from the server`,\n                                code,\n                            );\n                            reject(error);\n                        }\n                    }\n\n                    setTimeout(request);\n                });\n            }\n\n            Object.defineProperties(this, Object.freeze({\n                server: {\n                    value: Object.freeze({\n                        about,\n                        share,\n                        formats,\n                        exception,\n                        login,\n                        logout,\n                        authorized,\n                        register,\n                    }),\n                    writable: false,\n                },\n\n                tasks: {\n                    value: Object.freeze({\n                        getTasks,\n                        saveTask,\n                        createTask,\n                        deleteTask,\n                    }),\n                    writable: false,\n                },\n\n                jobs: {\n                    value: Object.freeze({\n                        getJob,\n                        saveJob,\n                    }),\n                    writable: false,\n                },\n\n                users: {\n                    value: Object.freeze({\n                        getUsers,\n                        getSelf,\n                    }),\n                    writable: false,\n                },\n\n                frames: {\n                    value: Object.freeze({\n                        getPreview,\n                        getData,\n                        getMeta,\n                    }),\n                    writable: false,\n                },\n\n                annotations: {\n                    value: Object.freeze({\n                        updateAnnotations,\n                        getAnnotations,\n                        dumpAnnotations,\n                        uploadAnnotations,\n                    }),\n                    writable: false,\n                },\n            }));\n        }\n    }\n\n    const serverProxy = new ServerProxy();\n    module.exports = serverProxy;\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:false\n*/\n\n(() => {\n    const PluginRegistry = require('./plugins');\n    const serverProxy = require('./server-proxy');\n    const { getFrame, getRanges } = require('./frames');\n    const { ArgumentError } = require('./exceptions');\n    const { TaskStatus } = require('./enums');\n    const { Label } = require('./labels');\n\n    function buildDublicatedAPI(prototype) {\n        Object.defineProperties(prototype, {\n            annotations: Object.freeze({\n                value: {\n                    async upload(file, loader) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.upload, file, loader);\n                        return result;\n                    },\n\n                    async save() {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.save);\n                        return result;\n                    },\n\n                    async clear(reload = false) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.clear, reload);\n                        return result;\n                    },\n\n                    async dump(name, dumper) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.dump, name, dumper);\n                        return result;\n                    },\n\n                    async statistics() {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.statistics);\n                        return result;\n                    },\n\n                    async put(arrayOfObjects = []) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.put, arrayOfObjects);\n                        return result;\n                    },\n\n                    async get(frame, filter = {}) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.get, frame, filter);\n                        return result;\n                    },\n\n                    async search(filter, frameFrom, frameTo) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.search,\n                                filter, frameFrom, frameTo);\n                        return result;\n                    },\n\n                    async select(objectStates, x, y) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this,\n                                prototype.annotations.select, objectStates, x, y);\n                        return result;\n                    },\n\n                    async hasUnsavedChanges() {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.hasUnsavedChanges);\n                        return result;\n                    },\n\n                    async merge(objectStates) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.merge, objectStates);\n                        return result;\n                    },\n\n                    async split(objectState, frame) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.split, objectState, frame);\n                        return result;\n                    },\n\n                    async group(objectStates, reset = false) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.annotations.group,\n                                objectStates, reset);\n                        return result;\n                    },\n                },\n                writable: true,\n            }),\n            frames: Object.freeze({\n                value: {\n                    async get(frame) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.frames.get, frame);\n                        return result;\n                    },\n                    async ranges() {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.frames.ranges);\n                        return result;\n                    },\n                },\n                writable: true,\n            }),\n            logs: Object.freeze({\n                value: {\n                    async put(logType, details) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.logs.put, logType, details);\n                        return result;\n                    },\n                    async save(onUpdate) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.logs.save, onUpdate);\n                        return result;\n                    },\n                },\n                writable: true,\n            }),\n            actions: Object.freeze({\n                value: {\n                    async undo(count) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.actions.undo, count);\n                        return result;\n                    },\n                    async redo(count) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.actions.redo, count);\n                        return result;\n                    },\n                    async clear() {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.actions.clear);\n                        return result;\n                    },\n                },\n                writable: true,\n            }),\n            events: Object.freeze({\n                value: {\n                    async subscribe(evType, callback) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.events.subscribe, evType, callback);\n                        return result;\n                    },\n                    async unsubscribe(evType, callback = null) {\n                        const result = await PluginRegistry\n                            .apiWrapper.call(this, prototype.events.unsubscribe, evType, callback);\n                        return result;\n                    },\n                },\n                writable: true,\n            }),\n        });\n    }\n\n    /**\n        * Base abstract class for Task and Job. It contains common members.\n        * @hideconstructor\n        * @virtual\n    */\n    class Session {\n        constructor() {\n            /**\n                * An interaction with annotations\n                * @namespace annotations\n                * @memberof Session\n            */\n            /**\n                * Upload annotations from a dump file\n                * You need upload annotations from a server again after successful executing\n                * @method upload\n                * @memberof Session.annotations\n                * @param {File} annotations - a text file with annotations\n                * @param {module:API.cvat.classes.Loader} loader - a loader\n                * which will be used to upload\n                * @instance\n                * @async\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n            */\n            /**\n                * Save all changes in annotations on a server\n                * Objects which hadn't been saved on a server before,\n                * get a serverID after saving. But received object states aren't updated.\n                * So, after successful saving it's recommended to update them manually\n                * (call the annotations.get() again)\n                * @method save\n                * @memberof Session.annotations\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n                * @instance\n                * @async\n                * @param {function} [onUpdate] saving can be long.\n                * This callback can be used to notify a user about current progress\n                * Its argument is a text string\n            */\n            /**\n                * Remove all annotations and optionally reinitialize it\n                * @method clear\n                * @memberof Session.annotations\n                * @param {boolean} [reload = false] reset all changes and\n                * reinitialize annotations by data from a server\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n                * @instance\n                * @async\n            */\n            /**\n                * Dump of annotations to a file.\n                * Method always dumps annotations for a whole task.\n                * @method dump\n                * @memberof Session.annotations\n                * @param {string} name - a name of a file with annotations\n                * @param {module:API.cvat.classes.Dumper} dumper - a dumper\n                * which will be used to dump\n                * @returns {string} URL which can be used in order to get a dump file\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n                * @instance\n                * @async\n            */\n            /**\n                * Collect short statistics about a task or a job.\n                * @method statistics\n                * @memberof Session.annotations\n                * @returns {module:API.cvat.classes.Statistics} statistics object\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @instance\n                * @async\n            */\n            /**\n                * Create new objects from one-frame states\n                * After successful adding you need to update object states on a frame\n                * @method put\n                * @memberof Session.annotations\n                * @param {module:API.cvat.classes.ObjectState[]} data\n                * array of objects on the specific frame\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.DataError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n                * @instance\n                * @async\n            */\n            /**\n                * @typedef {Object} ObjectFilter\n                * @property {string} [label] a name of a label\n                * @property {module:API.cvat.enums.ObjectType} [type]\n                * @property {module:API.cvat.enums.ObjectShape} [shape]\n                * @property {boolean} [occluded] a value of occluded property\n                * @property {boolean} [lock] a value of lock property\n                * @property {number} [width] a width of a shape\n                * @property {number} [height] a height of a shape\n                * @property {Object[]} [attributes] dictionary with \"name: value\" pairs\n                * @global\n            */\n            /**\n                * Get annotations for a specific frame\n                * @method get\n                * @param {integer} frame get objects from the frame\n                * @param {ObjectFilter[]} [filter = []]\n                * get only objects are satisfied to specific filter\n                * @returns {module:API.cvat.classes.ObjectState[]}\n                * @memberof Session.annotations\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n                * @instance\n                * @async\n            */\n            /**\n                * Find frame which contains at least one object satisfied to a filter\n                * @method search\n                * @memberof Session.annotations\n                * @param {ObjectFilter} [filter = []] filter\n                * @param {integer} from lower bound of a search\n                * @param {integer} to upper bound of a search\n                * @returns {integer} the nearest frame which contains filtered objects\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n                * @instance\n                * @async\n            */\n            /**\n                * Select shape under a cursor by using minimal distance\n                * between a cursor and a shape edge or a shape point\n                * For closed shapes a cursor is placed inside a shape\n                * @method select\n                * @memberof Session.annotations\n                * @param {module:API.cvat.classes.ObjectState[]} objectStates\n                * objects which can be selected\n                * @param {float} x horizontal coordinate\n                * @param {float} y vertical coordinate\n                * @returns {Object}\n                * a pair of {state: ObjectState, distance: number} for selected object.\n                * Pair values can be null if there aren't any sutisfied objects\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n                * @instance\n                * @async\n            */\n            /**\n                * Method unites several shapes and tracks into the one\n                * All shapes must be the same (rectangle, polygon, etc)\n                * All labels must be the same\n                * After successful merge you need to update object states on a frame\n                * @method merge\n                * @memberof Session.annotations\n                * @param {module:API.cvat.classes.ObjectState[]} objectStates\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n                * @instance\n                * @async\n            */\n            /**\n                * Method splits a track into two parts\n                * (start frame: previous frame), (frame, last frame)\n                * After successful split you need to update object states on a frame\n                * @method split\n                * @memberof Session.annotations\n                * @param {module:API.cvat.classes.ObjectState} objectState\n                * @param {integer} frame\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @instance\n                * @async\n            */\n            /**\n                * Method creates a new group and put all passed objects into it\n                * After successful split you need to update object states on a frame\n                * @method group\n                * @memberof Session.annotations\n                * @param {module:API.cvat.classes.ObjectState[]} objectStates\n                * @param {boolean} reset pass \"true\" to reset group value (set it to 0)\n                * @returns {integer} an ID of created group\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @instance\n                * @async\n            */\n            /**\n                * Indicate if there are any changes in\n                * annotations which haven't been saved on a server\n                * @method hasUnsavedChanges\n                * @memberof Session.annotations\n                * @returns {boolean}\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @instance\n                * @async\n            */\n\n\n            /**\n                * Namespace is used for an interaction with frames\n                * @namespace frames\n                * @memberof Session\n            */\n            /**\n                * Get frame by its number\n                * @method get\n                * @memberof Session.frames\n                * @param {integer} frame number of frame which you want to get\n                * @returns {module:API.cvat.classes.FrameData}\n                * @instance\n                * @async\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n            */\n            /**\n                * Returns the ranges of cached frames\n                * @method ranges\n                * @memberof Session.frames\n                * @returns {module:API.cvat.classes.FrameData}\n                * @instance\n                * @async\n                * @throws {module:API.cvat.exceptions.PluginError}\n            */\n\n            /**\n                * Namespace is used for an interaction with logs\n                * @namespace logs\n                * @memberof Session\n            */\n\n            /**\n                * Append log to a log collection.\n                * Continue logs will have been added after \"close\" method is called\n                * @method put\n                * @memberof Session.logs\n                * @param {module:API.cvat.enums.LogType} type a type of a log\n                * @param {boolean} continuous log is a continuous log\n                * @param {Object} details any others data which will be append to log data\n                * @returns {module:API.cvat.classes.Log}\n                * @instance\n                * @async\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n            */\n            /**\n                * Save accumulated logs on a server\n                * @method save\n                * @memberof Session.logs\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ServerError}\n                * @instance\n                * @async\n            */\n\n            /**\n                * Namespace is used for an interaction with actions\n                * @namespace actions\n                * @memberof Session\n            */\n\n            /**\n                * Is a dictionary of pairs \"id:action\" where \"id\" is an identifier of an object\n                * which has been affected by undo/redo and \"action\" is what exactly has been\n                * done with the object. Action can be: \"created\", \"deleted\", \"updated\".\n                * Size of an output array equal the param \"count\".\n                * @typedef {Object} HistoryAction\n                * @global\n            */\n            /**\n                * Undo actions\n                * @method undo\n                * @memberof Session.actions\n                * @returns {HistoryAction}\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @instance\n                * @async\n            */\n            /**\n                * Redo actions\n                * @method redo\n                * @memberof Session.actions\n                * @returns {HistoryAction}\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @instance\n                * @async\n            */\n\n\n            /**\n                * Namespace is used for an interaction with events\n                * @namespace events\n                * @memberof Session\n            */\n            /**\n                * Subscribe on an event\n                * @method subscribe\n                * @memberof Session.events\n                * @param {module:API.cvat.enums.EventType} type - event type\n                * @param {functions} callback - function which will be called on event\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n                * @instance\n                * @async\n            */\n            /**\n                * Unsubscribe from an event. If callback is not provided,\n                * all callbacks will be removed from subscribers for the event\n                * @method unsubscribe\n                * @memberof Session.events\n                * @param {module:API.cvat.enums.EventType} type - event type\n                * @param {functions} [callback = null] - function which is called on event\n                * @throws {module:API.cvat.exceptions.PluginError}\n                * @throws {module:API.cvat.exceptions.ArgumentError}\n                * @instance\n                * @async\n            */\n        }\n    }\n\n    /**\n        * Class representing a job.\n        * @memberof module:API.cvat.classes\n        * @hideconstructor\n        * @extends Session\n    */\n    class Job extends Session {\n        constructor(initialData) {\n            super();\n            const data = {\n                id: undefined,\n                assignee: undefined,\n                status: undefined,\n                start_frame: undefined,\n                stop_frame: undefined,\n                task: undefined,\n            };\n\n            for (const property in data) {\n                if (Object.prototype.hasOwnProperty.call(data, property)) {\n                    if (property in initialData) {\n                        data[property] = initialData[property];\n                    }\n\n                    if (data[property] === undefined) {\n                        throw new ArgumentError(\n                            `Job field \"${property}\" was not initialized`,\n                        );\n                    }\n                }\n            }\n\n            Object.defineProperties(this, Object.freeze({\n                /**\n                    * @name id\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Job\n                    * @readonly\n                    * @instance\n                */\n                id: {\n                    get: () => data.id,\n                },\n                /**\n                    * Identifier of a user who is responsible for the job\n                    * @name assignee\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Job\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                assignee: {\n                    get: () => data.assignee,\n                    set: () => (assignee) => {\n                        if (!Number.isInteger(assignee) || assignee < 0) {\n                            throw new ArgumentError(\n                                'Value must be a non negative integer',\n                            );\n                        }\n                        data.assignee = assignee;\n                    },\n                },\n                /**\n                    * @name status\n                    * @type {module:API.cvat.enums.TaskStatus}\n                    * @memberof module:API.cvat.classes.Job\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                status: {\n                    get: () => data.status,\n                    set: (status) => {\n                        const type = TaskStatus;\n                        let valueInEnum = false;\n                        for (const value in type) {\n                            if (type[value] === status) {\n                                valueInEnum = true;\n                                break;\n                            }\n                        }\n\n                        if (!valueInEnum) {\n                            throw new ArgumentError(\n                                'Value must be a value from the enumeration cvat.enums.TaskStatus',\n                            );\n                        }\n\n                        data.status = status;\n                    },\n                },\n                /**\n                    * @name startFrame\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Job\n                    * @readonly\n                    * @instance\n                */\n                startFrame: {\n                    get: () => data.start_frame,\n                },\n                /**\n                    * @name stopFrame\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Job\n                    * @readonly\n                    * @instance\n                */\n                stopFrame: {\n                    get: () => data.stop_frame,\n                },\n                /**\n                    * @name task\n                    * @type {module:API.cvat.classes.Task}\n                    * @memberof module:API.cvat.classes.Job\n                    * @readonly\n                    * @instance\n                */\n                task: {\n                    get: () => data.task,\n                },\n            }));\n\n            // When we call a function, for example: task.annotations.get()\n            // In the method get we lose the task context\n            // So, we need return it\n            this.annotations = {\n                get: Object.getPrototypeOf(this).annotations.get.bind(this),\n                put: Object.getPrototypeOf(this).annotations.put.bind(this),\n                save: Object.getPrototypeOf(this).annotations.save.bind(this),\n                dump: Object.getPrototypeOf(this).annotations.dump.bind(this),\n                merge: Object.getPrototypeOf(this).annotations.merge.bind(this),\n                split: Object.getPrototypeOf(this).annotations.split.bind(this),\n                group: Object.getPrototypeOf(this).annotations.group.bind(this),\n                clear: Object.getPrototypeOf(this).annotations.clear.bind(this),\n                upload: Object.getPrototypeOf(this).annotations.upload.bind(this),\n                select: Object.getPrototypeOf(this).annotations.select.bind(this),\n                statistics: Object.getPrototypeOf(this).annotations.statistics.bind(this),\n                hasUnsavedChanges: Object.getPrototypeOf(this)\n                    .annotations.hasUnsavedChanges.bind(this),\n            };\n\n            this.frames = {\n                get: Object.getPrototypeOf(this).frames.get.bind(this),\n                ranges: Object.getPrototypeOf(this).frames.ranges.bind(this),\n            };\n        }\n\n        /**\n            * Method updates job data like status or assignee\n            * @method save\n            * @memberof module:API.cvat.classes.Job\n            * @readonly\n            * @instance\n            * @async\n            * @throws {module:API.cvat.exceptions.ServerError}\n            * @throws {module:API.cvat.exceptions.PluginError}\n        */\n        async save() {\n            const result = await PluginRegistry\n                .apiWrapper.call(this, Job.prototype.save);\n            return result;\n        }\n    }\n\n    /**\n        * Class representing a task\n        * @memberof module:API.cvat.classes\n        * @extends Session\n    */\n    class Task extends Session {\n    /**\n        * In a fact you need use the constructor only if you want to create a task\n        * @param {object} initialData - Object which is used for initalization\n        * <br> It can contain keys:\n        * <br> <li style=\"margin-left: 10px;\"> name\n        * <br> <li style=\"margin-left: 10px;\"> assignee\n        * <br> <li style=\"margin-left: 10px;\"> bug_tracker\n        * <br> <li style=\"margin-left: 10px;\"> z_order\n        * <br> <li style=\"margin-left: 10px;\"> labels\n        * <br> <li style=\"margin-left: 10px;\"> segment_size\n        * <br> <li style=\"margin-left: 10px;\"> overlap\n    */\n        constructor(initialData) {\n            super();\n            const data = {\n                id: undefined,\n                name: undefined,\n                status: undefined,\n                size: undefined,\n                mode: undefined,\n                owner: undefined,\n                assignee: undefined,\n                created_date: undefined,\n                updated_date: undefined,\n                bug_tracker: undefined,\n                overlap: undefined,\n                segment_size: undefined,\n                z_order: undefined,\n                image_quality: undefined,\n                start_frame: undefined,\n                stop_frame: undefined,\n                frame_filter: undefined,\n                data_chunk_size: undefined,\n            };\n\n            for (const property in data) {\n                if (Object.prototype.hasOwnProperty.call(data, property)\n                    && property in initialData) {\n                    data[property] = initialData[property];\n                }\n            }\n\n            data.labels = [];\n            data.jobs = [];\n            data.files = Object.freeze({\n                server_files: [],\n                client_files: [],\n                remote_files: [],\n            });\n\n            if (Array.isArray(initialData.segments)) {\n                for (const segment of initialData.segments) {\n                    if (Array.isArray(segment.jobs)) {\n                        for (const job of segment.jobs) {\n                            const jobInstance = new Job({\n                                url: job.url,\n                                id: job.id,\n                                assignee: job.assignee,\n                                status: job.status,\n                                start_frame: segment.start_frame,\n                                stop_frame: segment.stop_frame,\n                                task: this,\n                            });\n                            data.jobs.push(jobInstance);\n                        }\n                    }\n                }\n            }\n\n            if (Array.isArray(initialData.labels)) {\n                for (const label of initialData.labels) {\n                    const classInstance = new Label(label);\n                    data.labels.push(classInstance);\n                }\n            }\n\n            Object.defineProperties(this, Object.freeze({\n                /**\n                    * @name id\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Task\n                    * @readonly\n                    * @instance\n                */\n                id: {\n                    get: () => data.id,\n                },\n                /**\n                    * @name name\n                    * @type {string}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                name: {\n                    get: () => data.name,\n                    set: (value) => {\n                        if (!value.trim().length) {\n                            throw new ArgumentError(\n                                'Value must not be empty',\n                            );\n                        }\n                        data.name = value;\n                    },\n                },\n                /**\n                    * @name status\n                    * @type {module:API.cvat.enums.TaskStatus}\n                    * @memberof module:API.cvat.classes.Task\n                    * @readonly\n                    * @instance\n                */\n                status: {\n                    get: () => data.status,\n                },\n                /**\n                    * @name size\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Task\n                    * @readonly\n                    * @instance\n                */\n                size: {\n                    get: () => data.size,\n                },\n                /**\n                    * @name mode\n                    * @type {TaskMode}\n                    * @memberof module:API.cvat.classes.Task\n                    * @readonly\n                    * @instance\n                */\n                mode: {\n                    get: () => data.mode,\n                },\n                /**\n                    * Identificator of a user who has created the task\n                    * @name owner\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Task\n                    * @readonly\n                    * @instance\n                */\n                owner: {\n                    get: () => data.owner,\n                },\n                /**\n                    * Identificator of a user who is responsible for the task\n                    * @name assignee\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                assignee: {\n                    get: () => data.assignee,\n                    set: () => (assignee) => {\n                        if (!Number.isInteger(assignee) || assignee < 0) {\n                            throw new ArgumentError(\n                                'Value must be a non negative integer',\n                            );\n                        }\n                        data.assignee = assignee;\n                    },\n                },\n                /**\n                    * @name createdDate\n                    * @type {string}\n                    * @memberof module:API.cvat.classes.Task\n                    * @readonly\n                    * @instance\n                */\n                createdDate: {\n                    get: () => data.created_date,\n                },\n                /**\n                    * @name updatedDate\n                    * @type {string}\n                    * @memberof module:API.cvat.classes.Task\n                    * @readonly\n                    * @instance\n                */\n                updatedDate: {\n                    get: () => data.updated_date,\n                },\n                /**\n                    * @name bugTracker\n                    * @type {string}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                bugTracker: {\n                    get: () => data.bug_tracker,\n                    set: (tracker) => {\n                        data.bug_tracker = tracker;\n                    },\n                },\n                /**\n                    * @name overlap\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                overlap: {\n                    get: () => data.overlap,\n                    set: (overlap) => {\n                        if (!Number.isInteger(overlap) || overlap < 0) {\n                            throw new ArgumentError(\n                                'Value must be a non negative integer',\n                            );\n                        }\n                        data.overlap = overlap;\n                    },\n                },\n                /**\n                    * @name segmentSize\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                segmentSize: {\n                    get: () => data.segment_size,\n                    set: (segment) => {\n                        if (!Number.isInteger(segment) || segment < 0) {\n                            throw new ArgumentError(\n                                'Value must be a positive integer',\n                            );\n                        }\n                        data.segment_size = segment;\n                    },\n                },\n                /**\n                    * @name zOrder\n                    * @type {boolean}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                zOrder: {\n                    get: () => data.z_order,\n                    set: (zOrder) => {\n                        if (typeof (zOrder) !== 'boolean') {\n                            throw new ArgumentError(\n                                'Value must be a boolean',\n                            );\n                        }\n                        data.z_order = zOrder;\n                    },\n                },\n                /**\n                    * @name imageQuality\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                imageQuality: {\n                    get: () => data.image_quality,\n                    set: (quality) => {\n                        if (!Number.isInteger(quality) || quality < 0) {\n                            throw new ArgumentError(\n                                'Value must be a positive integer',\n                            );\n                        }\n                        data.image_quality = quality;\n                    },\n                },\n                /**\n                    * After task has been created value can be appended only.\n                    * @name labels\n                    * @type {module:API.cvat.classes.Label[]}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                labels: {\n                    get: () => [...data.labels],\n                    set: (labels) => {\n                        if (!Array.isArray(labels)) {\n                            throw new ArgumentError(\n                                'Value must be an array of Labels',\n                            );\n                        }\n\n                        for (const label of labels) {\n                            if (!(label instanceof Label)) {\n                                throw new ArgumentError(\n                                    'Each array value must be an instance of Label. '\n                                        + `${typeof (label)} was found`,\n                                );\n                            }\n                        }\n\n                        if (typeof (data.id) === 'undefined') {\n                            data.labels = [...labels];\n                        } else {\n                            data.labels = data.labels.concat([...labels]);\n                        }\n                    },\n                },\n                /**\n                    * @name jobs\n                    * @type {module:API.cvat.classes.Job[]}\n                    * @memberof module:API.cvat.classes.Task\n                    * @readonly\n                    * @instance\n                */\n                jobs: {\n                    get: () => [...data.jobs],\n                },\n                /**\n                    * List of files from shared resource\n                    * @name serverFiles\n                    * @type {string[]}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                serverFiles: {\n                    get: () => [...data.files.server_files],\n                    set: (serverFiles) => {\n                        if (!Array.isArray(serverFiles)) {\n                            throw new ArgumentError(\n                                `Value must be an array. But ${typeof (serverFiles)} has been got.`,\n                            );\n                        }\n\n                        for (const value of serverFiles) {\n                            if (typeof (value) !== 'string') {\n                                throw new ArgumentError(\n                                    `Array values must be a string. But ${typeof (value)} has been got.`,\n                                );\n                            }\n                        }\n\n                        Array.prototype.push.apply(data.files.server_files, serverFiles);\n                    },\n                },\n                /**\n                    * List of files from client host\n                    * @name clientFiles\n                    * @type {File[]}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                clientFiles: {\n                    get: () => [...data.files.client_files],\n                    set: (clientFiles) => {\n                        if (!Array.isArray(clientFiles)) {\n                            throw new ArgumentError(\n                                `Value must be an array. But ${typeof (clientFiles)} has been got.`,\n                            );\n                        }\n\n                        for (const value of clientFiles) {\n                            if (!(value instanceof File)) {\n                                throw new ArgumentError(\n                                    `Array values must be a File. But ${value.constructor.name} has been got.`,\n                                );\n                            }\n                        }\n\n                        Array.prototype.push.apply(data.files.client_files, clientFiles);\n                    },\n                },\n                /**\n                    * List of files from remote host\n                    * @name remoteFiles\n                    * @type {File[]}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                remoteFiles: {\n                    get: () => [...data.files.remote_files],\n                    set: (remoteFiles) => {\n                        if (!Array.isArray(remoteFiles)) {\n                            throw new ArgumentError(\n                                `Value must be an array. But ${typeof (remoteFiles)} has been got.`,\n                            );\n                        }\n\n                        for (const value of remoteFiles) {\n                            if (typeof (value) !== 'string') {\n                                throw new ArgumentError(\n                                    `Array values must be a string. But ${typeof (value)} has been got.`,\n                                );\n                            }\n                        }\n\n                        Array.prototype.push.apply(data.files.remote_files, remoteFiles);\n                    },\n                },\n                /**\n                    * The first frame of a video to annotation\n                    * @name startFrame\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                startFrame: {\n                    get: () => data.start_frame,\n                    set: (frame) => {\n                        if (!Number.isInteger(frame) || frame < 0) {\n                            throw new ArgumentError(\n                                'Value must be a not negative integer',\n                            );\n                        }\n                        data.start_frame = frame;\n                    },\n                },\n                /**\n                    * The last frame of a video to annotation\n                    * @name stopFrame\n                    * @type {integer}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                stopFrame: {\n                    get: () => data.stop_frame,\n                    set: (frame) => {\n                        if (!Number.isInteger(frame) || frame < 0) {\n                            throw new ArgumentError(\n                                'Value must be a not negative integer',\n                            );\n                        }\n                        data.stop_frame = frame;\n                    },\n                },\n                /**\n                    * Filter to ignore some frames during task creation\n                    * @name frameFilter\n                    * @type {string}\n                    * @memberof module:API.cvat.classes.Task\n                    * @instance\n                    * @throws {module:API.cvat.exceptions.ArgumentError}\n                */\n                frameFilter: {\n                    get: () => data.frame_filter,\n                    set: (filter) => {\n                        if (typeof (filter) !== 'string') {\n                            throw new ArgumentError(\n                                `Filter value must be a string. But ${typeof (filter)} has been got.`,\n                            );\n                        }\n\n                        data.frame_filter = filter;\n                    },\n                },\n                dataChunkSize: {\n                    get: () => data.data_chunk_size,\n                    set: (chunkSize) => {\n                        if (typeof (chunkSize) !== 'number' || chunkSize < 1) {\n                            throw new ArgumentError(\n                                `Chink size value must be a positive number. But value ${chunkSize} has been got.`,\n                            );\n                        }\n\n                        data.data_chunk_size = chunkSize;\n                    },\n                },\n            }));\n\n            // When we call a function, for example: task.annotations.get()\n            // In the method get we lose the task context\n            // So, we need return it\n            this.annotations = {\n                get: Object.getPrototypeOf(this).annotations.get.bind(this),\n                put: Object.getPrototypeOf(this).annotations.put.bind(this),\n                save: Object.getPrototypeOf(this).annotations.save.bind(this),\n                dump: Object.getPrototypeOf(this).annotations.dump.bind(this),\n                merge: Object.getPrototypeOf(this).annotations.merge.bind(this),\n                split: Object.getPrototypeOf(this).annotations.split.bind(this),\n                group: Object.getPrototypeOf(this).annotations.group.bind(this),\n                clear: Object.getPrototypeOf(this).annotations.clear.bind(this),\n                upload: Object.getPrototypeOf(this).annotations.upload.bind(this),\n                select: Object.getPrototypeOf(this).annotations.select.bind(this),\n                statistics: Object.getPrototypeOf(this).annotations.statistics.bind(this),\n                hasUnsavedChanges: Object.getPrototypeOf(this)\n                    .annotations.hasUnsavedChanges.bind(this),\n            };\n\n            this.frames = {\n                get: Object.getPrototypeOf(this).frames.get.bind(this),\n                ranges: Object.getPrototypeOf(this).frames.ranges.bind(this),\n            };\n        }\n\n        /**\n            * Method updates data of a created task or creates new task from scratch\n            * @method save\n            * @returns {module:API.cvat.classes.Task}\n            * @memberof module:API.cvat.classes.Task\n            * @param {function} [onUpdate] - the function which is used only if task hasn't\n            * been created yet. It called in order to notify about creation status.\n            * It receives the string parameter which is a status message\n            * @readonly\n            * @instance\n            * @async\n            * @throws {module:API.cvat.exceptions.ServerError}\n            * @throws {module:API.cvat.exceptions.PluginError}\n        */\n        async save(onUpdate = () => {}) {\n            const result = await PluginRegistry\n                .apiWrapper.call(this, Task.prototype.save, onUpdate);\n            return result;\n        }\n\n        /**\n            * Method deletes a task from a server\n            * @method delete\n            * @memberof module:API.cvat.classes.Task\n            * @readonly\n            * @instance\n            * @async\n            * @throws {module:API.cvat.exceptions.ServerError}\n            * @throws {module:API.cvat.exceptions.PluginError}\n        */\n        async delete() {\n            const result = await PluginRegistry\n                .apiWrapper.call(this, Task.prototype.delete);\n            return result;\n        }\n    }\n\n    module.exports = {\n        Job,\n        Task,\n    };\n\n    const {\n        getAnnotations,\n        putAnnotations,\n        saveAnnotations,\n        hasUnsavedChanges,\n        mergeAnnotations,\n        splitAnnotations,\n        groupAnnotations,\n        clearAnnotations,\n        selectObject,\n        annotationsStatistics,\n        uploadAnnotations,\n        dumpAnnotations,\n    } = require('./annotations');\n\n    buildDublicatedAPI(Job.prototype);\n    buildDublicatedAPI(Task.prototype);\n\n    Job.prototype.save.implementation = async function () {\n        // TODO: Add ability to change an assignee\n        if (this.id) {\n            const jobData = {\n                status: this.status,\n            };\n\n            await serverProxy.jobs.saveJob(this.id, jobData);\n            return this;\n        }\n\n        throw new ArgumentError(\n            'Can not save job without and id',\n        );\n    };\n\n    Job.prototype.frames.get.implementation = async function (frame) {\n        if (!Number.isInteger(frame) || frame < 0) {\n            throw new ArgumentError(\n                `Frame must be a positive integer. Got: \"${frame}\"`,\n            );\n        }\n\n        if (frame < this.startFrame || frame > this.stopFrame) {\n            throw new ArgumentError(\n                `The frame with number ${frame} is out of the job`,\n            );\n        }\n\n        const frameData = await getFrame(\n            this.task.id,\n            this.task.dataChunkSize,\n            this.task.mode,\n            frame,\n        );\n        return frameData;\n    };\n\n    Job.prototype.frames.ranges.implementation = async function () {\n        const rangesData = await getRanges(\n            this.task.id,\n        );\n        return rangesData;\n    };\n\n    // TODO: Check filter for annotations\n    Job.prototype.annotations.get.implementation = async function (frame, filter) {\n        if (frame < this.startFrame || frame > this.stopFrame) {\n            throw new ArgumentError(\n                `Frame ${frame} does not exist in the job`,\n            );\n        }\n\n        const annotationsData = await getAnnotations(this, frame, filter);\n        return annotationsData;\n    };\n\n    Job.prototype.annotations.save.implementation = async function (onUpdate) {\n        const result = await saveAnnotations(this, onUpdate);\n        return result;\n    };\n\n    Job.prototype.annotations.merge.implementation = async function (objectStates) {\n        const result = await mergeAnnotations(this, objectStates);\n        return result;\n    };\n\n    Job.prototype.annotations.split.implementation = async function (objectState, frame) {\n        const result = await splitAnnotations(this, objectState, frame);\n        return result;\n    };\n\n    Job.prototype.annotations.group.implementation = async function (objectStates, reset) {\n        const result = await groupAnnotations(this, objectStates, reset);\n        return result;\n    };\n\n    Job.prototype.annotations.hasUnsavedChanges.implementation = function () {\n        const result = hasUnsavedChanges(this);\n        return result;\n    };\n\n    Job.prototype.annotations.clear.implementation = async function (reload) {\n        const result = await clearAnnotations(this, reload);\n        return result;\n    };\n\n    Job.prototype.annotations.select.implementation = function (frame, x, y) {\n        const result = selectObject(this, frame, x, y);\n        return result;\n    };\n\n    Job.prototype.annotations.statistics.implementation = function () {\n        const result = annotationsStatistics(this);\n        return result;\n    };\n\n    Job.prototype.annotations.put.implementation = function (objectStates) {\n        const result = putAnnotations(this, objectStates);\n        return result;\n    };\n\n    Job.prototype.annotations.upload.implementation = async function (file, loader) {\n        const result = await uploadAnnotations(this, file, loader);\n        return result;\n    };\n\n    Job.prototype.annotations.dump.implementation = async function (name, dumper) {\n        const result = await dumpAnnotations(this, name, dumper);\n        return result;\n    };\n\n    Task.prototype.save.implementation = async function saveTaskImplementation(onUpdate) {\n        // TODO: Add ability to change an owner and an assignee\n        if (typeof (this.id) !== 'undefined') {\n            // If the task has been already created, we update it\n            const taskData = {\n                name: this.name,\n                bug_tracker: this.bugTracker,\n                z_order: this.zOrder,\n                labels: [...this.labels.map(el => el.toJSON())],\n            };\n\n            await serverProxy.tasks.saveTask(this.id, taskData);\n            return this;\n        }\n\n        const taskData = {\n            name: this.name,\n            labels: this.labels.map(el => el.toJSON()),\n            image_quality: this.imageQuality,\n            z_order: Boolean(this.zOrder),\n        };\n\n        if (typeof (this.bugTracker) !== 'undefined') {\n            taskData.bug_tracker = this.bugTracker;\n        }\n        if (typeof (this.segmentSize) !== 'undefined') {\n            taskData.segment_size = this.segmentSize;\n        }\n        if (typeof (this.overlap) !== 'undefined') {\n            taskData.overlap = this.overlap;\n        }\n        if (typeof (this.startFrame) !== 'undefined') {\n            taskData.start_frame = this.startFrame;\n        }\n        if (typeof (this.stopFrame) !== 'undefined') {\n            taskData.stop_frame = this.stopFrame;\n        }\n        if (typeof (this.frameFilter) !== 'undefined') {\n            taskData.frame_filter = this.frameFilter;\n        }\n\n        const taskFiles = {\n            client_files: this.clientFiles,\n            server_files: this.serverFiles,\n            remote_files: this.remoteFiles,\n        };\n\n        const task = await serverProxy.tasks.createTask(taskData, taskFiles, onUpdate);\n        return new Task(task);\n    };\n\n    Task.prototype.delete.implementation = async function () {\n        const result = await serverProxy.tasks.deleteTask(this.id);\n        return result;\n    };\n\n    Task.prototype.frames.get.implementation = async function (frame) {\n        if (!Number.isInteger(frame) || frame < 0) {\n            throw new ArgumentError(\n                `Frame must be a positive integer. Got: \"${frame}\"`,\n            );\n        }\n\n        if (frame >= this.size) {\n            throw new ArgumentError(\n                `The frame with number ${frame} is out of the task`,\n            );\n        }\n\n        const result = await getFrame(\n            this.id,\n            this.dataChunkSize,\n            this.mode,\n            frame,\n        );\n        return result;\n    };\n\n    Task.prototype.frames.ranges.implementation = async function () {\n        const rangesData = await getRanges(\n            this.id,\n        );\n        return rangesData;\n    };\n\n    // TODO: Check filter for annotations\n    Task.prototype.annotations.get.implementation = async function (frame, filter) {\n        if (!Number.isInteger(frame) || frame < 0) {\n            throw new ArgumentError(\n                `Frame must be a positive integer. Got: \"${frame}\"`,\n            );\n        }\n\n        if (frame >= this.size) {\n            throw new ArgumentError(\n                `Frame ${frame} does not exist in the task`,\n            );\n        }\n\n        const result = await getAnnotations(this, frame, filter);\n        return result;\n    };\n\n    Task.prototype.annotations.save.implementation = async function (onUpdate) {\n        const result = await saveAnnotations(this, onUpdate);\n        return result;\n    };\n\n    Task.prototype.annotations.merge.implementation = async function (objectStates) {\n        const result = await mergeAnnotations(this, objectStates);\n        return result;\n    };\n\n    Task.prototype.annotations.split.implementation = async function (objectState, frame) {\n        const result = await splitAnnotations(this, objectState, frame);\n        return result;\n    };\n\n    Task.prototype.annotations.group.implementation = async function (objectStates, reset) {\n        const result = await groupAnnotations(this, objectStates, reset);\n        return result;\n    };\n\n    Task.prototype.annotations.hasUnsavedChanges.implementation = function () {\n        const result = hasUnsavedChanges(this);\n        return result;\n    };\n\n    Task.prototype.annotations.clear.implementation = async function (reload) {\n        const result = await clearAnnotations(this, reload);\n        return result;\n    };\n\n    Task.prototype.annotations.select.implementation = function (frame, x, y) {\n        const result = selectObject(this, frame, x, y);\n        return result;\n    };\n\n    Task.prototype.annotations.statistics.implementation = function () {\n        const result = annotationsStatistics(this);\n        return result;\n    };\n\n    Task.prototype.annotations.put.implementation = function (objectStates) {\n        const result = putAnnotations(this, objectStates);\n        return result;\n    };\n\n    Task.prototype.annotations.upload.implementation = async function (file, loader) {\n        const result = await uploadAnnotations(this, file, loader);\n        return result;\n    };\n\n    Task.prototype.annotations.dump.implementation = async function (name, dumper) {\n        const result = await dumpAnnotations(this, name, dumper);\n        return result;\n    };\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n\n(() => {\n    /**\n        * Class representing collection statistics\n        * @memberof module:API.cvat.classes\n        * @hideconstructor\n    */\n    class Statistics {\n        constructor(label, total) {\n            Object.defineProperties(this, Object.freeze({\n                /**\n                    * Statistics by labels with a structure:\n                    * @example\n                    * {\n                    *     label: {\n                    *         boxes: {\n                    *             tracks: 10,\n                    *             shapes: 11,\n                    *         },\n                    *         polygons: {\n                    *             tracks: 13,\n                    *             shapes: 14,\n                    *         },\n                    *         polylines: {\n                    *             tracks: 16,\n                    *             shapes: 17,\n                    *         },\n                    *         points: {\n                    *             tracks: 19,\n                    *             shapes: 20,\n                    *         },\n                    *         tags: 66,\n                    *         manually: 186,\n                    *         interpolated: 500,\n                    *         total: 608,\n                    *     }\n                    * }\n                    * @name label\n                    * @type {Object}\n                    * @memberof module:API.cvat.classes.Statistics\n                    * @readonly\n                    * @instance\n                */\n                label: {\n                    get: () => JSON.parse(JSON.stringify(label)),\n                },\n                /**\n                    * Total statistics (covers all labels) with a structure:\n                    * @example\n                    * {\n                    *     boxes: {\n                    *             tracks: 10,\n                    *             shapes: 11,\n                    *     },\n                    *     polygons: {\n                    *         tracks: 13,\n                    *         shapes: 14,\n                    *     },\n                    *     polylines: {\n                    *        tracks: 16,\n                    *        shapes: 17,\n                    *    },\n                    *    points: {\n                    *        tracks: 19,\n                    *        shapes: 20,\n                    *    },\n                    *    tags: 66,\n                    *    manually: 186,\n                    *    interpolated: 500,\n                    *    total: 608,\n                    * }\n                    * @name total\n                    * @type {Object}\n                    * @memberof module:API.cvat.classes.Statistics\n                    * @readonly\n                    * @instance\n                */\n                total: {\n                    get: () => JSON.parse(JSON.stringify(total)),\n                },\n            }));\n        }\n    }\n\n    module.exports = Statistics;\n})();\n","/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n(() => {\n    /**\n        * Class representing a user\n        * @memberof module:API.cvat.classes\n        * @hideconstructor\n    */\n    class User {\n        constructor(initialData) {\n            const data = {\n                id: null,\n                username: null,\n                email: null,\n                first_name: null,\n                last_name: null,\n                groups: null,\n                last_login: null,\n                date_joined: null,\n                is_staff: null,\n                is_superuser: null,\n                is_active: null,\n            };\n\n            for (const property in data) {\n                if (Object.prototype.hasOwnProperty.call(data, property)\n                    && property in initialData) {\n                    data[property] = initialData[property];\n                }\n            }\n\n            Object.defineProperties(this, Object.freeze({\n                id: {\n                    /**\n                        * @name id\n                        * @type {integer}\n                        * @memberof module:API.cvat.classes.User\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.id,\n                },\n                username: {\n                    /**\n                        * @name username\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.User\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.username,\n                },\n                email: {\n                    /**\n                        * @name email\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.User\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.email,\n                },\n                firstName: {\n                    /**\n                        * @name firstName\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.User\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.first_name,\n                },\n                lastName: {\n                    /**\n                        * @name lastName\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.User\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.last_name,\n                },\n                groups: {\n                    /**\n                        * @name groups\n                        * @type {string[]}\n                        * @memberof module:API.cvat.classes.User\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => JSON.parse(JSON.stringify(data.groups)),\n                },\n                lastLogin: {\n                    /**\n                        * @name lastLogin\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.User\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.last_login,\n                },\n                dateJoined: {\n                    /**\n                        * @name dateJoined\n                        * @type {string}\n                        * @memberof module:API.cvat.classes.User\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.date_joined,\n                },\n                isStaff: {\n                    /**\n                        * @name isStaff\n                        * @type {boolean}\n                        * @memberof module:API.cvat.classes.User\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.is_staff,\n                },\n                isSuperuser: {\n                    /**\n                        * @name isSuperuser\n                        * @type {boolean}\n                        * @memberof module:API.cvat.classes.User\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.is_superuser,\n                },\n                isActive: {\n                    /**\n                        * @name isActive\n                        * @type {boolean}\n                        * @memberof module:API.cvat.classes.User\n                        * @readonly\n                        * @instance\n                    */\n                    get: () => data.is_active,\n                },\n            }));\n        }\n    }\n\n    module.exports = User;\n})();\n","module.exports = require(\"assert\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"stream\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");"],"sourceRoot":""}