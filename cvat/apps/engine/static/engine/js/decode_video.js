/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/decode_video.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\nmodule.exports = function (it) {\n  if (!isObject(it) && it !== null) {\n    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n  } return it;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/a-possible-prototype.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\nvar create = __webpack_require__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\nvar hide = __webpack_require__(/*! ../internals/hide */ \"./node_modules/core-js/internals/hide.js\");\n\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  hide(ArrayPrototype, UNSCOPABLES, create(null));\n}\n\n// add a key to Array.prototype[@@unscopables]\nmodule.exports = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/add-to-unscopables.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\nmodule.exports = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + ' is not an object');\n  } return it;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/an-object.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\nvar toLength = __webpack_require__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\nvar toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ \"./node_modules/core-js/internals/to-absolute-index.js\");\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/array-includes.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/classof-raw.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var has = __webpack_require__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\nvar ownKeys = __webpack_require__(/*! ../internals/own-keys */ \"./node_modules/core-js/internals/own-keys.js\");\nvar getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/copy-constructor-properties.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nmodule.exports = !fails(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/correct-prototype-getter.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/create-iterator-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ \"./node_modules/core-js/internals/iterators-core.js\").IteratorPrototype;\nvar create = __webpack_require__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ \"./node_modules/core-js/internals/set-to-string-tag.js\");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (IteratorConstructor, NAME, next) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/create-iterator-constructor.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/create-property-descriptor.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/define-iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar $ = __webpack_require__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\nvar createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ \"./node_modules/core-js/internals/create-iterator-constructor.js\");\nvar getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ \"./node_modules/core-js/internals/object-get-prototype-of.js\");\nvar setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ \"./node_modules/core-js/internals/object-set-prototype-of.js\");\nvar setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ \"./node_modules/core-js/internals/set-to-string-tag.js\");\nvar hide = __webpack_require__(/*! ../internals/hide */ \"./node_modules/core-js/internals/hide.js\");\nvar redefine = __webpack_require__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\nvar IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ \"./node_modules/core-js/internals/iterators-core.js\");\n\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf) {\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {\n          hide(CurrentIteratorPrototype, ITERATOR, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    INCORRECT_VALUES_NAME = true;\n    defaultIterator = function values() { return nativeIterator.call(this); };\n  }\n\n  // define iterator\n  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n    hide(IterablePrototype, ITERATOR, defaultIterator);\n  }\n  Iterators[NAME] = defaultIterator;\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        redefine(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  return methods;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/define-iterator.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !fails(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/descriptors.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/document-create-element.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/dom-iterables.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nmodule.exports = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/dom-iterables.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/enum-bug-keys.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\").f;\nvar hide = __webpack_require__(/*! ../internals/hide */ \"./node_modules/core-js/internals/hide.js\");\nvar redefine = __webpack_require__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\nvar copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ \"./node_modules/core-js/internals/copy-constructor-properties.js\");\nvar isForced = __webpack_require__(/*! ../internals/is-forced */ \"./node_modules/core-js/internals/is-forced.js\");\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      hide(sourceProperty, 'sham', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/export.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/fails.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/function-to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/function-to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var shared = __webpack_require__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\n\nmodule.exports = shared('native-function-to-string', Function.toString);\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/function-to-string.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var path = __webpack_require__(/*! ../internals/path */ \"./node_modules/core-js/internals/path.js\");\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n\nvar aFunction = function (variable) {\n  return typeof variable == 'function' ? variable : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])\n    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/get-built-in.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var O = 'object';\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line no-undef\n  check(typeof globalThis == O && globalThis) ||\n  check(typeof window == O && window) ||\n  check(typeof self == O && self) ||\n  check(typeof global == O && global) ||\n  // eslint-disable-next-line no-new-func\n  Function('return this')();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/global.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/has.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/has.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/hidden-keys.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/hide.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/hide.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/hide.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/html.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar createElement = __webpack_require__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/ie8-dom-define.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\nvar classof = __webpack_require__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n\nvar split = ''.split;\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/indexed-object.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ \"./node_modules/core-js/internals/native-weak-map.js\");\nvar global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\nvar hide = __webpack_require__(/*! ../internals/hide */ \"./node_modules/core-js/internals/hide.js\");\nvar objectHas = __webpack_require__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP) {\n  var store = new WeakMap();\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    hide(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/internal-state.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : typeof detection == 'function' ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-forced.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-object.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = false;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/is-pure.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ \"./node_modules/core-js/internals/object-get-prototype-of.js\");\nvar hide = __webpack_require__(/*! ../internals/hide */ \"./node_modules/core-js/internals/hide.js\");\nvar has = __webpack_require__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar BUGGY_SAFARI_ITERATORS = false;\n\nvar returnThis = function () { return this; };\n\n// `%IteratorPrototype%` object\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nif (IteratorPrototype == undefined) IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nif (!IS_PURE && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n\nmodule.exports = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterators-core.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/iterators.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/native-symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var fails = __webpack_require__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  // Chrome 38 Symbol has incorrect toString conversion\n  // eslint-disable-next-line no-undef\n  return !String(Symbol());\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/native-symbol.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/native-weak-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ \"./node_modules/core-js/internals/function-to-string.js\");\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = typeof WeakMap === 'function' && /native code/.test(nativeFunctionToString.call(WeakMap));\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/native-weak-map.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ \"./node_modules/core-js/internals/object-define-properties.js\");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\nvar html = __webpack_require__(/*! ../internals/html */ \"./node_modules/core-js/internals/html.js\");\nvar documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar PROTOTYPE = 'prototype';\nvar Empty = function () { /* empty */ };\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var length = enumBugKeys.length;\n  var lt = '<';\n  var script = 'script';\n  var gt = '>';\n  var js = 'java' + script + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  iframe.src = String(js);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];\n  return createDict();\n};\n\n// `Object.create` method\n// https://tc39.github.io/ecma262/#sec-object.create\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-create.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar objectKeys = __webpack_require__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n\n// `Object.defineProperties` method\n// https://tc39.github.io/ecma262/#sec-object.defineproperties\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);\n  return O;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-define-properties.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\n\nvar nativeDefineProperty = Object.defineProperty;\n\n// `Object.defineProperty` method\n// https://tc39.github.io/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return nativeDefineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-define-property.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\nvar propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ \"./node_modules/core-js/internals/object-property-is-enumerable.js\");\nvar createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\nvar toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\nvar has = __webpack_require__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\nvar IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\n\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return nativeGetOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-own-property-descriptor.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.github.io/ecma262/#sec-object.getownpropertynames\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-own-property-names.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.f = Object.getOwnPropertySymbols;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-own-property-symbols.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var has = __webpack_require__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\nvar toObject = __webpack_require__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\nvar sharedKey = __webpack_require__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\nvar CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ \"./node_modules/core-js/internals/correct-prototype-getter.js\");\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar ObjectPrototype = Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.github.io/ecma262/#sec-object.getprototypeof\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectPrototype : null;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-get-prototype-of.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var has = __webpack_require__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\nvar indexOf = __webpack_require__(/*! ../internals/array-includes */ \"./node_modules/core-js/internals/array-includes.js\").indexOf;\nvar hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-keys-internal.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\nvar enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n\n// `Object.keys` method\n// https://tc39.github.io/ecma262/#sec-object.keys\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-keys.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : nativePropertyIsEnumerable;\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-property-is-enumerable.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\nvar aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ \"./node_modules/core-js/internals/a-possible-prototype.js\");\n\n// `Object.setPrototypeOf` method\n// https://tc39.github.io/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n    setter.call(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter.call(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/object-set-prototype-of.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\nvar getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\");\nvar getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\");\nvar anObject = __webpack_require__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/own-keys.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/path.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/redefine.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar shared = __webpack_require__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\nvar hide = __webpack_require__(/*! ../internals/hide */ \"./node_modules/core-js/internals/hide.js\");\nvar has = __webpack_require__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\nvar nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ \"./node_modules/core-js/internals/function-to-string.js\");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(nativeFunctionToString).split('toString');\n\nshared('inspectSource', function (it) {\n  return nativeFunctionToString.call(it);\n});\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  if (typeof value == 'function') {\n    if (typeof key == 'string' && !has(value, 'name')) hide(value, 'name', key);\n    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else hide(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return typeof this == 'function' && getInternalState(this).source || nativeFunctionToString.call(this);\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/redefine.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// `RequireObjectCoercible` abstract operation\n// https://tc39.github.io/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/require-object-coercible.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/set-global.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar hide = __webpack_require__(/*! ../internals/hide */ \"./node_modules/core-js/internals/hide.js\");\n\nmodule.exports = function (key, value) {\n  try {\n    hide(global, key, value);\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/set-global.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\nvar has = __webpack_require__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\nmodule.exports = function (it, TAG, STATIC) {\n  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/set-to-string-tag.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var shared = __webpack_require__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\nvar uid = __webpack_require__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/shared-key.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar setGlobal = __webpack_require__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\nvar IS_PURE = __webpack_require__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.2.1',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: ' 2019 Denis Pushkarev (zloirock.ru)'\n});\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/shared.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toInteger = __webpack_require__(/*! ../internals/to-integer */ \"./node_modules/core-js/internals/to-integer.js\");\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-absolute-index.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\nvar requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-indexed-object.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-integer.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.github.io/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-integer.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toInteger = __webpack_require__(/*! ../internals/to-integer */ \"./node_modules/core-js/internals/to-integer.js\");\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.github.io/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-length.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n\n// `ToObject` abstract operation\n// https://tc39.github.io/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-object.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var isObject = __webpack_require__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n\n// `ToPrimitive` abstract operation\n// https://tc39.github.io/ecma262/#sec-toprimitive\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (input, PREFERRED_STRING) {\n  if (!isObject(input)) return input;\n  var fn, val;\n  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/to-primitive.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/uid.js?");

/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar shared = __webpack_require__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\nvar uid = __webpack_require__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\nvar NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ \"./node_modules/core-js/internals/native-symbol.js\");\n\nvar Symbol = global.Symbol;\nvar store = shared('wks');\n\nmodule.exports = function (name) {\n  return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name]\n    || (NATIVE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n\n//# sourceURL=webpack:///./node_modules/core-js/internals/well-known-symbol.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/es.array.iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\nvar addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ \"./node_modules/core-js/internals/add-to-unscopables.js\");\nvar Iterators = __webpack_require__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\nvar InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\nvar defineIterator = __webpack_require__(/*! ../internals/define-iterator */ \"./node_modules/core-js/internals/define-iterator.js\");\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.github.io/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.github.io/ecma262/#sec-createarrayiterator\nmodule.exports = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject\nIterators.Arguments = Iterators.Array;\n\n// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/es.array.iterator.js?");

/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.iterator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var global = __webpack_require__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\nvar DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ \"./node_modules/core-js/internals/dom-iterables.js\");\nvar ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ \"./node_modules/core-js/modules/es.array.iterator.js\");\nvar hide = __webpack_require__(/*! ../internals/hide */ \"./node_modules/core-js/internals/hide.js\");\nvar wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  var Collection = global[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n      hide(CollectionPrototype, ITERATOR, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG]) hide(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        hide(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/core-js/modules/web.dom-collections.iterator.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/jpeg-js/index.js":
/*!***************************************!*\
  !*** ./node_modules/jpeg-js/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var encode = __webpack_require__(/*! ./lib/encoder */ \"./node_modules/jpeg-js/lib/encoder.js\"),\n    decode = __webpack_require__(/*! ./lib/decoder */ \"./node_modules/jpeg-js/lib/decoder.js\");\n\nmodule.exports = {\n  encode: encode,\n  decode: decode\n};\n\n\n//# sourceURL=webpack:///./node_modules/jpeg-js/index.js?");

/***/ }),

/***/ "./node_modules/jpeg-js/lib/decoder.js":
/*!*********************************************!*\
  !*** ./node_modules/jpeg-js/lib/decoder.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nvar JpegImage = (function jpegImage() {\n  \"use strict\";\n  var dctZigZag = new Int32Array([\n     0,\n     1,  8,\n    16,  9,  2,\n     3, 10, 17, 24,\n    32, 25, 18, 11, 4,\n     5, 12, 19, 26, 33, 40,\n    48, 41, 34, 27, 20, 13,  6,\n     7, 14, 21, 28, 35, 42, 49, 56,\n    57, 50, 43, 36, 29, 22, 15,\n    23, 30, 37, 44, 51, 58,\n    59, 52, 45, 38, 31,\n    39, 46, 53, 60,\n    61, 54, 47,\n    55, 62,\n    63\n  ]);\n\n  var dctCos1  =  4017   // cos(pi/16)\n  var dctSin1  =   799   // sin(pi/16)\n  var dctCos3  =  3406   // cos(3*pi/16)\n  var dctSin3  =  2276   // sin(3*pi/16)\n  var dctCos6  =  1567   // cos(6*pi/16)\n  var dctSin6  =  3784   // sin(6*pi/16)\n  var dctSqrt2 =  5793   // sqrt(2)\n  var dctSqrt1d2 = 2896  // sqrt(2) / 2\n\n  function constructor() {\n  }\n\n  function buildHuffmanTable(codeLengths, values) {\n    var k = 0, code = [], i, j, length = 16;\n    while (length > 0 && !codeLengths[length - 1])\n      length--;\n    code.push({children: [], index: 0});\n    var p = code[0], q;\n    for (i = 0; i < length; i++) {\n      for (j = 0; j < codeLengths[i]; j++) {\n        p = code.pop();\n        p.children[p.index] = values[k];\n        while (p.index > 0) {\n          p = code.pop();\n        }\n        p.index++;\n        code.push(p);\n        while (code.length <= i) {\n          code.push(q = {children: [], index: 0});\n          p.children[p.index] = q.children;\n          p = q;\n        }\n        k++;\n      }\n      if (i + 1 < length) {\n        // p here points to last code\n        code.push(q = {children: [], index: 0});\n        p.children[p.index] = q.children;\n        p = q;\n      }\n    }\n    return code[0].children;\n  }\n\n  function decodeScan(data, offset,\n                      frame, components, resetInterval,\n                      spectralStart, spectralEnd,\n                      successivePrev, successive) {\n    var precision = frame.precision;\n    var samplesPerLine = frame.samplesPerLine;\n    var scanLines = frame.scanLines;\n    var mcusPerLine = frame.mcusPerLine;\n    var progressive = frame.progressive;\n    var maxH = frame.maxH, maxV = frame.maxV;\n\n    var startOffset = offset, bitsData = 0, bitsCount = 0;\n    function readBit() {\n      if (bitsCount > 0) {\n        bitsCount--;\n        return (bitsData >> bitsCount) & 1;\n      }\n      bitsData = data[offset++];\n      if (bitsData == 0xFF) {\n        var nextByte = data[offset++];\n        if (nextByte) {\n          throw new Error(\"unexpected marker: \" + ((bitsData << 8) | nextByte).toString(16));\n        }\n        // unstuff 0\n      }\n      bitsCount = 7;\n      return bitsData >>> 7;\n    }\n    function decodeHuffman(tree) {\n      var node = tree, bit;\n      while ((bit = readBit()) !== null) {\n        node = node[bit];\n        if (typeof node === 'number')\n          return node;\n        if (typeof node !== 'object')\n          throw new Error(\"invalid huffman sequence\");\n      }\n      return null;\n    }\n    function receive(length) {\n      var n = 0;\n      while (length > 0) {\n        var bit = readBit();\n        if (bit === null) return;\n        n = (n << 1) | bit;\n        length--;\n      }\n      return n;\n    }\n    function receiveAndExtend(length) {\n      var n = receive(length);\n      if (n >= 1 << (length - 1))\n        return n;\n      return n + (-1 << length) + 1;\n    }\n    function decodeBaseline(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : receiveAndExtend(t);\n      zz[0]= (component.pred += diff);\n      var k = 1;\n      while (k < 64) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15)\n            break;\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s);\n        k++;\n      }\n    }\n    function decodeDCFirst(component, zz) {\n      var t = decodeHuffman(component.huffmanTableDC);\n      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n      zz[0] = (component.pred += diff);\n    }\n    function decodeDCSuccessive(component, zz) {\n      zz[0] |= readBit() << successive;\n    }\n    var eobrun = 0;\n    function decodeACFirst(component, zz) {\n      if (eobrun > 0) {\n        eobrun--;\n        return;\n      }\n      var k = spectralStart, e = spectralEnd;\n      while (k <= e) {\n        var rs = decodeHuffman(component.huffmanTableAC);\n        var s = rs & 15, r = rs >> 4;\n        if (s === 0) {\n          if (r < 15) {\n            eobrun = receive(r) + (1 << r) - 1;\n            break;\n          }\n          k += 16;\n          continue;\n        }\n        k += r;\n        var z = dctZigZag[k];\n        zz[z] = receiveAndExtend(s) * (1 << successive);\n        k++;\n      }\n    }\n    var successiveACState = 0, successiveACNextValue;\n    function decodeACSuccessive(component, zz) {\n      var k = spectralStart, e = spectralEnd, r = 0;\n      while (k <= e) {\n        var z = dctZigZag[k];\n        var direction = zz[z] < 0 ? -1 : 1;\n        switch (successiveACState) {\n        case 0: // initial state\n          var rs = decodeHuffman(component.huffmanTableAC);\n          var s = rs & 15, r = rs >> 4;\n          if (s === 0) {\n            if (r < 15) {\n              eobrun = receive(r) + (1 << r);\n              successiveACState = 4;\n            } else {\n              r = 16;\n              successiveACState = 1;\n            }\n          } else {\n            if (s !== 1)\n              throw new Error(\"invalid ACn encoding\");\n            successiveACNextValue = receiveAndExtend(s);\n            successiveACState = r ? 2 : 3;\n          }\n          continue;\n        case 1: // skipping r zero items\n        case 2:\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          else {\n            r--;\n            if (r === 0)\n              successiveACState = successiveACState == 2 ? 3 : 0;\n          }\n          break;\n        case 3: // set value for a zero item\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          else {\n            zz[z] = successiveACNextValue << successive;\n            successiveACState = 0;\n          }\n          break;\n        case 4: // eob\n          if (zz[z])\n            zz[z] += (readBit() << successive) * direction;\n          break;\n        }\n        k++;\n      }\n      if (successiveACState === 4) {\n        eobrun--;\n        if (eobrun === 0)\n          successiveACState = 0;\n      }\n    }\n    function decodeMcu(component, decode, mcu, row, col) {\n      var mcuRow = (mcu / mcusPerLine) | 0;\n      var mcuCol = mcu % mcusPerLine;\n      var blockRow = mcuRow * component.v + row;\n      var blockCol = mcuCol * component.h + col;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n    function decodeBlock(component, decode, mcu) {\n      var blockRow = (mcu / component.blocksPerLine) | 0;\n      var blockCol = mcu % component.blocksPerLine;\n      decode(component, component.blocks[blockRow][blockCol]);\n    }\n\n    var componentsLength = components.length;\n    var component, i, j, k, n;\n    var decodeFn;\n    if (progressive) {\n      if (spectralStart === 0)\n        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n      else\n        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n    } else {\n      decodeFn = decodeBaseline;\n    }\n\n    var mcu = 0, marker;\n    var mcuExpected;\n    if (componentsLength == 1) {\n      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    } else {\n      mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n    if (!resetInterval) resetInterval = mcuExpected;\n\n    var h, v;\n    while (mcu < mcuExpected) {\n      // reset interval stuff\n      for (i = 0; i < componentsLength; i++)\n        components[i].pred = 0;\n      eobrun = 0;\n\n      if (componentsLength == 1) {\n        component = components[0];\n        for (n = 0; n < resetInterval; n++) {\n          decodeBlock(component, decodeFn, mcu);\n          mcu++;\n        }\n      } else {\n        for (n = 0; n < resetInterval; n++) {\n          for (i = 0; i < componentsLength; i++) {\n            component = components[i];\n            h = component.h;\n            v = component.v;\n            for (j = 0; j < v; j++) {\n              for (k = 0; k < h; k++) {\n                decodeMcu(component, decodeFn, mcu, j, k);\n              }\n            }\n          }\n          mcu++;\n\n          // If we've reached our expected MCU's, stop decoding\n          if (mcu === mcuExpected) break;\n        }\n      }\n\n      // find marker\n      bitsCount = 0;\n      marker = (data[offset] << 8) | data[offset + 1];\n      if (marker < 0xFF00) {\n        throw new Error(\"marker was not found\");\n      }\n\n      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n        offset += 2;\n      }\n      else\n        break;\n    }\n\n    return offset - startOffset;\n  }\n\n  function buildComponentData(frame, component) {\n    var lines = [];\n    var blocksPerLine = component.blocksPerLine;\n    var blocksPerColumn = component.blocksPerColumn;\n    var samplesPerLine = blocksPerLine << 3;\n    var R = new Int32Array(64), r = new Uint8Array(64);\n\n    // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n    function quantizeAndInverse(zz, dataOut, dataIn) {\n      var qt = component.quantizationTable;\n      var v0, v1, v2, v3, v4, v5, v6, v7, t;\n      var p = dataIn;\n      var i;\n\n      // dequant\n      for (i = 0; i < 64; i++)\n        p[i] = zz[i] * qt[i];\n\n      // inverse DCT on rows\n      for (i = 0; i < 8; ++i) {\n        var row = 8 * i;\n\n        // check for all-zero AC coefficients\n        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&\n            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&\n            p[7 + row] == 0) {\n          t = (dctSqrt2 * p[0 + row] + 512) >> 10;\n          p[0 + row] = t;\n          p[1 + row] = t;\n          p[2 + row] = t;\n          p[3 + row] = t;\n          p[4 + row] = t;\n          p[5 + row] = t;\n          p[6 + row] = t;\n          p[7 + row] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;\n        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;\n        v2 = p[2 + row];\n        v3 = p[6 + row];\n        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;\n        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;\n        v5 = p[3 + row] << 4;\n        v6 = p[5 + row] << 4;\n\n        // stage 3\n        t = (v0 - v1+ 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0 + row] = v0 + v7;\n        p[7 + row] = v0 - v7;\n        p[1 + row] = v1 + v6;\n        p[6 + row] = v1 - v6;\n        p[2 + row] = v2 + v5;\n        p[5 + row] = v2 - v5;\n        p[3 + row] = v3 + v4;\n        p[4 + row] = v3 - v4;\n      }\n\n      // inverse DCT on columns\n      for (i = 0; i < 8; ++i) {\n        var col = i;\n\n        // check for all-zero AC coefficients\n        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&\n            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&\n            p[7*8 + col] == 0) {\n          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;\n          p[0*8 + col] = t;\n          p[1*8 + col] = t;\n          p[2*8 + col] = t;\n          p[3*8 + col] = t;\n          p[4*8 + col] = t;\n          p[5*8 + col] = t;\n          p[6*8 + col] = t;\n          p[7*8 + col] = t;\n          continue;\n        }\n\n        // stage 4\n        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;\n        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;\n        v2 = p[2*8 + col];\n        v3 = p[6*8 + col];\n        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;\n        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;\n        v5 = p[3*8 + col];\n        v6 = p[5*8 + col];\n\n        // stage 3\n        t = (v0 - v1 + 1) >> 1;\n        v0 = (v0 + v1 + 1) >> 1;\n        v1 = t;\n        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\n        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\n        v3 = t;\n        t = (v4 - v6 + 1) >> 1;\n        v4 = (v4 + v6 + 1) >> 1;\n        v6 = t;\n        t = (v7 + v5 + 1) >> 1;\n        v5 = (v7 - v5 + 1) >> 1;\n        v7 = t;\n\n        // stage 2\n        t = (v0 - v3 + 1) >> 1;\n        v0 = (v0 + v3 + 1) >> 1;\n        v3 = t;\n        t = (v1 - v2 + 1) >> 1;\n        v1 = (v1 + v2 + 1) >> 1;\n        v2 = t;\n        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n        v7 = t;\n        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n        v6 = t;\n\n        // stage 1\n        p[0*8 + col] = v0 + v7;\n        p[7*8 + col] = v0 - v7;\n        p[1*8 + col] = v1 + v6;\n        p[6*8 + col] = v1 - v6;\n        p[2*8 + col] = v2 + v5;\n        p[5*8 + col] = v2 - v5;\n        p[3*8 + col] = v3 + v4;\n        p[4*8 + col] = v3 - v4;\n      }\n\n      // convert to 8-bit integers\n      for (i = 0; i < 64; ++i) {\n        var sample = 128 + ((p[i] + 8) >> 4);\n        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;\n      }\n    }\n\n    var i, j;\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n      var scanLine = blockRow << 3;\n      for (i = 0; i < 8; i++)\n        lines.push(new Uint8Array(samplesPerLine));\n      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n\n        var offset = 0, sample = blockCol << 3;\n        for (j = 0; j < 8; j++) {\n          var line = lines[scanLine + j];\n          for (i = 0; i < 8; i++)\n            line[sample + i] = r[offset++];\n        }\n      }\n    }\n    return lines;\n  }\n\n  function clampTo8bit(a) {\n    return a < 0 ? 0 : a > 255 ? 255 : a;\n  }\n\n  constructor.prototype = {\n    load: function load(path) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", path, true);\n      xhr.responseType = \"arraybuffer\";\n      xhr.onload = (function() {\n        // TODO catch parse error\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        this.parse(data);\n        if (this.onload)\n          this.onload();\n      }).bind(this);\n      xhr.send(null);\n    },\n    parse: function parse(data) {\n      var offset = 0, length = data.length;\n      function readUint16() {\n        var value = (data[offset] << 8) | data[offset + 1];\n        offset += 2;\n        return value;\n      }\n      function readDataBlock() {\n        var length = readUint16();\n        var array = data.subarray(offset, offset + length - 2);\n        offset += array.length;\n        return array;\n      }\n      function prepareComponents(frame) {\n        var maxH = 0, maxV = 0;\n        var component, componentId;\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            if (maxH < component.h) maxH = component.h;\n            if (maxV < component.v) maxV = component.v;\n          }\n        }\n        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n        for (componentId in frame.components) {\n          if (frame.components.hasOwnProperty(componentId)) {\n            component = frame.components[componentId];\n            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);\n            var blocksPerLineForMcu = mcusPerLine * component.h;\n            var blocksPerColumnForMcu = mcusPerColumn * component.v;\n            var blocks = [];\n            for (var i = 0; i < blocksPerColumnForMcu; i++) {\n              var row = [];\n              for (var j = 0; j < blocksPerLineForMcu; j++)\n                row.push(new Int32Array(64));\n              blocks.push(row);\n            }\n            component.blocksPerLine = blocksPerLine;\n            component.blocksPerColumn = blocksPerColumn;\n            component.blocks = blocks;\n          }\n        }\n        frame.maxH = maxH;\n        frame.maxV = maxV;\n        frame.mcusPerLine = mcusPerLine;\n        frame.mcusPerColumn = mcusPerColumn;\n      }\n      var jfif = null;\n      var adobe = null;\n      var pixels = null;\n      var frame, resetInterval;\n      var quantizationTables = [], frames = [];\n      var huffmanTablesAC = [], huffmanTablesDC = [];\n      var fileMarker = readUint16();\n      if (fileMarker != 0xFFD8) { // SOI (Start of Image)\n        throw new Error(\"SOI not found\");\n      }\n\n      fileMarker = readUint16();\n      while (fileMarker != 0xFFD9) { // EOI (End of image)\n        var i, j, l;\n        switch(fileMarker) {\n          case 0xFF00: break;\n          case 0xFFE0: // APP0 (Application Specific)\n          case 0xFFE1: // APP1\n          case 0xFFE2: // APP2\n          case 0xFFE3: // APP3\n          case 0xFFE4: // APP4\n          case 0xFFE5: // APP5\n          case 0xFFE6: // APP6\n          case 0xFFE7: // APP7\n          case 0xFFE8: // APP8\n          case 0xFFE9: // APP9\n          case 0xFFEA: // APP10\n          case 0xFFEB: // APP11\n          case 0xFFEC: // APP12\n          case 0xFFED: // APP13\n          case 0xFFEE: // APP14\n          case 0xFFEF: // APP15\n          case 0xFFFE: // COM (Comment)\n            var appData = readDataBlock();\n\n            if (fileMarker === 0xFFE0) {\n              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&\n                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n                jfif = {\n                  version: { major: appData[5], minor: appData[6] },\n                  densityUnits: appData[7],\n                  xDensity: (appData[8] << 8) | appData[9],\n                  yDensity: (appData[10] << 8) | appData[11],\n                  thumbWidth: appData[12],\n                  thumbHeight: appData[13],\n                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                };\n              }\n            }\n            // TODO APP1 - Exif\n            if (fileMarker === 0xFFEE) {\n              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&\n                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n                adobe = {\n                  version: appData[6],\n                  flags0: (appData[7] << 8) | appData[8],\n                  flags1: (appData[9] << 8) | appData[10],\n                  transformCode: appData[11]\n                };\n              }\n            }\n            break;\n\n          case 0xFFDB: // DQT (Define Quantization Tables)\n            var quantizationTablesLength = readUint16();\n            var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n            while (offset < quantizationTablesEnd) {\n              var quantizationTableSpec = data[offset++];\n              var tableData = new Int32Array(64);\n              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = data[offset++];\n                }\n              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit\n                for (j = 0; j < 64; j++) {\n                  var z = dctZigZag[j];\n                  tableData[z] = readUint16();\n                }\n              } else\n                throw new Error(\"DQT: invalid table spec\");\n              quantizationTables[quantizationTableSpec & 15] = tableData;\n            }\n            break;\n\n          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)\n            readUint16(); // skip data length\n            frame = {};\n            frame.extended = (fileMarker === 0xFFC1);\n            frame.progressive = (fileMarker === 0xFFC2);\n            frame.precision = data[offset++];\n            frame.scanLines = readUint16();\n            frame.samplesPerLine = readUint16();\n            frame.components = {};\n            frame.componentsOrder = [];\n            var componentsCount = data[offset++], componentId;\n            var maxH = 0, maxV = 0;\n            for (i = 0; i < componentsCount; i++) {\n              componentId = data[offset];\n              var h = data[offset + 1] >> 4;\n              var v = data[offset + 1] & 15;\n              var qId = data[offset + 2];\n              frame.componentsOrder.push(componentId);\n              frame.components[componentId] = {\n                h: h,\n                v: v,\n                quantizationIdx: qId\n              };\n              offset += 3;\n            }\n            prepareComponents(frame);\n            frames.push(frame);\n            break;\n\n          case 0xFFC4: // DHT (Define Huffman Tables)\n            var huffmanLength = readUint16();\n            for (i = 2; i < huffmanLength;) {\n              var huffmanTableSpec = data[offset++];\n              var codeLengths = new Uint8Array(16);\n              var codeLengthSum = 0;\n              for (j = 0; j < 16; j++, offset++)\n                codeLengthSum += (codeLengths[j] = data[offset]);\n              var huffmanValues = new Uint8Array(codeLengthSum);\n              for (j = 0; j < codeLengthSum; j++, offset++)\n                huffmanValues[j] = data[offset];\n              i += 17 + codeLengthSum;\n\n              ((huffmanTableSpec >> 4) === 0 ?\n                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =\n                buildHuffmanTable(codeLengths, huffmanValues);\n            }\n            break;\n\n          case 0xFFDD: // DRI (Define Restart Interval)\n            readUint16(); // skip data length\n            resetInterval = readUint16();\n            break;\n\n          case 0xFFDA: // SOS (Start of Scan)\n            var scanLength = readUint16();\n            var selectorsCount = data[offset++];\n            var components = [], component;\n            for (i = 0; i < selectorsCount; i++) {\n              component = frame.components[data[offset++]];\n              var tableSpec = data[offset++];\n              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n              components.push(component);\n            }\n            var spectralStart = data[offset++];\n            var spectralEnd = data[offset++];\n            var successiveApproximation = data[offset++];\n            var processed = decodeScan(data, offset,\n              frame, components, resetInterval,\n              spectralStart, spectralEnd,\n              successiveApproximation >> 4, successiveApproximation & 15);\n            offset += processed;\n            break;\n\n          case 0xFFFF: // Fill bytes\n            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n              offset--;\n            }\n            break;\n\n          default:\n            if (data[offset - 3] == 0xFF &&\n                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n              // could be incorrect encoding -- last 0xFF byte of the previous\n              // block was eaten by the encoder\n              offset -= 3;\n              break;\n            }\n            throw new Error(\"unknown JPEG marker \" + fileMarker.toString(16));\n        }\n        fileMarker = readUint16();\n      }\n      if (frames.length != 1)\n        throw new Error(\"only single frame JPEGs supported\");\n\n      // set each frame's components quantization table\n      for (var i = 0; i < frames.length; i++) {\n        var cp = frames[i].components;\n        for (var j in cp) {\n          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];\n          delete cp[j].quantizationIdx;\n        }\n      }\n\n      this.width = frame.samplesPerLine;\n      this.height = frame.scanLines;\n      this.jfif = jfif;\n      this.adobe = adobe;\n      this.components = [];\n      for (var i = 0; i < frame.componentsOrder.length; i++) {\n        var component = frame.components[frame.componentsOrder[i]];\n        this.components.push({\n          lines: buildComponentData(frame, component),\n          scaleX: component.h / frame.maxH,\n          scaleY: component.v / frame.maxV\n        });\n      }\n    },\n    getData: function getData(width, height) {\n      var scaleX = this.width / width, scaleY = this.height / height;\n\n      var component1, component2, component3, component4;\n      var component1Line, component2Line, component3Line, component4Line;\n      var x, y;\n      var offset = 0;\n      var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n      var colorTransform;\n      var dataLength = width * height * this.components.length;\n      var data = new Uint8Array(dataLength);\n      switch (this.components.length) {\n        case 1:\n          component1 = this.components[0];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 2:\n          // PDF might compress two component data in custom colorspace\n          component1 = this.components[0];\n          component2 = this.components[1];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n              data[offset++] = Y;\n              Y = component2Line[0 | (x * component2.scaleX * scaleX)];\n              data[offset++] = Y;\n            }\n          }\n          break;\n        case 3:\n          // The default transform for three components is true\n          colorTransform = true;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.colorTransform !== 'undefined')\n            colorTransform = !!this.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                R = component1Line[0 | (x * component1.scaleX * scaleX)];\n                G = component2Line[0 | (x * component2.scaleX * scaleX)];\n                B = component3Line[0 | (x * component3.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n\n                R = clampTo8bit(Y + 1.402 * (Cr - 128));\n                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                B = clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n\n              data[offset++] = R;\n              data[offset++] = G;\n              data[offset++] = B;\n            }\n          }\n          break;\n        case 4:\n          if (!this.adobe)\n            throw new Error('Unsupported color mode (4 components)');\n          // The default transform for four components is false\n          colorTransform = false;\n          // The adobe transform marker overrides any previous setting\n          if (this.adobe && this.adobe.transformCode)\n            colorTransform = true;\n          else if (typeof this.colorTransform !== 'undefined')\n            colorTransform = !!this.colorTransform;\n\n          component1 = this.components[0];\n          component2 = this.components[1];\n          component3 = this.components[2];\n          component4 = this.components[3];\n          for (y = 0; y < height; y++) {\n            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];\n            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];\n            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];\n            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];\n            for (x = 0; x < width; x++) {\n              if (!colorTransform) {\n                C = component1Line[0 | (x * component1.scaleX * scaleX)];\n                M = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n              } else {\n                Y = component1Line[0 | (x * component1.scaleX * scaleX)];\n                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];\n                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];\n                K = component4Line[0 | (x * component4.scaleX * scaleX)];\n\n                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));\n                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));\n                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));\n              }\n              data[offset++] = 255-C;\n              data[offset++] = 255-M;\n              data[offset++] = 255-Ye;\n              data[offset++] = 255-K;\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n      return data;\n    },\n    copyToImageData: function copyToImageData(imageData) {\n      var width = imageData.width, height = imageData.height;\n      var imageDataArray = imageData.data;\n      var data = this.getData(width, height);\n      var i = 0, j = 0, x, y;\n      var Y, K, C, M, R, G, B;\n      switch (this.components.length) {\n        case 1:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              Y = data[i++];\n\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = Y;\n              imageDataArray[j++] = 255;\n            }\n          }\n          break;\n        case 3:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              R = data[i++];\n              G = data[i++];\n              B = data[i++];\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              imageDataArray[j++] = 255;\n            }\n          }\n          break;\n        case 4:\n          for (y = 0; y < height; y++) {\n            for (x = 0; x < width; x++) {\n              C = data[i++];\n              M = data[i++];\n              Y = data[i++];\n              K = data[i++];\n\n              R = 255 - clampTo8bit(C * (1 - K / 255) + K);\n              G = 255 - clampTo8bit(M * (1 - K / 255) + K);\n              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);\n\n              imageDataArray[j++] = R;\n              imageDataArray[j++] = G;\n              imageDataArray[j++] = B;\n              imageDataArray[j++] = 255;\n            }\n          }\n          break;\n        default:\n          throw new Error('Unsupported color mode');\n      }\n    }\n  };\n\n  return constructor;\n})();\nmodule.exports = decode;\n\nfunction decode(jpegData, opts) {\n  var defaultOpts = {\n    useTArray: false,\n    colorTransform: true\n  };\n  if (opts) {\n    if (typeof opts === 'object') {\n      opts = {\n        useTArray: (typeof opts.useTArray === 'undefined' ?\n                    defaultOpts.useTArray : opts.useTArray),\n        colorTransform: (typeof opts.colorTransform === 'undefined' ?\n                         defaultOpts.colorTransform : opts.colorTransform)\n      };\n    } else {\n      // backwards compatiblity, before 0.3.5, we only had the useTArray param\n      opts = defaultOpts;\n      opts.useTArray = true;\n    }\n  } else {\n    opts = defaultOpts;\n  }\n\n  var arr = new Uint8Array(jpegData);\n  var decoder = new JpegImage();\n  decoder.parse(arr);\n  decoder.colorTransform = opts.colorTransform;\n\n  var image = {\n    width: decoder.width,\n    height: decoder.height,\n    data: opts.useTArray ?\n      new Uint8Array(decoder.width * decoder.height * 4) :\n      new Buffer(decoder.width * decoder.height * 4)\n  };\n\n  decoder.copyToImageData(image);\n\n  return image;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/jpeg-js/lib/decoder.js?");

/***/ }),

/***/ "./node_modules/jpeg-js/lib/encoder.js":
/*!*********************************************!*\
  !*** ./node_modules/jpeg-js/lib/encoder.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {/*\n  Copyright (c) 2008, Adobe Systems Incorporated\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without \n  modification, are permitted provided that the following conditions are\n  met:\n\n  * Redistributions of source code must retain the above copyright notice, \n    this list of conditions and the following disclaimer.\n  \n  * Redistributions in binary form must reproduce the above copyright\n    notice, this list of conditions and the following disclaimer in the \n    documentation and/or other materials provided with the distribution.\n  \n  * Neither the name of Adobe Systems Incorporated nor the names of its \n    contributors may be used to endorse or promote products derived from \n    this software without specific prior written permission.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n  IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR \n  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n/*\nJPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009\n\nBasic GUI blocking jpeg encoder\n*/\n\nvar btoa = btoa || function(buf) {\n  return new Buffer(buf).toString('base64');\n};\n\nfunction JPEGEncoder(quality) {\n  var self = this;\n\tvar fround = Math.round;\n\tvar ffloor = Math.floor;\n\tvar YTable = new Array(64);\n\tvar UVTable = new Array(64);\n\tvar fdtbl_Y = new Array(64);\n\tvar fdtbl_UV = new Array(64);\n\tvar YDC_HT;\n\tvar UVDC_HT;\n\tvar YAC_HT;\n\tvar UVAC_HT;\n\t\n\tvar bitcode = new Array(65535);\n\tvar category = new Array(65535);\n\tvar outputfDCTQuant = new Array(64);\n\tvar DU = new Array(64);\n\tvar byteout = [];\n\tvar bytenew = 0;\n\tvar bytepos = 7;\n\t\n\tvar YDU = new Array(64);\n\tvar UDU = new Array(64);\n\tvar VDU = new Array(64);\n\tvar clt = new Array(256);\n\tvar RGB_YUV_TABLE = new Array(2048);\n\tvar currentQuality;\n\t\n\tvar ZigZag = [\n\t\t\t 0, 1, 5, 6,14,15,27,28,\n\t\t\t 2, 4, 7,13,16,26,29,42,\n\t\t\t 3, 8,12,17,25,30,41,43,\n\t\t\t 9,11,18,24,31,40,44,53,\n\t\t\t10,19,23,32,39,45,52,54,\n\t\t\t20,22,33,38,46,51,55,60,\n\t\t\t21,34,37,47,50,56,59,61,\n\t\t\t35,36,48,49,57,58,62,63\n\t\t];\n\t\n\tvar std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];\n\tvar std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];\n\tvar std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];\n\tvar std_ac_luminance_values = [\n\t\t\t0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,\n\t\t\t0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,\n\t\t\t0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,\n\t\t\t0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,\n\t\t\t0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,\n\t\t\t0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,\n\t\t\t0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,\n\t\t\t0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,\n\t\t\t0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,\n\t\t\t0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,\n\t\t\t0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,\n\t\t\t0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,\n\t\t\t0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,\n\t\t\t0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,\n\t\t\t0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,\n\t\t\t0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,\n\t\t\t0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,\n\t\t\t0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,\n\t\t\t0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,\n\t\t\t0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,\n\t\t\t0xf9,0xfa\n\t\t];\n\t\n\tvar std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];\n\tvar std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];\n\tvar std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];\n\tvar std_ac_chrominance_values = [\n\t\t\t0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,\n\t\t\t0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,\n\t\t\t0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,\n\t\t\t0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,\n\t\t\t0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,\n\t\t\t0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,\n\t\t\t0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,\n\t\t\t0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,\n\t\t\t0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,\n\t\t\t0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,\n\t\t\t0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,\n\t\t\t0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,\n\t\t\t0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,\n\t\t\t0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,\n\t\t\t0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,\n\t\t\t0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,\n\t\t\t0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,\n\t\t\t0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,\n\t\t\t0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,\n\t\t\t0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,\n\t\t\t0xf9,0xfa\n\t\t];\n\t\n\tfunction initQuantTables(sf){\n\t\t\tvar YQT = [\n\t\t\t\t16, 11, 10, 16, 24, 40, 51, 61,\n\t\t\t\t12, 12, 14, 19, 26, 58, 60, 55,\n\t\t\t\t14, 13, 16, 24, 40, 57, 69, 56,\n\t\t\t\t14, 17, 22, 29, 51, 87, 80, 62,\n\t\t\t\t18, 22, 37, 56, 68,109,103, 77,\n\t\t\t\t24, 35, 55, 64, 81,104,113, 92,\n\t\t\t\t49, 64, 78, 87,103,121,120,101,\n\t\t\t\t72, 92, 95, 98,112,100,103, 99\n\t\t\t];\n\t\t\t\n\t\t\tfor (var i = 0; i < 64; i++) {\n\t\t\t\tvar t = ffloor((YQT[i]*sf+50)/100);\n\t\t\t\tif (t < 1) {\n\t\t\t\t\tt = 1;\n\t\t\t\t} else if (t > 255) {\n\t\t\t\t\tt = 255;\n\t\t\t\t}\n\t\t\t\tYTable[ZigZag[i]] = t;\n\t\t\t}\n\t\t\tvar UVQT = [\n\t\t\t\t17, 18, 24, 47, 99, 99, 99, 99,\n\t\t\t\t18, 21, 26, 66, 99, 99, 99, 99,\n\t\t\t\t24, 26, 56, 99, 99, 99, 99, 99,\n\t\t\t\t47, 66, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99,\n\t\t\t\t99, 99, 99, 99, 99, 99, 99, 99\n\t\t\t];\n\t\t\tfor (var j = 0; j < 64; j++) {\n\t\t\t\tvar u = ffloor((UVQT[j]*sf+50)/100);\n\t\t\t\tif (u < 1) {\n\t\t\t\t\tu = 1;\n\t\t\t\t} else if (u > 255) {\n\t\t\t\t\tu = 255;\n\t\t\t\t}\n\t\t\t\tUVTable[ZigZag[j]] = u;\n\t\t\t}\n\t\t\tvar aasf = [\n\t\t\t\t1.0, 1.387039845, 1.306562965, 1.175875602,\n\t\t\t\t1.0, 0.785694958, 0.541196100, 0.275899379\n\t\t\t];\n\t\t\tvar k = 0;\n\t\t\tfor (var row = 0; row < 8; row++)\n\t\t\t{\n\t\t\t\tfor (var col = 0; col < 8; col++)\n\t\t\t\t{\n\t\t\t\t\tfdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));\n\t\t\t\t\tfdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction computeHuffmanTbl(nrcodes, std_table){\n\t\t\tvar codevalue = 0;\n\t\t\tvar pos_in_table = 0;\n\t\t\tvar HT = new Array();\n\t\t\tfor (var k = 1; k <= 16; k++) {\n\t\t\t\tfor (var j = 1; j <= nrcodes[k]; j++) {\n\t\t\t\t\tHT[std_table[pos_in_table]] = [];\n\t\t\t\t\tHT[std_table[pos_in_table]][0] = codevalue;\n\t\t\t\t\tHT[std_table[pos_in_table]][1] = k;\n\t\t\t\t\tpos_in_table++;\n\t\t\t\t\tcodevalue++;\n\t\t\t\t}\n\t\t\t\tcodevalue*=2;\n\t\t\t}\n\t\t\treturn HT;\n\t\t}\n\t\t\n\t\tfunction initHuffmanTbl()\n\t\t{\n\t\t\tYDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);\n\t\t\tUVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);\n\t\t\tYAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);\n\t\t\tUVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);\n\t\t}\n\t\n\t\tfunction initCategoryNumber()\n\t\t{\n\t\t\tvar nrlower = 1;\n\t\t\tvar nrupper = 2;\n\t\t\tfor (var cat = 1; cat <= 15; cat++) {\n\t\t\t\t//Positive numbers\n\t\t\t\tfor (var nr = nrlower; nr<nrupper; nr++) {\n\t\t\t\t\tcategory[32767+nr] = cat;\n\t\t\t\t\tbitcode[32767+nr] = [];\n\t\t\t\t\tbitcode[32767+nr][1] = cat;\n\t\t\t\t\tbitcode[32767+nr][0] = nr;\n\t\t\t\t}\n\t\t\t\t//Negative numbers\n\t\t\t\tfor (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {\n\t\t\t\t\tcategory[32767+nrneg] = cat;\n\t\t\t\t\tbitcode[32767+nrneg] = [];\n\t\t\t\t\tbitcode[32767+nrneg][1] = cat;\n\t\t\t\t\tbitcode[32767+nrneg][0] = nrupper-1+nrneg;\n\t\t\t\t}\n\t\t\t\tnrlower <<= 1;\n\t\t\t\tnrupper <<= 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction initRGBYUVTable() {\n\t\t\tfor(var i = 0; i < 256;i++) {\n\t\t\t\tRGB_YUV_TABLE[i]      \t\t=  19595 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+ 256)>>0] \t=  38470 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+ 512)>>0] \t=   7471 * i + 0x8000;\n\t\t\t\tRGB_YUV_TABLE[(i+ 768)>>0] \t= -11059 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+1024)>>0] \t= -21709 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+1280)>>0] \t=  32768 * i + 0x807FFF;\n\t\t\t\tRGB_YUV_TABLE[(i+1536)>>0] \t= -27439 * i;\n\t\t\t\tRGB_YUV_TABLE[(i+1792)>>0] \t= - 5329 * i;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// IO functions\n\t\tfunction writeBits(bs)\n\t\t{\n\t\t\tvar value = bs[0];\n\t\t\tvar posval = bs[1]-1;\n\t\t\twhile ( posval >= 0 ) {\n\t\t\t\tif (value & (1 << posval) ) {\n\t\t\t\t\tbytenew |= (1 << bytepos);\n\t\t\t\t}\n\t\t\t\tposval--;\n\t\t\t\tbytepos--;\n\t\t\t\tif (bytepos < 0) {\n\t\t\t\t\tif (bytenew == 0xFF) {\n\t\t\t\t\t\twriteByte(0xFF);\n\t\t\t\t\t\twriteByte(0);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\twriteByte(bytenew);\n\t\t\t\t\t}\n\t\t\t\t\tbytepos=7;\n\t\t\t\t\tbytenew=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tfunction writeByte(value)\n\t\t{\n\t\t\t//byteout.push(clt[value]); // write char directly instead of converting later\n      byteout.push(value);\n\t\t}\n\t\n\t\tfunction writeWord(value)\n\t\t{\n\t\t\twriteByte((value>>8)&0xFF);\n\t\t\twriteByte((value   )&0xFF);\n\t\t}\n\t\t\n\t\t// DCT & quantization core\n\t\tfunction fDCTQuant(data, fdtbl)\n\t\t{\n\t\t\tvar d0, d1, d2, d3, d4, d5, d6, d7;\n\t\t\t/* Pass 1: process rows. */\n\t\t\tvar dataOff=0;\n\t\t\tvar i;\n\t\t\tvar I8 = 8;\n\t\t\tvar I64 = 64;\n\t\t\tfor (i=0; i<I8; ++i)\n\t\t\t{\n\t\t\t\td0 = data[dataOff];\n\t\t\t\td1 = data[dataOff+1];\n\t\t\t\td2 = data[dataOff+2];\n\t\t\t\td3 = data[dataOff+3];\n\t\t\t\td4 = data[dataOff+4];\n\t\t\t\td5 = data[dataOff+5];\n\t\t\t\td6 = data[dataOff+6];\n\t\t\t\td7 = data[dataOff+7];\n\t\t\t\t\n\t\t\t\tvar tmp0 = d0 + d7;\n\t\t\t\tvar tmp7 = d0 - d7;\n\t\t\t\tvar tmp1 = d1 + d6;\n\t\t\t\tvar tmp6 = d1 - d6;\n\t\t\t\tvar tmp2 = d2 + d5;\n\t\t\t\tvar tmp5 = d2 - d5;\n\t\t\t\tvar tmp3 = d3 + d4;\n\t\t\t\tvar tmp4 = d3 - d4;\n\t\n\t\t\t\t/* Even part */\n\t\t\t\tvar tmp10 = tmp0 + tmp3;\t/* phase 2 */\n\t\t\t\tvar tmp13 = tmp0 - tmp3;\n\t\t\t\tvar tmp11 = tmp1 + tmp2;\n\t\t\t\tvar tmp12 = tmp1 - tmp2;\n\t\n\t\t\t\tdata[dataOff] = tmp10 + tmp11; /* phase 3 */\n\t\t\t\tdata[dataOff+4] = tmp10 - tmp11;\n\t\n\t\t\t\tvar z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */\n\t\t\t\tdata[dataOff+2] = tmp13 + z1; /* phase 5 */\n\t\t\t\tdata[dataOff+6] = tmp13 - z1;\n\t\n\t\t\t\t/* Odd part */\n\t\t\t\ttmp10 = tmp4 + tmp5; /* phase 2 */\n\t\t\t\ttmp11 = tmp5 + tmp6;\n\t\t\t\ttmp12 = tmp6 + tmp7;\n\t\n\t\t\t\t/* The rotator is modified from fig 4-8 to avoid extra negations. */\n\t\t\t\tvar z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */\n\t\t\t\tvar z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */\n\t\t\t\tvar z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */\n\t\t\t\tvar z3 = tmp11 * 0.707106781; /* c4 */\n\t\n\t\t\t\tvar z11 = tmp7 + z3;\t/* phase 5 */\n\t\t\t\tvar z13 = tmp7 - z3;\n\t\n\t\t\t\tdata[dataOff+5] = z13 + z2;\t/* phase 6 */\n\t\t\t\tdata[dataOff+3] = z13 - z2;\n\t\t\t\tdata[dataOff+1] = z11 + z4;\n\t\t\t\tdata[dataOff+7] = z11 - z4;\n\t\n\t\t\t\tdataOff += 8; /* advance pointer to next row */\n\t\t\t}\n\t\n\t\t\t/* Pass 2: process columns. */\n\t\t\tdataOff = 0;\n\t\t\tfor (i=0; i<I8; ++i)\n\t\t\t{\n\t\t\t\td0 = data[dataOff];\n\t\t\t\td1 = data[dataOff + 8];\n\t\t\t\td2 = data[dataOff + 16];\n\t\t\t\td3 = data[dataOff + 24];\n\t\t\t\td4 = data[dataOff + 32];\n\t\t\t\td5 = data[dataOff + 40];\n\t\t\t\td6 = data[dataOff + 48];\n\t\t\t\td7 = data[dataOff + 56];\n\t\t\t\t\n\t\t\t\tvar tmp0p2 = d0 + d7;\n\t\t\t\tvar tmp7p2 = d0 - d7;\n\t\t\t\tvar tmp1p2 = d1 + d6;\n\t\t\t\tvar tmp6p2 = d1 - d6;\n\t\t\t\tvar tmp2p2 = d2 + d5;\n\t\t\t\tvar tmp5p2 = d2 - d5;\n\t\t\t\tvar tmp3p2 = d3 + d4;\n\t\t\t\tvar tmp4p2 = d3 - d4;\n\t\n\t\t\t\t/* Even part */\n\t\t\t\tvar tmp10p2 = tmp0p2 + tmp3p2;\t/* phase 2 */\n\t\t\t\tvar tmp13p2 = tmp0p2 - tmp3p2;\n\t\t\t\tvar tmp11p2 = tmp1p2 + tmp2p2;\n\t\t\t\tvar tmp12p2 = tmp1p2 - tmp2p2;\n\t\n\t\t\t\tdata[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */\n\t\t\t\tdata[dataOff+32] = tmp10p2 - tmp11p2;\n\t\n\t\t\t\tvar z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */\n\t\t\t\tdata[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */\n\t\t\t\tdata[dataOff+48] = tmp13p2 - z1p2;\n\t\n\t\t\t\t/* Odd part */\n\t\t\t\ttmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */\n\t\t\t\ttmp11p2 = tmp5p2 + tmp6p2;\n\t\t\t\ttmp12p2 = tmp6p2 + tmp7p2;\n\t\n\t\t\t\t/* The rotator is modified from fig 4-8 to avoid extra negations. */\n\t\t\t\tvar z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */\n\t\t\t\tvar z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */\n\t\t\t\tvar z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */\n\t\t\t\tvar z3p2 = tmp11p2 * 0.707106781; /* c4 */\n\t\n\t\t\t\tvar z11p2 = tmp7p2 + z3p2;\t/* phase 5 */\n\t\t\t\tvar z13p2 = tmp7p2 - z3p2;\n\t\n\t\t\t\tdata[dataOff+40] = z13p2 + z2p2; /* phase 6 */\n\t\t\t\tdata[dataOff+24] = z13p2 - z2p2;\n\t\t\t\tdata[dataOff+ 8] = z11p2 + z4p2;\n\t\t\t\tdata[dataOff+56] = z11p2 - z4p2;\n\t\n\t\t\t\tdataOff++; /* advance pointer to next column */\n\t\t\t}\n\t\n\t\t\t// Quantize/descale the coefficients\n\t\t\tvar fDCTQuant;\n\t\t\tfor (i=0; i<I64; ++i)\n\t\t\t{\n\t\t\t\t// Apply the quantization and scaling factor & Round to nearest integer\n\t\t\t\tfDCTQuant = data[i]*fdtbl[i];\n\t\t\t\toutputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);\n\t\t\t\t//outputfDCTQuant[i] = fround(fDCTQuant);\n\n\t\t\t}\n\t\t\treturn outputfDCTQuant;\n\t\t}\n\t\t\n\t\tfunction writeAPP0()\n\t\t{\n\t\t\twriteWord(0xFFE0); // marker\n\t\t\twriteWord(16); // length\n\t\t\twriteByte(0x4A); // J\n\t\t\twriteByte(0x46); // F\n\t\t\twriteByte(0x49); // I\n\t\t\twriteByte(0x46); // F\n\t\t\twriteByte(0); // = \"JFIF\",'\\0'\n\t\t\twriteByte(1); // versionhi\n\t\t\twriteByte(1); // versionlo\n\t\t\twriteByte(0); // xyunits\n\t\t\twriteWord(1); // xdensity\n\t\t\twriteWord(1); // ydensity\n\t\t\twriteByte(0); // thumbnwidth\n\t\t\twriteByte(0); // thumbnheight\n\t\t}\n\t\n\t\tfunction writeSOF0(width, height)\n\t\t{\n\t\t\twriteWord(0xFFC0); // marker\n\t\t\twriteWord(17);   // length, truecolor YUV JPG\n\t\t\twriteByte(8);    // precision\n\t\t\twriteWord(height);\n\t\t\twriteWord(width);\n\t\t\twriteByte(3);    // nrofcomponents\n\t\t\twriteByte(1);    // IdY\n\t\t\twriteByte(0x11); // HVY\n\t\t\twriteByte(0);    // QTY\n\t\t\twriteByte(2);    // IdU\n\t\t\twriteByte(0x11); // HVU\n\t\t\twriteByte(1);    // QTU\n\t\t\twriteByte(3);    // IdV\n\t\t\twriteByte(0x11); // HVV\n\t\t\twriteByte(1);    // QTV\n\t\t}\n\t\n\t\tfunction writeDQT()\n\t\t{\n\t\t\twriteWord(0xFFDB); // marker\n\t\t\twriteWord(132);\t   // length\n\t\t\twriteByte(0);\n\t\t\tfor (var i=0; i<64; i++) {\n\t\t\t\twriteByte(YTable[i]);\n\t\t\t}\n\t\t\twriteByte(1);\n\t\t\tfor (var j=0; j<64; j++) {\n\t\t\t\twriteByte(UVTable[j]);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction writeDHT()\n\t\t{\n\t\t\twriteWord(0xFFC4); // marker\n\t\t\twriteWord(0x01A2); // length\n\t\n\t\t\twriteByte(0); // HTYDCinfo\n\t\t\tfor (var i=0; i<16; i++) {\n\t\t\t\twriteByte(std_dc_luminance_nrcodes[i+1]);\n\t\t\t}\n\t\t\tfor (var j=0; j<=11; j++) {\n\t\t\t\twriteByte(std_dc_luminance_values[j]);\n\t\t\t}\n\t\n\t\t\twriteByte(0x10); // HTYACinfo\n\t\t\tfor (var k=0; k<16; k++) {\n\t\t\t\twriteByte(std_ac_luminance_nrcodes[k+1]);\n\t\t\t}\n\t\t\tfor (var l=0; l<=161; l++) {\n\t\t\t\twriteByte(std_ac_luminance_values[l]);\n\t\t\t}\n\t\n\t\t\twriteByte(1); // HTUDCinfo\n\t\t\tfor (var m=0; m<16; m++) {\n\t\t\t\twriteByte(std_dc_chrominance_nrcodes[m+1]);\n\t\t\t}\n\t\t\tfor (var n=0; n<=11; n++) {\n\t\t\t\twriteByte(std_dc_chrominance_values[n]);\n\t\t\t}\n\t\n\t\t\twriteByte(0x11); // HTUACinfo\n\t\t\tfor (var o=0; o<16; o++) {\n\t\t\t\twriteByte(std_ac_chrominance_nrcodes[o+1]);\n\t\t\t}\n\t\t\tfor (var p=0; p<=161; p++) {\n\t\t\t\twriteByte(std_ac_chrominance_values[p]);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction writeSOS()\n\t\t{\n\t\t\twriteWord(0xFFDA); // marker\n\t\t\twriteWord(12); // length\n\t\t\twriteByte(3); // nrofcomponents\n\t\t\twriteByte(1); // IdY\n\t\t\twriteByte(0); // HTY\n\t\t\twriteByte(2); // IdU\n\t\t\twriteByte(0x11); // HTU\n\t\t\twriteByte(3); // IdV\n\t\t\twriteByte(0x11); // HTV\n\t\t\twriteByte(0); // Ss\n\t\t\twriteByte(0x3f); // Se\n\t\t\twriteByte(0); // Bf\n\t\t}\n\t\t\n\t\tfunction processDU(CDU, fdtbl, DC, HTDC, HTAC){\n\t\t\tvar EOB = HTAC[0x00];\n\t\t\tvar M16zeroes = HTAC[0xF0];\n\t\t\tvar pos;\n\t\t\tvar I16 = 16;\n\t\t\tvar I63 = 63;\n\t\t\tvar I64 = 64;\n\t\t\tvar DU_DCT = fDCTQuant(CDU, fdtbl);\n\t\t\t//ZigZag reorder\n\t\t\tfor (var j=0;j<I64;++j) {\n\t\t\t\tDU[ZigZag[j]]=DU_DCT[j];\n\t\t\t}\n\t\t\tvar Diff = DU[0] - DC; DC = DU[0];\n\t\t\t//Encode DC\n\t\t\tif (Diff==0) {\n\t\t\t\twriteBits(HTDC[0]); // Diff might be 0\n\t\t\t} else {\n\t\t\t\tpos = 32767+Diff;\n\t\t\t\twriteBits(HTDC[category[pos]]);\n\t\t\t\twriteBits(bitcode[pos]);\n\t\t\t}\n\t\t\t//Encode ACs\n\t\t\tvar end0pos = 63; // was const... which is crazy\n\t\t\tfor (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {};\n\t\t\t//end0pos = first element in reverse order !=0\n\t\t\tif ( end0pos == 0) {\n\t\t\t\twriteBits(EOB);\n\t\t\t\treturn DC;\n\t\t\t}\n\t\t\tvar i = 1;\n\t\t\tvar lng;\n\t\t\twhile ( i <= end0pos ) {\n\t\t\t\tvar startpos = i;\n\t\t\t\tfor (; (DU[i]==0) && (i<=end0pos); ++i) {}\n\t\t\t\tvar nrzeroes = i-startpos;\n\t\t\t\tif ( nrzeroes >= I16 ) {\n\t\t\t\t\tlng = nrzeroes>>4;\n\t\t\t\t\tfor (var nrmarker=1; nrmarker <= lng; ++nrmarker)\n\t\t\t\t\t\twriteBits(M16zeroes);\n\t\t\t\t\tnrzeroes = nrzeroes&0xF;\n\t\t\t\t}\n\t\t\t\tpos = 32767+DU[i];\n\t\t\t\twriteBits(HTAC[(nrzeroes<<4)+category[pos]]);\n\t\t\t\twriteBits(bitcode[pos]);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif ( end0pos != I63 ) {\n\t\t\t\twriteBits(EOB);\n\t\t\t}\n\t\t\treturn DC;\n\t\t}\n\n\t\tfunction initCharLookupTable(){\n\t\t\tvar sfcc = String.fromCharCode;\n\t\t\tfor(var i=0; i < 256; i++){ ///// ACHTUNG // 255\n\t\t\t\tclt[i] = sfcc(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.encode = function(image,quality) // image data object\n\t\t{\n\t\t\tvar time_start = new Date().getTime();\n\t\t\t\n\t\t\tif(quality) setQuality(quality);\n\t\t\t\n\t\t\t// Initialize bit writer\n\t\t\tbyteout = new Array();\n\t\t\tbytenew=0;\n\t\t\tbytepos=7;\n\t\n\t\t\t// Add JPEG headers\n\t\t\twriteWord(0xFFD8); // SOI\n\t\t\twriteAPP0();\n\t\t\twriteDQT();\n\t\t\twriteSOF0(image.width,image.height);\n\t\t\twriteDHT();\n\t\t\twriteSOS();\n\n\t\n\t\t\t// Encode 8x8 macroblocks\n\t\t\tvar DCY=0;\n\t\t\tvar DCU=0;\n\t\t\tvar DCV=0;\n\t\t\t\n\t\t\tbytenew=0;\n\t\t\tbytepos=7;\n\t\t\t\n\t\t\t\n\t\t\tthis.encode.displayName = \"_encode_\";\n\n\t\t\tvar imageData = image.data;\n\t\t\tvar width = image.width;\n\t\t\tvar height = image.height;\n\n\t\t\tvar quadWidth = width*4;\n\t\t\tvar tripleWidth = width*3;\n\t\t\t\n\t\t\tvar x, y = 0;\n\t\t\tvar r, g, b;\n\t\t\tvar start,p, col,row,pos;\n\t\t\twhile(y < height){\n\t\t\t\tx = 0;\n\t\t\t\twhile(x < quadWidth){\n\t\t\t\tstart = quadWidth * y + x;\n\t\t\t\tp = start;\n\t\t\t\tcol = -1;\n\t\t\t\trow = 0;\n\t\t\t\t\n\t\t\t\tfor(pos=0; pos < 64; pos++){\n\t\t\t\t\trow = pos >> 3;// /8\n\t\t\t\t\tcol = ( pos & 7 ) * 4; // %8\n\t\t\t\t\tp = start + ( row * quadWidth ) + col;\t\t\n\t\t\t\t\t\n\t\t\t\t\tif(y+row >= height){ // padding bottom\n\t\t\t\t\t\tp-= (quadWidth*(y+1+row-height));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(x+col >= quadWidth){ // padding right\t\n\t\t\t\t\t\tp-= ((x+col) - quadWidth +4)\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tr = imageData[ p++ ];\n\t\t\t\t\tg = imageData[ p++ ];\n\t\t\t\t\tb = imageData[ p++ ];\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t/* // calculate YUV values dynamically\n\t\t\t\t\tYDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80\n\t\t\t\t\tUDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));\n\t\t\t\t\tVDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));\n\t\t\t\t\t*/\n\t\t\t\t\t\n\t\t\t\t\t// use lookup table (slightly faster)\n\t\t\t\t\tYDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;\n\t\t\t\t\tUDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;\n\t\t\t\t\tVDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tDCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n\t\t\t\tDCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\n\t\t\t\tDCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\n\t\t\t\tx+=32;\n\t\t\t\t}\n\t\t\t\ty+=8;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t////////////////////////////////////////////////////////////////\n\t\n\t\t\t// Do the bit alignment of the EOI marker\n\t\t\tif ( bytepos >= 0 ) {\n\t\t\t\tvar fillbits = [];\n\t\t\t\tfillbits[1] = bytepos+1;\n\t\t\t\tfillbits[0] = (1<<(bytepos+1))-1;\n\t\t\t\twriteBits(fillbits);\n\t\t\t}\n\t\n\t\t\twriteWord(0xFFD9); //EOI\n\n      return  'data:image/jpeg;base64,' + btoa(byteout.join(''));\n      // return new Buffer(byteout);\n\n\t\t\t// var jpegDataUri = 'data:image/jpeg;base64,' + btoa(byteout.join(''));\n\t\t\t\n\t\t\t// byteout = [];\n\t\t\t\n\t\t\t// // benchmarking\n\t\t\t// var duration = new Date().getTime() - time_start;\n   //  \t\t//console.log('Encoding time: '+ duration + 'ms');\n   //  \t\t//\n\t\t\t\n\t\t\t// return jpegDataUri\t\t\t\n\t}\n\t\n\tfunction setQuality(quality){\n\t\tif (quality <= 0) {\n\t\t\tquality = 1;\n\t\t}\n\t\tif (quality > 100) {\n\t\t\tquality = 100;\n\t\t}\n\t\t\n\t\tif(currentQuality == quality) return // don't recalc if unchanged\n\t\t\n\t\tvar sf = 0;\n\t\tif (quality < 50) {\n\t\t\tsf = Math.floor(5000 / quality);\n\t\t} else {\n\t\t\tsf = Math.floor(200 - quality*2);\n\t\t}\n\t\t\n\t\tinitQuantTables(sf);\n\t\tcurrentQuality = quality;\n\t\t//console.log('Quality set to: '+quality +'%');\n\t}\n\t\n\tfunction init(){\n\t\tvar time_start = new Date().getTime();\n\t\tif(!quality) quality = 50;\n\t\t// Create tables\n\t\tinitCharLookupTable()\n\t\tinitHuffmanTbl();\n\t\tinitCategoryNumber();\n\t\tinitRGBYUVTable();\n\t\t\n\t\tsetQuality(quality);\n\t\tvar duration = new Date().getTime() - time_start;\n    \t//console.log('Initialization '+ duration + 'ms');\n\t}\n\t\n\tinit();\n\t\n};\nmodule.exports = encode;\n\nfunction encode(imgData, qu) {\n  if (typeof qu === 'undefined') qu = 50;\n  var encoder = new JPEGEncoder(qu);\n\tvar data = encoder.encode(imgData, qu);\n  return {\n    data: data,\n    width: imgData.width,\n    height: imgData.height\n  };\n}\n\n// helper function to get the imageData of an existing image on the current page.\nfunction getImageDataFromImage(idOrElement){\n\tvar theImg = (typeof(idOrElement)=='string')? document.getElementById(idOrElement):idOrElement;\n\tvar cvs = document.createElement('canvas');\n\tcvs.width = theImg.width;\n\tcvs.height = theImg.height;\n\tvar ctx = cvs.getContext(\"2d\");\n\tctx.drawImage(theImg,0,0);\n\t\n\treturn (ctx.getImageData(0, 0, cvs.width, cvs.height));\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/jpeg-js/lib/encoder.js?");

/***/ }),

/***/ "./node_modules/js-base64/base64.js":
/*!******************************************!*\
  !*** ./node_modules/js-base64/base64.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *  base64.js\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n */\n;(function (global, factory) {\n     true\n        ? module.exports = factory(global)\n        : undefined\n}((\n    typeof self !== 'undefined' ? self\n        : typeof window !== 'undefined' ? window\n        : typeof global !== 'undefined' ? global\n: this\n), function(global) {\n    'use strict';\n    // existing version for noConflict()\n    global = global || {};\n    var _Base64 = global.Base64;\n    var version = \"2.5.1\";\n    // if node.js and NOT React Native, we use Buffer\n    var buffer;\n    if ( true && module.exports) {\n        try {\n            buffer = eval(\"require('buffer').Buffer\");\n        } catch (err) {\n            buffer = undefined;\n        }\n    }\n    // constants\n    var b64chars\n        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var b64tab = function(bin) {\n        var t = {};\n        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;\n        return t;\n    }(b64chars);\n    var fromCharCode = String.fromCharCode;\n    // encoder stuff\n    var cb_utob = function(c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c\n                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))\n                                + fromCharCode(0x80 | (cc & 0x3f)))\n                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))\n                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                   + fromCharCode(0x80 | ( cc         & 0x3f)));\n        } else {\n            var cc = 0x10000\n                + (c.charCodeAt(0) - 0xD800) * 0x400\n                + (c.charCodeAt(1) - 0xDC00);\n            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))\n                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))\n                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                    + fromCharCode(0x80 | ( cc         & 0x3f)));\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    var utob = function(u) {\n        return u.replace(re_utob, cb_utob);\n    };\n    var cb_encode = function(ccc) {\n        var padlen = [0, 2, 1][ccc.length % 3],\n        ord = ccc.charCodeAt(0) << 16\n            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)\n            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),\n        chars = [\n            b64chars.charAt( ord >>> 18),\n            b64chars.charAt((ord >>> 12) & 63),\n            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n        ];\n        return chars.join('');\n    };\n    var btoa = global.btoa ? function(b) {\n        return global.btoa(b);\n    } : function(b) {\n        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n    var _encode = buffer ?\n        buffer.from && Uint8Array && buffer.from !== Uint8Array.from\n        ? function (u) {\n            return (u.constructor === buffer.constructor ? u : buffer.from(u))\n                .toString('base64')\n        }\n        :  function (u) {\n            return (u.constructor === buffer.constructor ? u : new  buffer(u))\n                .toString('base64')\n        }\n        : function (u) { return btoa(utob(u)) }\n    ;\n    var encode = function(u, urisafe) {\n        return !urisafe\n            ? _encode(String(u))\n            : _encode(String(u)).replace(/[+\\/]/g, function(m0) {\n                return m0 == '+' ? '-' : '_';\n            }).replace(/=/g, '');\n    };\n    var encodeURI = function(u) { return encode(u, true) };\n    // decoder stuff\n    var re_btou = new RegExp([\n        '[\\xC0-\\xDF][\\x80-\\xBF]',\n        '[\\xE0-\\xEF][\\x80-\\xBF]{2}',\n        '[\\xF0-\\xF7][\\x80-\\xBF]{3}'\n    ].join('|'), 'g');\n    var cb_btou = function(cccc) {\n        switch(cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                |    ((0x3f & cccc.charCodeAt(1)) << 12)\n                |    ((0x3f & cccc.charCodeAt(2)) <<  6)\n                |     (0x3f & cccc.charCodeAt(3)),\n            offset = cp - 0x10000;\n            return (fromCharCode((offset  >>> 10) + 0xD800)\n                    + fromCharCode((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return fromCharCode(\n                ((0x0f & cccc.charCodeAt(0)) << 12)\n                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n                    |  (0x3f & cccc.charCodeAt(2))\n            );\n        default:\n            return  fromCharCode(\n                ((0x1f & cccc.charCodeAt(0)) << 6)\n                    |  (0x3f & cccc.charCodeAt(1))\n            );\n        }\n    };\n    var btou = function(b) {\n        return b.replace(re_btou, cb_btou);\n    };\n    var cb_decode = function(cccc) {\n        var len = cccc.length,\n        padlen = len % 4,\n        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)\n            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)\n            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)\n            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),\n        chars = [\n            fromCharCode( n >>> 16),\n            fromCharCode((n >>>  8) & 0xff),\n            fromCharCode( n         & 0xff)\n        ];\n        chars.length -= [0, 0, 2, 1][padlen];\n        return chars.join('');\n    };\n    var _atob = global.atob ? function(a) {\n        return global.atob(a);\n    } : function(a){\n        return a.replace(/\\S{1,4}/g, cb_decode);\n    };\n    var atob = function(a) {\n        return _atob(String(a).replace(/[^A-Za-z0-9\\+\\/]/g, ''));\n    };\n    var _decode = buffer ?\n        buffer.from && Uint8Array && buffer.from !== Uint8Array.from\n        ? function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : buffer.from(a, 'base64')).toString();\n        }\n        : function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : new buffer(a, 'base64')).toString();\n        }\n        : function(a) { return btou(_atob(a)) };\n    var decode = function(a){\n        return _decode(\n            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })\n                .replace(/[^A-Za-z0-9\\+\\/]/g, '')\n        );\n    };\n    var noConflict = function() {\n        var Base64 = global.Base64;\n        global.Base64 = _Base64;\n        return Base64;\n    };\n    // export Base64\n    global.Base64 = {\n        VERSION: version,\n        atob: atob,\n        btoa: btoa,\n        fromBase64: decode,\n        toBase64: encode,\n        utob: utob,\n        encode: encode,\n        encodeURI: encodeURI,\n        btou: btou,\n        decode: decode,\n        noConflict: noConflict,\n        __buffer__: buffer\n    };\n    // if ES5 is available, make Base64.extendString() available\n    if (typeof Object.defineProperty === 'function') {\n        var noEnum = function(v){\n            return {value:v,enumerable:false,writable:true,configurable:true};\n        };\n        global.Base64.extendString = function () {\n            Object.defineProperty(\n                String.prototype, 'fromBase64', noEnum(function () {\n                    return decode(this)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64', noEnum(function (urisafe) {\n                    return encode(this, urisafe)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64URI', noEnum(function () {\n                    return encode(this, true)\n                }));\n        };\n    }\n    //\n    // export Base64 to the namespace\n    //\n    if (global['Meteor']) { // Meteor.js\n        Base64 = global.Base64;\n    }\n    // module.exports and AMD are mutually exclusive.\n    // module.exports has precedence.\n    if ( true && module.exports) {\n        module.exports.Base64 = global.Base64;\n    }\n    else if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){ return global.Base64 }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    // that's it!\n    return {Base64: global.Base64}\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/js-base64/base64.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/js/3rdparty/buffer.js":
/*!***********************************!*\
  !*** ./src/js/3rdparty/buffer.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.array.iterator */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n\nmodule.exports = function () {\n  \"use strict\";\n\n  var BitBuffer = function (bufferOrLength, mode) {\n    if (typeof bufferOrLength === 'object') {\n      this.bytes = bufferOrLength instanceof Uint8Array ? bufferOrLength : new Uint8Array(bufferOrLength);\n      this.byteLength = this.bytes.length;\n    } else {\n      this.bytes = new Uint8Array(bufferOrLength || 1024 * 1024);\n      this.byteLength = 0;\n    }\n\n    this.mode = mode || BitBuffer.MODE.EXPAND;\n    this.index = 0;\n  };\n\n  BitBuffer.prototype.resize = function (size) {\n    var newBytes = new Uint8Array(size);\n\n    if (this.byteLength !== 0) {\n      this.byteLength = Math.min(this.byteLength, size);\n      newBytes.set(this.bytes, 0, this.byteLength);\n    }\n\n    this.bytes = newBytes;\n    this.index = Math.min(this.index, this.byteLength << 3);\n  };\n\n  BitBuffer.prototype.evict = function (sizeNeeded) {\n    var bytePos = this.index >> 3,\n        available = this.bytes.length - this.byteLength; // If the current index is the write position, we can simply reset both\n    // to 0. Also reset (and throw away yet unread data) if we won't be able\n    // to fit the new data in even after a normal eviction.\n\n    if (this.index === this.byteLength << 3 || sizeNeeded > available + bytePos // emergency evac\n    ) {\n        this.byteLength = 0;\n        this.index = 0;\n        return;\n      } else if (bytePos === 0) {\n      // Nothing read yet - we can't evict anything\n      return;\n    } // Some browsers don't support copyWithin() yet - we may have to do\n    // it manually using set and a subarray\n\n\n    if (this.bytes.copyWithin) {\n      this.bytes.copyWithin(0, bytePos, this.byteLength);\n    } else {\n      this.bytes.set(this.bytes.subarray(bytePos, this.byteLength));\n    }\n\n    this.byteLength = this.byteLength - bytePos;\n    this.index -= bytePos << 3;\n    return;\n  };\n\n  BitBuffer.prototype.write = function (buffers) {\n    var isArrayOfBuffers = typeof buffers[0] === 'object',\n        totalLength = 0,\n        available = this.bytes.length - this.byteLength; // Calculate total byte length\n\n    if (isArrayOfBuffers) {\n      var totalLength = 0;\n\n      for (var i = 0; i < buffers.length; i++) {\n        totalLength += buffers[i].byteLength;\n      }\n    } else {\n      totalLength = buffers.byteLength;\n    } // Do we need to resize or evict?\n\n\n    if (totalLength > available) {\n      if (this.mode === BitBuffer.MODE.EXPAND) {\n        var newSize = Math.max(this.bytes.length * 2, totalLength - available);\n        this.resize(newSize);\n      } else {\n        this.evict(totalLength);\n      }\n    }\n\n    if (isArrayOfBuffers) {\n      for (var i = 0; i < buffers.length; i++) {\n        this.appendSingleBuffer(buffers[i]);\n      }\n    } else {\n      this.appendSingleBuffer(buffers);\n    }\n\n    return totalLength;\n  };\n\n  BitBuffer.prototype.appendSingleBuffer = function (buffer) {\n    buffer = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n    this.bytes.set(buffer, this.byteLength);\n    this.byteLength += buffer.length;\n  };\n\n  BitBuffer.prototype.findNextStartCode = function () {\n    for (var i = this.index + 7 >> 3; i < this.byteLength; i++) {\n      if (this.bytes[i] == 0x00 && this.bytes[i + 1] == 0x00 && this.bytes[i + 2] == 0x01) {\n        this.index = i + 4 << 3;\n        return this.bytes[i + 3];\n      }\n    }\n\n    this.index = this.byteLength << 3;\n    return -1;\n  };\n\n  BitBuffer.prototype.findStartCode = function (code) {\n    var current = 0;\n\n    while (true) {\n      current = this.findNextStartCode();\n\n      if (current === code || current === -1) {\n        return current;\n      }\n    }\n\n    return -1;\n  };\n\n  BitBuffer.prototype.nextBytesAreStartCode = function () {\n    var i = this.index + 7 >> 3;\n    return i >= this.byteLength || this.bytes[i] == 0x00 && this.bytes[i + 1] == 0x00 && this.bytes[i + 2] == 0x01;\n  };\n\n  BitBuffer.prototype.peek = function (count) {\n    var offset = this.index;\n    var value = 0;\n\n    while (count) {\n      var currentByte = this.bytes[offset >> 3],\n          remaining = 8 - (offset & 7),\n          // remaining bits in byte\n      read = remaining < count ? remaining : count,\n          // bits in this run\n      shift = remaining - read,\n          mask = 0xff >> 8 - read;\n      value = value << read | (currentByte & mask << shift) >> shift;\n      offset += read;\n      count -= read;\n    }\n\n    return value;\n  };\n\n  BitBuffer.prototype.read = function (count) {\n    var value = this.peek(count);\n    this.index += count;\n    return value;\n  };\n\n  BitBuffer.prototype.skip = function (count) {\n    return this.index += count;\n  };\n\n  BitBuffer.prototype.rewind = function (count) {\n    this.index = Math.max(this.index - count, 0);\n  };\n\n  BitBuffer.prototype.has = function (count) {\n    return (this.byteLength << 3) - this.index >= count;\n  };\n\n  BitBuffer.MODE = {\n    EVICT: 1,\n    EXPAND: 2\n  };\n  return BitBuffer;\n}();\n\n//# sourceURL=webpack:///./src/js/3rdparty/buffer.js?");

/***/ }),

/***/ "./src/js/3rdparty/decoder.js":
/*!************************************!*\
  !*** ./src/js/3rdparty/decoder.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function () {\n  \"use strict\";\n\n  var BaseDecoder = function (options) {\n    this.destination = null;\n    this.canPlay = false;\n    this.collectTimestamps = !options.streaming;\n    this.bytesWritten = 0;\n    this.timestamps = [];\n    this.timestampIndex = 0;\n    this.startTime = 0;\n    this.decodedTime = 0;\n    Object.defineProperty(this, 'currentTime', {\n      get: this.getCurrentTime\n    });\n  };\n\n  BaseDecoder.prototype.destroy = function () {};\n\n  BaseDecoder.prototype.connect = function (destination) {\n    this.destination = destination;\n  };\n\n  BaseDecoder.prototype.bufferGetIndex = function () {\n    return this.bits.index;\n  };\n\n  BaseDecoder.prototype.bufferSetIndex = function (index) {\n    this.bits.index = index;\n  };\n\n  BaseDecoder.prototype.bufferWrite = function (buffers) {\n    return this.bits.write(buffers);\n  };\n\n  BaseDecoder.prototype.write = function (pts, buffers) {\n    if (this.collectTimestamps) {\n      if (this.timestamps.length === 0) {\n        this.startTime = pts;\n        this.decodedTime = pts;\n      }\n\n      this.timestamps.push({\n        index: this.bytesWritten << 3,\n        time: pts\n      });\n    }\n\n    this.bytesWritten += this.bufferWrite(buffers);\n    this.canPlay = true;\n  };\n\n  BaseDecoder.prototype.seek = function (time) {\n    if (!this.collectTimestamps) {\n      return;\n    }\n\n    this.timestampIndex = 0;\n\n    for (var i = 0; i < this.timestamps.length; i++) {\n      if (this.timestamps[i].time > time) {\n        break;\n      }\n\n      this.timestampIndex = i;\n    }\n\n    var ts = this.timestamps[this.timestampIndex];\n\n    if (ts) {\n      this.bufferSetIndex(ts.index);\n      this.decodedTime = ts.time;\n    } else {\n      this.bufferSetIndex(0);\n      this.decodedTime = this.startTime;\n    }\n  };\n\n  BaseDecoder.prototype.decode = function () {\n    this.advanceDecodedTime(0);\n  };\n\n  BaseDecoder.prototype.advanceDecodedTime = function (seconds) {\n    if (this.collectTimestamps) {\n      var newTimestampIndex = -1;\n      var currentIndex = this.bufferGetIndex();\n\n      for (var i = this.timestampIndex; i < this.timestamps.length; i++) {\n        if (this.timestamps[i].index > currentIndex) {\n          break;\n        }\n\n        newTimestampIndex = i;\n      } // Did we find a new PTS, different from the last? If so, we don't have\n      // to advance the decoded time manually and can instead sync it exactly\n      // to the PTS.\n\n\n      if (newTimestampIndex !== -1 && newTimestampIndex !== this.timestampIndex) {\n        this.timestampIndex = newTimestampIndex;\n        this.decodedTime = this.timestamps[this.timestampIndex].time;\n        return;\n      }\n    }\n\n    this.decodedTime += seconds;\n  };\n\n  BaseDecoder.prototype.getCurrentTime = function () {\n    return this.decodedTime;\n  };\n\n  return BaseDecoder;\n}();\n\n//# sourceURL=webpack:///./src/js/3rdparty/decoder.js?");

/***/ }),

/***/ "./src/js/3rdparty/jsmpeg.js":
/*!***********************************!*\
  !*** ./src/js/3rdparty/jsmpeg.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*! jsmpeg v1.0 | (c) Dominic Szablewski | MIT license */\n// This sets up the JSMpeg \"Namespace\". The object is empty apart from the Now()\n// utility function and the automatic CreateVideoElements() after DOMReady.\nmodule.exports = {\n  // The Player sets up the connections between source, demuxer, decoders,\n  // renderer and audio output. It ties everything together, is responsible\n  // of scheduling decoding and provides some convenience methods for\n  // external users.\n  Player: null,\n  // A Video Element wraps the Player, shows HTML controls to start/pause\n  // the video and handles Audio unlocking on iOS. VideoElements can be\n  // created directly in HTML using the <div class=\"jsmpeg\"/> tag.\n  VideoElement: null,\n  // The BitBuffer wraps a Uint8Array and allows reading an arbitrary number\n  // of bits at a time. On writing, the BitBuffer either expands its\n  // internal buffer (for static files) or deletes old data (for streaming).\n  BitBuffer: null,\n  // A Source provides raw data from HTTP, a WebSocket connection or any\n  // other mean. Sources must support the following API:\n  //   .connect(destinationNode)\n  //   .write(buffer)\n  //   .start() - start reading\n  //   .resume(headroom) - continue reading; headroom to play pos in seconds\n  //   .established - boolean, true after connection is established\n  //   .completed - boolean, true if the source is completely loaded\n  //   .progress - float 0-1\n  Source: {},\n  // A Demuxer may sit between a Source and a Decoder. It separates the\n  // incoming raw data into Video, Audio and other Streams. API:\n  //   .connect(streamId, destinationNode)\n  //   .write(buffer)\n  //   .currentTime  float, in seconds\n  //   .startTime - float, in seconds\n  Demuxer: {},\n  // A Decoder accepts an incoming Stream of raw Audio or Video data, buffers\n  // it and upon `.decode()` decodes a single frame of data. Video decoders\n  // call `destinationNode.render(Y, Cr, CB)` with the decoded pixel data;\n  // Audio decoders call `destinationNode.play(left, right)` with the decoded\n  // PCM data. API:\n  //   .connect(destinationNode)\n  //   .write(pts, buffer)\n  //   .decode()\n  //   .seek(time)\n  //   .currentTime - float, in seconds\n  //   .startTime - float, in seconds\n  Decoder: {},\n  // A Renderer accepts raw YCrCb data in 3 separate buffers via the render()\n  // method. Renderers typically convert the data into the RGBA color space\n  // and draw it on a Canvas, but other output - such as writing PNGs - would\n  // be conceivable. API:\n  //   .render(y, cr, cb) - pixel data as Uint8Arrays\n  //   .enabled - wether the renderer does anything upon receiving data\n  Renderer: {},\n  // Audio Outputs accept raw Stero PCM data in 2 separate buffers via the\n  // play() method. Outputs typically play the audio on the user's device.\n  // API:\n  //   .play(sampleRate, left, right) - rate in herz; PCM data as Uint8Arrays\n  //   .stop()\n  //   .enqueuedTime - float, in seconds\n  //   .enabled - wether the output does anything upon receiving data\n  AudioOutput: {},\n  Now: function () {\n    return Date.now() / 1000;\n  },\n  Fill: function (array, value) {\n    if (array.fill) {\n      array.fill(value);\n    } else {\n      for (var i = 0; i < array.length; i++) {\n        array[i] = value;\n      }\n    }\n  },\n  // The build process may append `JSMpeg.WASM_BINARY_INLINED = base64data;`\n  // to the minified source.\n  // If this property is present, jsmpeg will use the inlined binary data\n  // instead of trying to load a jsmpeg.wasm file via Ajax.\n  WASM_BINARY_INLINED: null\n};\n\n//# sourceURL=webpack:///./src/js/3rdparty/jsmpeg.js?");

/***/ }),

/***/ "./src/js/3rdparty/mpeg1.js":
/*!**********************************!*\
  !*** ./src/js/3rdparty/mpeg1.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.array.iterator */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n\nconst BaseDecoder = __webpack_require__(/*! ./decoder */ \"./src/js/3rdparty/decoder.js\");\n\nconst BitBuffer = __webpack_require__(/*! ./buffer */ \"./src/js/3rdparty/buffer.js\");\n\nconst now = __webpack_require__(/*! ./jsmpeg */ \"./src/js/3rdparty/jsmpeg.js\").Now;\n\nconst fill = __webpack_require__(/*! ./jsmpeg */ \"./src/js/3rdparty/jsmpeg.js\").Fill;\n\nmodule.exports = function () {\n  \"use strict\"; // Inspired by Java MPEG-1 Video Decoder and Player by Zoltan Korandi\n  // https://sourceforge.net/projects/javampeg1video/\n\n  var MPEG1 = function (options) {\n    BaseDecoder.call(this, options);\n    this.onDecodeCallback = options.onVideoDecode;\n    var bufferSize = options.videoBufferSize || 8 * 1024 * 1024;\n    var bufferMode = BitBuffer.MODE.EXPAND;\n    this.bits = new BitBuffer(bufferSize, bufferMode);\n    this.customIntraQuantMatrix = new Uint8Array(64);\n    this.customNonIntraQuantMatrix = new Uint8Array(64);\n    this.blockData = new Int32Array(64);\n    this.currentFrame = 0;\n    this.decodeFirstFrame = options.decodeFirstFrame !== false;\n  };\n\n  MPEG1.prototype = Object.create(BaseDecoder.prototype);\n  MPEG1.prototype.constructor = MPEG1;\n\n  MPEG1.prototype.write = function (pts, buffers) {\n    BaseDecoder.prototype.write.call(this, pts, buffers);\n\n    if (!this.hasSequenceHeader) {\n      if (this.bits.findStartCode(MPEG1.START.SEQUENCE) === -1) {\n        return false;\n      }\n\n      this.decodeSequenceHeader();\n\n      if (this.decodeFirstFrame) {\n        console.log(\"decodeFirstFrame\");\n        this.decode();\n      }\n    }\n  };\n\n  MPEG1.prototype.decode = function () {\n    var startTime = now();\n\n    if (!this.hasSequenceHeader) {\n      return false;\n    }\n\n    if (this.bits.findStartCode(MPEG1.START.PICTURE) === -1) {\n      var bufferedBytes = this.bits.byteLength - (this.bits.index >> 3);\n      return false;\n    }\n\n    const result = this.decodePicture(); // this.advanceDecodedTime(1/this.frameRate);\n    // var elapsedTime = now() - startTime;\n    // if (this.onDecodeCallback) {\n    // \tthis.onDecodeCallback(this, elapsedTime);\n    // }\n\n    return result;\n  };\n\n  MPEG1.prototype.readHuffman = function (codeTable) {\n    var state = 0;\n\n    do {\n      state = codeTable[state + this.bits.read(1)];\n    } while (state >= 0 && codeTable[state] !== 0);\n\n    return codeTable[state + 2];\n  }; // Sequence Layer\n\n\n  MPEG1.prototype.frameRate = 29.97;\n\n  MPEG1.prototype.decodeSequenceHeader = function () {\n    var newWidth = this.bits.read(12),\n        newHeight = this.bits.read(12); // skip pixel aspect ratio\n\n    this.bits.skip(4);\n    this.frameRate = MPEG1.PICTURE_RATE[this.bits.read(4)]; // skip bitRate, marker, bufferSize and constrained bit\n\n    this.bits.skip(18 + 1 + 10 + 1);\n\n    if (newWidth !== this.width || newHeight !== this.height) {\n      this.width = newWidth;\n      this.height = newHeight;\n      this.initBuffers();\n\n      if (this.destination) {\n        this.destination.resize(newWidth, newHeight);\n      }\n    }\n\n    if (this.bits.read(1)) {\n      // load custom intra quant matrix?\n      for (var i = 0; i < 64; i++) {\n        this.customIntraQuantMatrix[MPEG1.ZIG_ZAG[i]] = this.bits.read(8);\n      }\n\n      this.intraQuantMatrix = this.customIntraQuantMatrix;\n    }\n\n    if (this.bits.read(1)) {\n      // load custom non intra quant matrix?\n      for (var i = 0; i < 64; i++) {\n        var idx = MPEG1.ZIG_ZAG[i];\n        this.customNonIntraQuantMatrix[idx] = this.bits.read(8);\n      }\n\n      this.nonIntraQuantMatrix = this.customNonIntraQuantMatrix;\n    }\n\n    this.hasSequenceHeader = true;\n  };\n\n  MPEG1.prototype.initBuffers = function () {\n    this.intraQuantMatrix = MPEG1.DEFAULT_INTRA_QUANT_MATRIX;\n    this.nonIntraQuantMatrix = MPEG1.DEFAULT_NON_INTRA_QUANT_MATRIX;\n    this.mbWidth = this.width + 15 >> 4;\n    this.mbHeight = this.height + 15 >> 4;\n    this.mbSize = this.mbWidth * this.mbHeight;\n    this.codedWidth = this.mbWidth << 4;\n    this.codedHeight = this.mbHeight << 4;\n    this.codedSize = this.codedWidth * this.codedHeight;\n    this.halfWidth = this.mbWidth << 3;\n    this.halfHeight = this.mbHeight << 3; // Allocated buffers and resize the canvas\n\n    this.currentY = new Uint8ClampedArray(this.codedSize);\n    this.currentY32 = new Uint32Array(this.currentY.buffer);\n    this.currentCr = new Uint8ClampedArray(this.codedSize >> 2);\n    this.currentCr32 = new Uint32Array(this.currentCr.buffer);\n    this.currentCb = new Uint8ClampedArray(this.codedSize >> 2);\n    this.currentCb32 = new Uint32Array(this.currentCb.buffer);\n    this.forwardY = new Uint8ClampedArray(this.codedSize);\n    this.forwardY32 = new Uint32Array(this.forwardY.buffer);\n    this.forwardCr = new Uint8ClampedArray(this.codedSize >> 2);\n    this.forwardCr32 = new Uint32Array(this.forwardCr.buffer);\n    this.forwardCb = new Uint8ClampedArray(this.codedSize >> 2);\n    this.forwardCb32 = new Uint32Array(this.forwardCb.buffer);\n  }; // Picture Layer\n\n\n  MPEG1.prototype.currentY = null;\n  MPEG1.prototype.currentCr = null;\n  MPEG1.prototype.currentCb = null;\n  MPEG1.prototype.pictureType = 0; // Buffers for motion compensation\n\n  MPEG1.prototype.forwardY = null;\n  MPEG1.prototype.forwardCr = null;\n  MPEG1.prototype.forwardCb = null;\n  MPEG1.prototype.fullPelForward = false;\n  MPEG1.prototype.forwardFCode = 0;\n  MPEG1.prototype.forwardRSize = 0;\n  MPEG1.prototype.forwardF = 0;\n\n  MPEG1.prototype.decodePicture = function (skipOutput) {\n    this.currentFrame++;\n    this.bits.skip(10); // skip temporalReference\n\n    this.pictureType = this.bits.read(3);\n    this.bits.skip(16); // skip vbv_delay\n    // Skip B and D frames or unknown coding type\n\n    if (this.pictureType <= 0 || this.pictureType >= MPEG1.PICTURE_TYPE.B) {\n      return;\n    } // full_pel_forward, forward_f_code\n\n\n    if (this.pictureType === MPEG1.PICTURE_TYPE.PREDICTIVE) {\n      this.fullPelForward = this.bits.read(1);\n      this.forwardFCode = this.bits.read(3);\n\n      if (this.forwardFCode === 0) {\n        // Ignore picture with zero forward_f_code\n        return;\n      }\n\n      this.forwardRSize = this.forwardFCode - 1;\n      this.forwardF = 1 << this.forwardRSize;\n    }\n\n    var code = 0;\n\n    do {\n      code = this.bits.findNextStartCode();\n    } while (code === MPEG1.START.EXTENSION || code === MPEG1.START.USER_DATA);\n\n    while (code >= MPEG1.START.SLICE_FIRST && code <= MPEG1.START.SLICE_LAST) {\n      this.decodeSlice(code & 0x000000FF);\n      code = this.bits.findNextStartCode();\n    }\n\n    if (code !== -1) {\n      // We found the next start code; rewind 32bits and let the main loop\n      // handle it.\n      this.bits.rewind(32);\n    }\n\n    let curY = this.currentY;\n    let curCr = this.currentCr;\n    let curCb = this.currentCb; // If this is a reference picutre then rotate the prediction pointers\n\n    if (this.pictureType === MPEG1.PICTURE_TYPE.INTRA || this.pictureType === MPEG1.PICTURE_TYPE.PREDICTIVE) {\n      var tmpY = this.forwardY,\n          tmpY32 = this.forwardY32,\n          tmpCr = this.forwardCr,\n          tmpCr32 = this.forwardCr32,\n          tmpCb = this.forwardCb,\n          tmpCb32 = this.forwardCb32;\n      this.forwardY = this.currentY;\n      this.forwardY32 = this.currentY32;\n      this.forwardCr = this.currentCr;\n      this.forwardCr32 = this.currentCr32;\n      this.forwardCb = this.currentCb;\n      this.forwardCb32 = this.currentCb32;\n      this.currentY = tmpY;\n      this.currentY32 = tmpY32;\n      this.currentCr = tmpCr;\n      this.currentCr32 = tmpCr32;\n      this.currentCb = tmpCb;\n      this.currentCb32 = tmpCb32;\n    }\n\n    return [curY, curCr, curCb];\n  }; // Slice Layer\n\n\n  MPEG1.prototype.quantizerScale = 0;\n  MPEG1.prototype.sliceBegin = false;\n\n  MPEG1.prototype.decodeSlice = function (slice) {\n    this.sliceBegin = true;\n    this.macroblockAddress = (slice - 1) * this.mbWidth - 1; // Reset motion vectors and DC predictors\n\n    this.motionFwH = this.motionFwHPrev = 0;\n    this.motionFwV = this.motionFwVPrev = 0;\n    this.dcPredictorY = 128;\n    this.dcPredictorCr = 128;\n    this.dcPredictorCb = 128;\n    this.quantizerScale = this.bits.read(5); // skip extra bits\n\n    while (this.bits.read(1)) {\n      this.bits.skip(8);\n    }\n\n    do {\n      this.decodeMacroblock();\n    } while (!this.bits.nextBytesAreStartCode());\n  }; // Macroblock Layer\n\n\n  MPEG1.prototype.macroblockAddress = 0;\n  MPEG1.prototype.mbRow = 0;\n  MPEG1.prototype.mbCol = 0;\n  MPEG1.prototype.macroblockType = 0;\n  MPEG1.prototype.macroblockIntra = false;\n  MPEG1.prototype.macroblockMotFw = false;\n  MPEG1.prototype.motionFwH = 0;\n  MPEG1.prototype.motionFwV = 0;\n  MPEG1.prototype.motionFwHPrev = 0;\n  MPEG1.prototype.motionFwVPrev = 0;\n\n  MPEG1.prototype.decodeMacroblock = function () {\n    // Decode macroblock_address_increment\n    var increment = 0,\n        t = this.readHuffman(MPEG1.MACROBLOCK_ADDRESS_INCREMENT);\n\n    while (t === 34) {\n      // macroblock_stuffing\n      t = this.readHuffman(MPEG1.MACROBLOCK_ADDRESS_INCREMENT);\n    }\n\n    while (t === 35) {\n      // macroblock_escape\n      increment += 33;\n      t = this.readHuffman(MPEG1.MACROBLOCK_ADDRESS_INCREMENT);\n    }\n\n    increment += t; // Process any skipped macroblocks\n\n    if (this.sliceBegin) {\n      // The first macroblock_address_increment of each slice is relative\n      // to beginning of the preverious row, not the preverious macroblock\n      this.sliceBegin = false;\n      this.macroblockAddress += increment;\n    } else {\n      if (this.macroblockAddress + increment >= this.mbSize) {\n        // Illegal (too large) macroblock_address_increment\n        return;\n      }\n\n      if (increment > 1) {\n        // Skipped macroblocks reset DC predictors\n        this.dcPredictorY = 128;\n        this.dcPredictorCr = 128;\n        this.dcPredictorCb = 128; // Skipped macroblocks in P-pictures reset motion vectors\n\n        if (this.pictureType === MPEG1.PICTURE_TYPE.PREDICTIVE) {\n          this.motionFwH = this.motionFwHPrev = 0;\n          this.motionFwV = this.motionFwVPrev = 0;\n        }\n      } // Predict skipped macroblocks\n\n\n      while (increment > 1) {\n        this.macroblockAddress++;\n        this.mbRow = this.macroblockAddress / this.mbWidth | 0;\n        this.mbCol = this.macroblockAddress % this.mbWidth;\n        this.copyMacroblock(this.motionFwH, this.motionFwV, this.forwardY, this.forwardCr, this.forwardCb);\n        increment--;\n      }\n\n      this.macroblockAddress++;\n    }\n\n    this.mbRow = this.macroblockAddress / this.mbWidth | 0;\n    this.mbCol = this.macroblockAddress % this.mbWidth; // Process the current macroblock\n\n    var mbTable = MPEG1.MACROBLOCK_TYPE[this.pictureType];\n    this.macroblockType = this.readHuffman(mbTable);\n    this.macroblockIntra = this.macroblockType & 0x01;\n    this.macroblockMotFw = this.macroblockType & 0x08; // Quantizer scale\n\n    if ((this.macroblockType & 0x10) !== 0) {\n      this.quantizerScale = this.bits.read(5);\n    }\n\n    if (this.macroblockIntra) {\n      // Intra-coded macroblocks reset motion vectors\n      this.motionFwH = this.motionFwHPrev = 0;\n      this.motionFwV = this.motionFwVPrev = 0;\n    } else {\n      // Non-intra macroblocks reset DC predictors\n      this.dcPredictorY = 128;\n      this.dcPredictorCr = 128;\n      this.dcPredictorCb = 128;\n      this.decodeMotionVectors();\n      this.copyMacroblock(this.motionFwH, this.motionFwV, this.forwardY, this.forwardCr, this.forwardCb);\n    } // Decode blocks\n\n\n    var cbp = (this.macroblockType & 0x02) !== 0 ? this.readHuffman(MPEG1.CODE_BLOCK_PATTERN) : this.macroblockIntra ? 0x3f : 0;\n\n    for (var block = 0, mask = 0x20; block < 6; block++) {\n      if ((cbp & mask) !== 0) {\n        this.decodeBlock(block);\n      }\n\n      mask >>= 1;\n    }\n  };\n\n  MPEG1.prototype.decodeMotionVectors = function () {\n    var code,\n        d,\n        r = 0; // Forward\n\n    if (this.macroblockMotFw) {\n      // Horizontal forward\n      code = this.readHuffman(MPEG1.MOTION);\n\n      if (code !== 0 && this.forwardF !== 1) {\n        r = this.bits.read(this.forwardRSize);\n        d = (Math.abs(code) - 1 << this.forwardRSize) + r + 1;\n\n        if (code < 0) {\n          d = -d;\n        }\n      } else {\n        d = code;\n      }\n\n      this.motionFwHPrev += d;\n\n      if (this.motionFwHPrev > (this.forwardF << 4) - 1) {\n        this.motionFwHPrev -= this.forwardF << 5;\n      } else if (this.motionFwHPrev < -this.forwardF << 4) {\n        this.motionFwHPrev += this.forwardF << 5;\n      }\n\n      this.motionFwH = this.motionFwHPrev;\n\n      if (this.fullPelForward) {\n        this.motionFwH <<= 1;\n      } // Vertical forward\n\n\n      code = this.readHuffman(MPEG1.MOTION);\n\n      if (code !== 0 && this.forwardF !== 1) {\n        r = this.bits.read(this.forwardRSize);\n        d = (Math.abs(code) - 1 << this.forwardRSize) + r + 1;\n\n        if (code < 0) {\n          d = -d;\n        }\n      } else {\n        d = code;\n      }\n\n      this.motionFwVPrev += d;\n\n      if (this.motionFwVPrev > (this.forwardF << 4) - 1) {\n        this.motionFwVPrev -= this.forwardF << 5;\n      } else if (this.motionFwVPrev < -this.forwardF << 4) {\n        this.motionFwVPrev += this.forwardF << 5;\n      }\n\n      this.motionFwV = this.motionFwVPrev;\n\n      if (this.fullPelForward) {\n        this.motionFwV <<= 1;\n      }\n    } else if (this.pictureType === MPEG1.PICTURE_TYPE.PREDICTIVE) {\n      // No motion information in P-picture, reset vectors\n      this.motionFwH = this.motionFwHPrev = 0;\n      this.motionFwV = this.motionFwVPrev = 0;\n    }\n  };\n\n  MPEG1.prototype.copyMacroblock = function (motionH, motionV, sY, sCr, sCb) {\n    var width, scan, H, V, oddH, oddV, src, dest, last; // We use 32bit writes here\n\n    var dY = this.currentY32,\n        dCb = this.currentCb32,\n        dCr = this.currentCr32; // Luminance\n\n    width = this.codedWidth;\n    scan = width - 16;\n    H = motionH >> 1;\n    V = motionV >> 1;\n    oddH = (motionH & 1) === 1;\n    oddV = (motionV & 1) === 1;\n    src = ((this.mbRow << 4) + V) * width + (this.mbCol << 4) + H;\n    dest = this.mbRow * width + this.mbCol << 2;\n    last = dest + (width << 2);\n    var x, y1, y2, y;\n\n    if (oddH) {\n      if (oddV) {\n        while (dest < last) {\n          y1 = sY[src] + sY[src + width];\n          src++;\n\n          for (x = 0; x < 4; x++) {\n            y2 = sY[src] + sY[src + width];\n            src++;\n            y = y1 + y2 + 2 >> 2 & 0xff;\n            y1 = sY[src] + sY[src + width];\n            src++;\n            y |= y1 + y2 + 2 << 6 & 0xff00;\n            y2 = sY[src] + sY[src + width];\n            src++;\n            y |= y1 + y2 + 2 << 14 & 0xff0000;\n            y1 = sY[src] + sY[src + width];\n            src++;\n            y |= y1 + y2 + 2 << 22 & 0xff000000;\n            dY[dest++] = y;\n          }\n\n          dest += scan >> 2;\n          src += scan - 1;\n        }\n      } else {\n        while (dest < last) {\n          y1 = sY[src++];\n\n          for (x = 0; x < 4; x++) {\n            y2 = sY[src++];\n            y = y1 + y2 + 1 >> 1 & 0xff;\n            y1 = sY[src++];\n            y |= y1 + y2 + 1 << 7 & 0xff00;\n            y2 = sY[src++];\n            y |= y1 + y2 + 1 << 15 & 0xff0000;\n            y1 = sY[src++];\n            y |= y1 + y2 + 1 << 23 & 0xff000000;\n            dY[dest++] = y;\n          }\n\n          dest += scan >> 2;\n          src += scan - 1;\n        }\n      }\n    } else {\n      if (oddV) {\n        while (dest < last) {\n          for (x = 0; x < 4; x++) {\n            y = sY[src] + sY[src + width] + 1 >> 1 & 0xff;\n            src++;\n            y |= sY[src] + sY[src + width] + 1 << 7 & 0xff00;\n            src++;\n            y |= sY[src] + sY[src + width] + 1 << 15 & 0xff0000;\n            src++;\n            y |= sY[src] + sY[src + width] + 1 << 23 & 0xff000000;\n            src++;\n            dY[dest++] = y;\n          }\n\n          dest += scan >> 2;\n          src += scan;\n        }\n      } else {\n        while (dest < last) {\n          for (x = 0; x < 4; x++) {\n            y = sY[src];\n            src++;\n            y |= sY[src] << 8;\n            src++;\n            y |= sY[src] << 16;\n            src++;\n            y |= sY[src] << 24;\n            src++;\n            dY[dest++] = y;\n          }\n\n          dest += scan >> 2;\n          src += scan;\n        }\n      }\n    } // Chrominance\n\n\n    width = this.halfWidth;\n    scan = width - 8;\n    H = motionH / 2 >> 1;\n    V = motionV / 2 >> 1;\n    oddH = (motionH / 2 & 1) === 1;\n    oddV = (motionV / 2 & 1) === 1;\n    src = ((this.mbRow << 3) + V) * width + (this.mbCol << 3) + H;\n    dest = this.mbRow * width + this.mbCol << 1;\n    last = dest + (width << 1);\n    var cr1, cr2, cr, cb1, cb2, cb;\n\n    if (oddH) {\n      if (oddV) {\n        while (dest < last) {\n          cr1 = sCr[src] + sCr[src + width];\n          cb1 = sCb[src] + sCb[src + width];\n          src++;\n\n          for (x = 0; x < 2; x++) {\n            cr2 = sCr[src] + sCr[src + width];\n            cb2 = sCb[src] + sCb[src + width];\n            src++;\n            cr = cr1 + cr2 + 2 >> 2 & 0xff;\n            cb = cb1 + cb2 + 2 >> 2 & 0xff;\n            cr1 = sCr[src] + sCr[src + width];\n            cb1 = sCb[src] + sCb[src + width];\n            src++;\n            cr |= cr1 + cr2 + 2 << 6 & 0xff00;\n            cb |= cb1 + cb2 + 2 << 6 & 0xff00;\n            cr2 = sCr[src] + sCr[src + width];\n            cb2 = sCb[src] + sCb[src + width];\n            src++;\n            cr |= cr1 + cr2 + 2 << 14 & 0xff0000;\n            cb |= cb1 + cb2 + 2 << 14 & 0xff0000;\n            cr1 = sCr[src] + sCr[src + width];\n            cb1 = sCb[src] + sCb[src + width];\n            src++;\n            cr |= cr1 + cr2 + 2 << 22 & 0xff000000;\n            cb |= cb1 + cb2 + 2 << 22 & 0xff000000;\n            dCr[dest] = cr;\n            dCb[dest] = cb;\n            dest++;\n          }\n\n          dest += scan >> 2;\n          src += scan - 1;\n        }\n      } else {\n        while (dest < last) {\n          cr1 = sCr[src];\n          cb1 = sCb[src];\n          src++;\n\n          for (x = 0; x < 2; x++) {\n            cr2 = sCr[src];\n            cb2 = sCb[src++];\n            cr = cr1 + cr2 + 1 >> 1 & 0xff;\n            cb = cb1 + cb2 + 1 >> 1 & 0xff;\n            cr1 = sCr[src];\n            cb1 = sCb[src++];\n            cr |= cr1 + cr2 + 1 << 7 & 0xff00;\n            cb |= cb1 + cb2 + 1 << 7 & 0xff00;\n            cr2 = sCr[src];\n            cb2 = sCb[src++];\n            cr |= cr1 + cr2 + 1 << 15 & 0xff0000;\n            cb |= cb1 + cb2 + 1 << 15 & 0xff0000;\n            cr1 = sCr[src];\n            cb1 = sCb[src++];\n            cr |= cr1 + cr2 + 1 << 23 & 0xff000000;\n            cb |= cb1 + cb2 + 1 << 23 & 0xff000000;\n            dCr[dest] = cr;\n            dCb[dest] = cb;\n            dest++;\n          }\n\n          dest += scan >> 2;\n          src += scan - 1;\n        }\n      }\n    } else {\n      if (oddV) {\n        while (dest < last) {\n          for (x = 0; x < 2; x++) {\n            cr = sCr[src] + sCr[src + width] + 1 >> 1 & 0xff;\n            cb = sCb[src] + sCb[src + width] + 1 >> 1 & 0xff;\n            src++;\n            cr |= sCr[src] + sCr[src + width] + 1 << 7 & 0xff00;\n            cb |= sCb[src] + sCb[src + width] + 1 << 7 & 0xff00;\n            src++;\n            cr |= sCr[src] + sCr[src + width] + 1 << 15 & 0xff0000;\n            cb |= sCb[src] + sCb[src + width] + 1 << 15 & 0xff0000;\n            src++;\n            cr |= sCr[src] + sCr[src + width] + 1 << 23 & 0xff000000;\n            cb |= sCb[src] + sCb[src + width] + 1 << 23 & 0xff000000;\n            src++;\n            dCr[dest] = cr;\n            dCb[dest] = cb;\n            dest++;\n          }\n\n          dest += scan >> 2;\n          src += scan;\n        }\n      } else {\n        while (dest < last) {\n          for (x = 0; x < 2; x++) {\n            cr = sCr[src];\n            cb = sCb[src];\n            src++;\n            cr |= sCr[src] << 8;\n            cb |= sCb[src] << 8;\n            src++;\n            cr |= sCr[src] << 16;\n            cb |= sCb[src] << 16;\n            src++;\n            cr |= sCr[src] << 24;\n            cb |= sCb[src] << 24;\n            src++;\n            dCr[dest] = cr;\n            dCb[dest] = cb;\n            dest++;\n          }\n\n          dest += scan >> 2;\n          src += scan;\n        }\n      }\n    }\n  }; // Block layer\n\n\n  MPEG1.prototype.dcPredictorY = 0;\n  MPEG1.prototype.dcPredictorCr = 0;\n  MPEG1.prototype.dcPredictorCb = 0;\n  MPEG1.prototype.blockData = null;\n\n  MPEG1.prototype.decodeBlock = function (block) {\n    var n = 0,\n        quantMatrix; // Decode DC coefficient of intra-coded blocks\n\n    if (this.macroblockIntra) {\n      var predictor, dctSize; // DC prediction\n\n      if (block < 4) {\n        predictor = this.dcPredictorY;\n        dctSize = this.readHuffman(MPEG1.DCT_DC_SIZE_LUMINANCE);\n      } else {\n        predictor = block === 4 ? this.dcPredictorCr : this.dcPredictorCb;\n        dctSize = this.readHuffman(MPEG1.DCT_DC_SIZE_CHROMINANCE);\n      } // Read DC coeff\n\n\n      if (dctSize > 0) {\n        var differential = this.bits.read(dctSize);\n\n        if ((differential & 1 << dctSize - 1) !== 0) {\n          this.blockData[0] = predictor + differential;\n        } else {\n          this.blockData[0] = predictor + (-1 << dctSize | differential + 1);\n        }\n      } else {\n        this.blockData[0] = predictor;\n      } // Save predictor value\n\n\n      if (block < 4) {\n        this.dcPredictorY = this.blockData[0];\n      } else if (block === 4) {\n        this.dcPredictorCr = this.blockData[0];\n      } else {\n        this.dcPredictorCb = this.blockData[0];\n      } // Dequantize + premultiply\n\n\n      this.blockData[0] <<= 3 + 5;\n      quantMatrix = this.intraQuantMatrix;\n      n = 1;\n    } else {\n      quantMatrix = this.nonIntraQuantMatrix;\n    } // Decode AC coefficients (+DC for non-intra)\n\n\n    var level = 0;\n\n    while (true) {\n      var run = 0,\n          coeff = this.readHuffman(MPEG1.DCT_COEFF);\n\n      if (coeff === 0x0001 && n > 0 && this.bits.read(1) === 0) {\n        // end_of_block\n        break;\n      }\n\n      if (coeff === 0xffff) {\n        // escape\n        run = this.bits.read(6);\n        level = this.bits.read(8);\n\n        if (level === 0) {\n          level = this.bits.read(8);\n        } else if (level === 128) {\n          level = this.bits.read(8) - 256;\n        } else if (level > 128) {\n          level = level - 256;\n        }\n      } else {\n        run = coeff >> 8;\n        level = coeff & 0xff;\n\n        if (this.bits.read(1)) {\n          level = -level;\n        }\n      }\n\n      n += run;\n      var dezigZagged = MPEG1.ZIG_ZAG[n];\n      n++; // Dequantize, oddify, clip\n\n      level <<= 1;\n\n      if (!this.macroblockIntra) {\n        level += level < 0 ? -1 : 1;\n      }\n\n      level = level * this.quantizerScale * quantMatrix[dezigZagged] >> 4;\n\n      if ((level & 1) === 0) {\n        level -= level > 0 ? 1 : -1;\n      }\n\n      if (level > 2047) {\n        level = 2047;\n      } else if (level < -2048) {\n        level = -2048;\n      } // Save premultiplied coefficient\n\n\n      this.blockData[dezigZagged] = level * MPEG1.PREMULTIPLIER_MATRIX[dezigZagged];\n    } // Move block to its place\n\n\n    var destArray, destIndex, scan;\n\n    if (block < 4) {\n      destArray = this.currentY;\n      scan = this.codedWidth - 8;\n      destIndex = this.mbRow * this.codedWidth + this.mbCol << 4;\n\n      if ((block & 1) !== 0) {\n        destIndex += 8;\n      }\n\n      if ((block & 2) !== 0) {\n        destIndex += this.codedWidth << 3;\n      }\n    } else {\n      destArray = block === 4 ? this.currentCb : this.currentCr;\n      scan = (this.codedWidth >> 1) - 8;\n      destIndex = (this.mbRow * this.codedWidth << 2) + (this.mbCol << 3);\n    }\n\n    if (this.macroblockIntra) {\n      // Overwrite (no prediction)\n      if (n === 1) {\n        MPEG1.CopyValueToDestination(this.blockData[0] + 128 >> 8, destArray, destIndex, scan);\n        this.blockData[0] = 0;\n      } else {\n        MPEG1.IDCT(this.blockData);\n        MPEG1.CopyBlockToDestination(this.blockData, destArray, destIndex, scan);\n        fill(this.blockData, 0);\n      }\n    } else {\n      // Add data to the predicted macroblock\n      if (n === 1) {\n        MPEG1.AddValueToDestination(this.blockData[0] + 128 >> 8, destArray, destIndex, scan);\n        this.blockData[0] = 0;\n      } else {\n        MPEG1.IDCT(this.blockData);\n        MPEG1.AddBlockToDestination(this.blockData, destArray, destIndex, scan);\n        fill(this.blockData, 0);\n      }\n    }\n\n    n = 0;\n  };\n\n  MPEG1.CopyBlockToDestination = function (block, dest, index, scan) {\n    for (var n = 0; n < 64; n += 8, index += scan + 8) {\n      dest[index + 0] = block[n + 0];\n      dest[index + 1] = block[n + 1];\n      dest[index + 2] = block[n + 2];\n      dest[index + 3] = block[n + 3];\n      dest[index + 4] = block[n + 4];\n      dest[index + 5] = block[n + 5];\n      dest[index + 6] = block[n + 6];\n      dest[index + 7] = block[n + 7];\n    }\n  };\n\n  MPEG1.AddBlockToDestination = function (block, dest, index, scan) {\n    for (var n = 0; n < 64; n += 8, index += scan + 8) {\n      dest[index + 0] += block[n + 0];\n      dest[index + 1] += block[n + 1];\n      dest[index + 2] += block[n + 2];\n      dest[index + 3] += block[n + 3];\n      dest[index + 4] += block[n + 4];\n      dest[index + 5] += block[n + 5];\n      dest[index + 6] += block[n + 6];\n      dest[index + 7] += block[n + 7];\n    }\n  };\n\n  MPEG1.CopyValueToDestination = function (value, dest, index, scan) {\n    for (var n = 0; n < 64; n += 8, index += scan + 8) {\n      dest[index + 0] = value;\n      dest[index + 1] = value;\n      dest[index + 2] = value;\n      dest[index + 3] = value;\n      dest[index + 4] = value;\n      dest[index + 5] = value;\n      dest[index + 6] = value;\n      dest[index + 7] = value;\n    }\n  };\n\n  MPEG1.AddValueToDestination = function (value, dest, index, scan) {\n    for (var n = 0; n < 64; n += 8, index += scan + 8) {\n      dest[index + 0] += value;\n      dest[index + 1] += value;\n      dest[index + 2] += value;\n      dest[index + 3] += value;\n      dest[index + 4] += value;\n      dest[index + 5] += value;\n      dest[index + 6] += value;\n      dest[index + 7] += value;\n    }\n  };\n\n  MPEG1.IDCT = function (block) {\n    // See http://vsr.informatik.tu-chemnitz.de/~jan/MPEG/HTML/IDCT.html\n    // for more info.\n    var b1, b3, b4, b6, b7, tmp1, tmp2, m0, x0, x1, x2, x3, x4, y3, y4, y5, y6, y7; // Transform columns\n\n    for (var i = 0; i < 8; ++i) {\n      b1 = block[4 * 8 + i];\n      b3 = block[2 * 8 + i] + block[6 * 8 + i];\n      b4 = block[5 * 8 + i] - block[3 * 8 + i];\n      tmp1 = block[1 * 8 + i] + block[7 * 8 + i];\n      tmp2 = block[3 * 8 + i] + block[5 * 8 + i];\n      b6 = block[1 * 8 + i] - block[7 * 8 + i];\n      b7 = tmp1 + tmp2;\n      m0 = block[0 * 8 + i];\n      x4 = (b6 * 473 - b4 * 196 + 128 >> 8) - b7;\n      x0 = x4 - ((tmp1 - tmp2) * 362 + 128 >> 8);\n      x1 = m0 - b1;\n      x2 = ((block[2 * 8 + i] - block[6 * 8 + i]) * 362 + 128 >> 8) - b3;\n      x3 = m0 + b1;\n      y3 = x1 + x2;\n      y4 = x3 + b3;\n      y5 = x1 - x2;\n      y6 = x3 - b3;\n      y7 = -x0 - (b4 * 473 + b6 * 196 + 128 >> 8);\n      block[0 * 8 + i] = b7 + y4;\n      block[1 * 8 + i] = x4 + y3;\n      block[2 * 8 + i] = y5 - x0;\n      block[3 * 8 + i] = y6 - y7;\n      block[4 * 8 + i] = y6 + y7;\n      block[5 * 8 + i] = x0 + y5;\n      block[6 * 8 + i] = y3 - x4;\n      block[7 * 8 + i] = y4 - b7;\n    } // Transform rows\n\n\n    for (var i = 0; i < 64; i += 8) {\n      b1 = block[4 + i];\n      b3 = block[2 + i] + block[6 + i];\n      b4 = block[5 + i] - block[3 + i];\n      tmp1 = block[1 + i] + block[7 + i];\n      tmp2 = block[3 + i] + block[5 + i];\n      b6 = block[1 + i] - block[7 + i];\n      b7 = tmp1 + tmp2;\n      m0 = block[0 + i];\n      x4 = (b6 * 473 - b4 * 196 + 128 >> 8) - b7;\n      x0 = x4 - ((tmp1 - tmp2) * 362 + 128 >> 8);\n      x1 = m0 - b1;\n      x2 = ((block[2 + i] - block[6 + i]) * 362 + 128 >> 8) - b3;\n      x3 = m0 + b1;\n      y3 = x1 + x2;\n      y4 = x3 + b3;\n      y5 = x1 - x2;\n      y6 = x3 - b3;\n      y7 = -x0 - (b4 * 473 + b6 * 196 + 128 >> 8);\n      block[0 + i] = b7 + y4 + 128 >> 8;\n      block[1 + i] = x4 + y3 + 128 >> 8;\n      block[2 + i] = y5 - x0 + 128 >> 8;\n      block[3 + i] = y6 - y7 + 128 >> 8;\n      block[4 + i] = y6 + y7 + 128 >> 8;\n      block[5 + i] = x0 + y5 + 128 >> 8;\n      block[6 + i] = y3 - x4 + 128 >> 8;\n      block[7 + i] = y4 - b7 + 128 >> 8;\n    }\n  }; // VLC Tables and Constants\n\n\n  MPEG1.PICTURE_RATE = [0.000, 23.976, 24.000, 25.000, 29.970, 30.000, 50.000, 59.940, 60.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000];\n  MPEG1.ZIG_ZAG = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);\n  MPEG1.DEFAULT_INTRA_QUANT_MATRIX = new Uint8Array([8, 16, 19, 22, 26, 27, 29, 34, 16, 16, 22, 24, 27, 29, 34, 37, 19, 22, 26, 27, 29, 34, 34, 38, 22, 22, 26, 27, 29, 34, 37, 40, 22, 26, 27, 29, 32, 35, 40, 48, 26, 27, 29, 32, 35, 40, 48, 58, 26, 27, 29, 34, 38, 46, 56, 69, 27, 29, 35, 38, 46, 56, 69, 83]);\n  MPEG1.DEFAULT_NON_INTRA_QUANT_MATRIX = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16]);\n  MPEG1.PREMULTIPLIER_MATRIX = new Uint8Array([32, 44, 42, 38, 32, 25, 17, 9, 44, 62, 58, 52, 44, 35, 24, 12, 42, 58, 55, 49, 42, 33, 23, 12, 38, 52, 49, 44, 38, 30, 20, 10, 32, 44, 42, 38, 32, 25, 17, 9, 25, 35, 33, 30, 25, 20, 14, 7, 17, 24, 23, 20, 17, 14, 9, 5, 9, 12, 12, 10, 9, 7, 5, 2]); // MPEG-1 VLC\n  //  macroblock_stuffing decodes as 34.\n  //  macroblock_escape decodes as 35.\n\n  MPEG1.MACROBLOCK_ADDRESS_INCREMENT = new Int16Array([1 * 3, 2 * 3, 0, //   0\n  3 * 3, 4 * 3, 0, //   1  0\n  0, 0, 1, //   2  1.\n  5 * 3, 6 * 3, 0, //   3  00\n  7 * 3, 8 * 3, 0, //   4  01\n  9 * 3, 10 * 3, 0, //   5  000\n  11 * 3, 12 * 3, 0, //   6  001\n  0, 0, 3, //   7  010.\n  0, 0, 2, //   8  011.\n  13 * 3, 14 * 3, 0, //   9  0000\n  15 * 3, 16 * 3, 0, //  10  0001\n  0, 0, 5, //  11  0010.\n  0, 0, 4, //  12  0011.\n  17 * 3, 18 * 3, 0, //  13  0000 0\n  19 * 3, 20 * 3, 0, //  14  0000 1\n  0, 0, 7, //  15  0001 0.\n  0, 0, 6, //  16  0001 1.\n  21 * 3, 22 * 3, 0, //  17  0000 00\n  23 * 3, 24 * 3, 0, //  18  0000 01\n  25 * 3, 26 * 3, 0, //  19  0000 10\n  27 * 3, 28 * 3, 0, //  20  0000 11\n  -1, 29 * 3, 0, //  21  0000 000\n  -1, 30 * 3, 0, //  22  0000 001\n  31 * 3, 32 * 3, 0, //  23  0000 010\n  33 * 3, 34 * 3, 0, //  24  0000 011\n  35 * 3, 36 * 3, 0, //  25  0000 100\n  37 * 3, 38 * 3, 0, //  26  0000 101\n  0, 0, 9, //  27  0000 110.\n  0, 0, 8, //  28  0000 111.\n  39 * 3, 40 * 3, 0, //  29  0000 0001\n  41 * 3, 42 * 3, 0, //  30  0000 0011\n  43 * 3, 44 * 3, 0, //  31  0000 0100\n  45 * 3, 46 * 3, 0, //  32  0000 0101\n  0, 0, 15, //  33  0000 0110.\n  0, 0, 14, //  34  0000 0111.\n  0, 0, 13, //  35  0000 1000.\n  0, 0, 12, //  36  0000 1001.\n  0, 0, 11, //  37  0000 1010.\n  0, 0, 10, //  38  0000 1011.\n  47 * 3, -1, 0, //  39  0000 0001 0\n  -1, 48 * 3, 0, //  40  0000 0001 1\n  49 * 3, 50 * 3, 0, //  41  0000 0011 0\n  51 * 3, 52 * 3, 0, //  42  0000 0011 1\n  53 * 3, 54 * 3, 0, //  43  0000 0100 0\n  55 * 3, 56 * 3, 0, //  44  0000 0100 1\n  57 * 3, 58 * 3, 0, //  45  0000 0101 0\n  59 * 3, 60 * 3, 0, //  46  0000 0101 1\n  61 * 3, -1, 0, //  47  0000 0001 00\n  -1, 62 * 3, 0, //  48  0000 0001 11\n  63 * 3, 64 * 3, 0, //  49  0000 0011 00\n  65 * 3, 66 * 3, 0, //  50  0000 0011 01\n  67 * 3, 68 * 3, 0, //  51  0000 0011 10\n  69 * 3, 70 * 3, 0, //  52  0000 0011 11\n  71 * 3, 72 * 3, 0, //  53  0000 0100 00\n  73 * 3, 74 * 3, 0, //  54  0000 0100 01\n  0, 0, 21, //  55  0000 0100 10.\n  0, 0, 20, //  56  0000 0100 11.\n  0, 0, 19, //  57  0000 0101 00.\n  0, 0, 18, //  58  0000 0101 01.\n  0, 0, 17, //  59  0000 0101 10.\n  0, 0, 16, //  60  0000 0101 11.\n  0, 0, 35, //  61  0000 0001 000. -- macroblock_escape\n  0, 0, 34, //  62  0000 0001 111. -- macroblock_stuffing\n  0, 0, 33, //  63  0000 0011 000.\n  0, 0, 32, //  64  0000 0011 001.\n  0, 0, 31, //  65  0000 0011 010.\n  0, 0, 30, //  66  0000 0011 011.\n  0, 0, 29, //  67  0000 0011 100.\n  0, 0, 28, //  68  0000 0011 101.\n  0, 0, 27, //  69  0000 0011 110.\n  0, 0, 26, //  70  0000 0011 111.\n  0, 0, 25, //  71  0000 0100 000.\n  0, 0, 24, //  72  0000 0100 001.\n  0, 0, 23, //  73  0000 0100 010.\n  0, 0, 22 //  74  0000 0100 011.\n  ]); //  macroblock_type bitmap:\n  //    0x10  macroblock_quant\n  //    0x08  macroblock_motion_forward\n  //    0x04  macroblock_motion_backward\n  //    0x02  macrobkock_pattern\n  //    0x01  macroblock_intra\n  //\n\n  MPEG1.MACROBLOCK_TYPE_INTRA = new Int8Array([1 * 3, 2 * 3, 0, //   0\n  -1, 3 * 3, 0, //   1  0\n  0, 0, 0x01, //   2  1.\n  0, 0, 0x11 //   3  01.\n  ]);\n  MPEG1.MACROBLOCK_TYPE_PREDICTIVE = new Int8Array([1 * 3, 2 * 3, 0, //  0\n  3 * 3, 4 * 3, 0, //  1  0\n  0, 0, 0x0a, //  2  1.\n  5 * 3, 6 * 3, 0, //  3  00\n  0, 0, 0x02, //  4  01.\n  7 * 3, 8 * 3, 0, //  5  000\n  0, 0, 0x08, //  6  001.\n  9 * 3, 10 * 3, 0, //  7  0000\n  11 * 3, 12 * 3, 0, //  8  0001\n  -1, 13 * 3, 0, //  9  00000\n  0, 0, 0x12, // 10  00001.\n  0, 0, 0x1a, // 11  00010.\n  0, 0, 0x01, // 12  00011.\n  0, 0, 0x11 // 13  000001.\n  ]);\n  MPEG1.MACROBLOCK_TYPE_B = new Int8Array([1 * 3, 2 * 3, 0, //  0\n  3 * 3, 5 * 3, 0, //  1  0\n  4 * 3, 6 * 3, 0, //  2  1\n  8 * 3, 7 * 3, 0, //  3  00\n  0, 0, 0x0c, //  4  10.\n  9 * 3, 10 * 3, 0, //  5  01\n  0, 0, 0x0e, //  6  11.\n  13 * 3, 14 * 3, 0, //  7  001\n  12 * 3, 11 * 3, 0, //  8  000\n  0, 0, 0x04, //  9  010.\n  0, 0, 0x06, // 10  011.\n  18 * 3, 16 * 3, 0, // 11  0001\n  15 * 3, 17 * 3, 0, // 12  0000\n  0, 0, 0x08, // 13  0010.\n  0, 0, 0x0a, // 14  0011.\n  -1, 19 * 3, 0, // 15  00000\n  0, 0, 0x01, // 16  00011.\n  20 * 3, 21 * 3, 0, // 17  00001\n  0, 0, 0x1e, // 18  00010.\n  0, 0, 0x11, // 19  000001.\n  0, 0, 0x16, // 20  000010.\n  0, 0, 0x1a // 21  000011.\n  ]);\n  MPEG1.MACROBLOCK_TYPE = [null, MPEG1.MACROBLOCK_TYPE_INTRA, MPEG1.MACROBLOCK_TYPE_PREDICTIVE, MPEG1.MACROBLOCK_TYPE_B];\n  MPEG1.CODE_BLOCK_PATTERN = new Int16Array([2 * 3, 1 * 3, 0, //   0\n  3 * 3, 6 * 3, 0, //   1  1\n  4 * 3, 5 * 3, 0, //   2  0\n  8 * 3, 11 * 3, 0, //   3  10\n  12 * 3, 13 * 3, 0, //   4  00\n  9 * 3, 7 * 3, 0, //   5  01\n  10 * 3, 14 * 3, 0, //   6  11\n  20 * 3, 19 * 3, 0, //   7  011\n  18 * 3, 16 * 3, 0, //   8  100\n  23 * 3, 17 * 3, 0, //   9  010\n  27 * 3, 25 * 3, 0, //  10  110\n  21 * 3, 28 * 3, 0, //  11  101\n  15 * 3, 22 * 3, 0, //  12  000\n  24 * 3, 26 * 3, 0, //  13  001\n  0, 0, 60, //  14  111.\n  35 * 3, 40 * 3, 0, //  15  0000\n  44 * 3, 48 * 3, 0, //  16  1001\n  38 * 3, 36 * 3, 0, //  17  0101\n  42 * 3, 47 * 3, 0, //  18  1000\n  29 * 3, 31 * 3, 0, //  19  0111\n  39 * 3, 32 * 3, 0, //  20  0110\n  0, 0, 32, //  21  1010.\n  45 * 3, 46 * 3, 0, //  22  0001\n  33 * 3, 41 * 3, 0, //  23  0100\n  43 * 3, 34 * 3, 0, //  24  0010\n  0, 0, 4, //  25  1101.\n  30 * 3, 37 * 3, 0, //  26  0011\n  0, 0, 8, //  27  1100.\n  0, 0, 16, //  28  1011.\n  0, 0, 44, //  29  0111 0.\n  50 * 3, 56 * 3, 0, //  30  0011 0\n  0, 0, 28, //  31  0111 1.\n  0, 0, 52, //  32  0110 1.\n  0, 0, 62, //  33  0100 0.\n  61 * 3, 59 * 3, 0, //  34  0010 1\n  52 * 3, 60 * 3, 0, //  35  0000 0\n  0, 0, 1, //  36  0101 1.\n  55 * 3, 54 * 3, 0, //  37  0011 1\n  0, 0, 61, //  38  0101 0.\n  0, 0, 56, //  39  0110 0.\n  57 * 3, 58 * 3, 0, //  40  0000 1\n  0, 0, 2, //  41  0100 1.\n  0, 0, 40, //  42  1000 0.\n  51 * 3, 62 * 3, 0, //  43  0010 0\n  0, 0, 48, //  44  1001 0.\n  64 * 3, 63 * 3, 0, //  45  0001 0\n  49 * 3, 53 * 3, 0, //  46  0001 1\n  0, 0, 20, //  47  1000 1.\n  0, 0, 12, //  48  1001 1.\n  80 * 3, 83 * 3, 0, //  49  0001 10\n  0, 0, 63, //  50  0011 00.\n  77 * 3, 75 * 3, 0, //  51  0010 00\n  65 * 3, 73 * 3, 0, //  52  0000 00\n  84 * 3, 66 * 3, 0, //  53  0001 11\n  0, 0, 24, //  54  0011 11.\n  0, 0, 36, //  55  0011 10.\n  0, 0, 3, //  56  0011 01.\n  69 * 3, 87 * 3, 0, //  57  0000 10\n  81 * 3, 79 * 3, 0, //  58  0000 11\n  68 * 3, 71 * 3, 0, //  59  0010 11\n  70 * 3, 78 * 3, 0, //  60  0000 01\n  67 * 3, 76 * 3, 0, //  61  0010 10\n  72 * 3, 74 * 3, 0, //  62  0010 01\n  86 * 3, 85 * 3, 0, //  63  0001 01\n  88 * 3, 82 * 3, 0, //  64  0001 00\n  -1, 94 * 3, 0, //  65  0000 000\n  95 * 3, 97 * 3, 0, //  66  0001 111\n  0, 0, 33, //  67  0010 100.\n  0, 0, 9, //  68  0010 110.\n  106 * 3, 110 * 3, 0, //  69  0000 100\n  102 * 3, 116 * 3, 0, //  70  0000 010\n  0, 0, 5, //  71  0010 111.\n  0, 0, 10, //  72  0010 010.\n  93 * 3, 89 * 3, 0, //  73  0000 001\n  0, 0, 6, //  74  0010 011.\n  0, 0, 18, //  75  0010 001.\n  0, 0, 17, //  76  0010 101.\n  0, 0, 34, //  77  0010 000.\n  113 * 3, 119 * 3, 0, //  78  0000 011\n  103 * 3, 104 * 3, 0, //  79  0000 111\n  90 * 3, 92 * 3, 0, //  80  0001 100\n  109 * 3, 107 * 3, 0, //  81  0000 110\n  117 * 3, 118 * 3, 0, //  82  0001 001\n  101 * 3, 99 * 3, 0, //  83  0001 101\n  98 * 3, 96 * 3, 0, //  84  0001 110\n  100 * 3, 91 * 3, 0, //  85  0001 011\n  114 * 3, 115 * 3, 0, //  86  0001 010\n  105 * 3, 108 * 3, 0, //  87  0000 101\n  112 * 3, 111 * 3, 0, //  88  0001 000\n  121 * 3, 125 * 3, 0, //  89  0000 0011\n  0, 0, 41, //  90  0001 1000.\n  0, 0, 14, //  91  0001 0111.\n  0, 0, 21, //  92  0001 1001.\n  124 * 3, 122 * 3, 0, //  93  0000 0010\n  120 * 3, 123 * 3, 0, //  94  0000 0001\n  0, 0, 11, //  95  0001 1110.\n  0, 0, 19, //  96  0001 1101.\n  0, 0, 7, //  97  0001 1111.\n  0, 0, 35, //  98  0001 1100.\n  0, 0, 13, //  99  0001 1011.\n  0, 0, 50, // 100  0001 0110.\n  0, 0, 49, // 101  0001 1010.\n  0, 0, 58, // 102  0000 0100.\n  0, 0, 37, // 103  0000 1110.\n  0, 0, 25, // 104  0000 1111.\n  0, 0, 45, // 105  0000 1010.\n  0, 0, 57, // 106  0000 1000.\n  0, 0, 26, // 107  0000 1101.\n  0, 0, 29, // 108  0000 1011.\n  0, 0, 38, // 109  0000 1100.\n  0, 0, 53, // 110  0000 1001.\n  0, 0, 23, // 111  0001 0001.\n  0, 0, 43, // 112  0001 0000.\n  0, 0, 46, // 113  0000 0110.\n  0, 0, 42, // 114  0001 0100.\n  0, 0, 22, // 115  0001 0101.\n  0, 0, 54, // 116  0000 0101.\n  0, 0, 51, // 117  0001 0010.\n  0, 0, 15, // 118  0001 0011.\n  0, 0, 30, // 119  0000 0111.\n  0, 0, 39, // 120  0000 0001 0.\n  0, 0, 47, // 121  0000 0011 0.\n  0, 0, 55, // 122  0000 0010 1.\n  0, 0, 27, // 123  0000 0001 1.\n  0, 0, 59, // 124  0000 0010 0.\n  0, 0, 31 // 125  0000 0011 1.\n  ]);\n  MPEG1.MOTION = new Int16Array([1 * 3, 2 * 3, 0, //   0\n  4 * 3, 3 * 3, 0, //   1  0\n  0, 0, 0, //   2  1.\n  6 * 3, 5 * 3, 0, //   3  01\n  8 * 3, 7 * 3, 0, //   4  00\n  0, 0, -1, //   5  011.\n  0, 0, 1, //   6  010.\n  9 * 3, 10 * 3, 0, //   7  001\n  12 * 3, 11 * 3, 0, //   8  000\n  0, 0, 2, //   9  0010.\n  0, 0, -2, //  10  0011.\n  14 * 3, 15 * 3, 0, //  11  0001\n  16 * 3, 13 * 3, 0, //  12  0000\n  20 * 3, 18 * 3, 0, //  13  0000 1\n  0, 0, 3, //  14  0001 0.\n  0, 0, -3, //  15  0001 1.\n  17 * 3, 19 * 3, 0, //  16  0000 0\n  -1, 23 * 3, 0, //  17  0000 00\n  27 * 3, 25 * 3, 0, //  18  0000 11\n  26 * 3, 21 * 3, 0, //  19  0000 01\n  24 * 3, 22 * 3, 0, //  20  0000 10\n  32 * 3, 28 * 3, 0, //  21  0000 011\n  29 * 3, 31 * 3, 0, //  22  0000 101\n  -1, 33 * 3, 0, //  23  0000 001\n  36 * 3, 35 * 3, 0, //  24  0000 100\n  0, 0, -4, //  25  0000 111.\n  30 * 3, 34 * 3, 0, //  26  0000 010\n  0, 0, 4, //  27  0000 110.\n  0, 0, -7, //  28  0000 0111.\n  0, 0, 5, //  29  0000 1010.\n  37 * 3, 41 * 3, 0, //  30  0000 0100\n  0, 0, -5, //  31  0000 1011.\n  0, 0, 7, //  32  0000 0110.\n  38 * 3, 40 * 3, 0, //  33  0000 0011\n  42 * 3, 39 * 3, 0, //  34  0000 0101\n  0, 0, -6, //  35  0000 1001.\n  0, 0, 6, //  36  0000 1000.\n  51 * 3, 54 * 3, 0, //  37  0000 0100 0\n  50 * 3, 49 * 3, 0, //  38  0000 0011 0\n  45 * 3, 46 * 3, 0, //  39  0000 0101 1\n  52 * 3, 47 * 3, 0, //  40  0000 0011 1\n  43 * 3, 53 * 3, 0, //  41  0000 0100 1\n  44 * 3, 48 * 3, 0, //  42  0000 0101 0\n  0, 0, 10, //  43  0000 0100 10.\n  0, 0, 9, //  44  0000 0101 00.\n  0, 0, 8, //  45  0000 0101 10.\n  0, 0, -8, //  46  0000 0101 11.\n  57 * 3, 66 * 3, 0, //  47  0000 0011 11\n  0, 0, -9, //  48  0000 0101 01.\n  60 * 3, 64 * 3, 0, //  49  0000 0011 01\n  56 * 3, 61 * 3, 0, //  50  0000 0011 00\n  55 * 3, 62 * 3, 0, //  51  0000 0100 00\n  58 * 3, 63 * 3, 0, //  52  0000 0011 10\n  0, 0, -10, //  53  0000 0100 11.\n  59 * 3, 65 * 3, 0, //  54  0000 0100 01\n  0, 0, 12, //  55  0000 0100 000.\n  0, 0, 16, //  56  0000 0011 000.\n  0, 0, 13, //  57  0000 0011 110.\n  0, 0, 14, //  58  0000 0011 100.\n  0, 0, 11, //  59  0000 0100 010.\n  0, 0, 15, //  60  0000 0011 010.\n  0, 0, -16, //  61  0000 0011 001.\n  0, 0, -12, //  62  0000 0100 001.\n  0, 0, -14, //  63  0000 0011 101.\n  0, 0, -15, //  64  0000 0011 011.\n  0, 0, -11, //  65  0000 0100 011.\n  0, 0, -13 //  66  0000 0011 111.\n  ]);\n  MPEG1.DCT_DC_SIZE_LUMINANCE = new Int8Array([2 * 3, 1 * 3, 0, //   0\n  6 * 3, 5 * 3, 0, //   1  1\n  3 * 3, 4 * 3, 0, //   2  0\n  0, 0, 1, //   3  00.\n  0, 0, 2, //   4  01.\n  9 * 3, 8 * 3, 0, //   5  11\n  7 * 3, 10 * 3, 0, //   6  10\n  0, 0, 0, //   7  100.\n  12 * 3, 11 * 3, 0, //   8  111\n  0, 0, 4, //   9  110.\n  0, 0, 3, //  10  101.\n  13 * 3, 14 * 3, 0, //  11  1111\n  0, 0, 5, //  12  1110.\n  0, 0, 6, //  13  1111 0.\n  16 * 3, 15 * 3, 0, //  14  1111 1\n  17 * 3, -1, 0, //  15  1111 11\n  0, 0, 7, //  16  1111 10.\n  0, 0, 8 //  17  1111 110.\n  ]);\n  MPEG1.DCT_DC_SIZE_CHROMINANCE = new Int8Array([2 * 3, 1 * 3, 0, //   0\n  4 * 3, 3 * 3, 0, //   1  1\n  6 * 3, 5 * 3, 0, //   2  0\n  8 * 3, 7 * 3, 0, //   3  11\n  0, 0, 2, //   4  10.\n  0, 0, 1, //   5  01.\n  0, 0, 0, //   6  00.\n  10 * 3, 9 * 3, 0, //   7  111\n  0, 0, 3, //   8  110.\n  12 * 3, 11 * 3, 0, //   9  1111\n  0, 0, 4, //  10  1110.\n  14 * 3, 13 * 3, 0, //  11  1111 1\n  0, 0, 5, //  12  1111 0.\n  16 * 3, 15 * 3, 0, //  13  1111 11\n  0, 0, 6, //  14  1111 10.\n  17 * 3, -1, 0, //  15  1111 111\n  0, 0, 7, //  16  1111 110.\n  0, 0, 8 //  17  1111 1110.\n  ]); //  dct_coeff bitmap:\n  //    0xff00  run\n  //    0x00ff  level\n  //  Decoded values are unsigned. Sign bit follows in the stream.\n  //  Interpretation of the value 0x0001\n  //    for dc_coeff_first:  run=0, level=1\n  //    for dc_coeff_next:   If the next bit is 1: run=0, level=1\n  //                         If the next bit is 0: end_of_block\n  //  escape decodes as 0xffff.\n\n  MPEG1.DCT_COEFF = new Int32Array([1 * 3, 2 * 3, 0, //   0\n  4 * 3, 3 * 3, 0, //   1  0\n  0, 0, 0x0001, //   2  1.\n  7 * 3, 8 * 3, 0, //   3  01\n  6 * 3, 5 * 3, 0, //   4  00\n  13 * 3, 9 * 3, 0, //   5  001\n  11 * 3, 10 * 3, 0, //   6  000\n  14 * 3, 12 * 3, 0, //   7  010\n  0, 0, 0x0101, //   8  011.\n  20 * 3, 22 * 3, 0, //   9  0011\n  18 * 3, 21 * 3, 0, //  10  0001\n  16 * 3, 19 * 3, 0, //  11  0000\n  0, 0, 0x0201, //  12  0101.\n  17 * 3, 15 * 3, 0, //  13  0010\n  0, 0, 0x0002, //  14  0100.\n  0, 0, 0x0003, //  15  0010 1.\n  27 * 3, 25 * 3, 0, //  16  0000 0\n  29 * 3, 31 * 3, 0, //  17  0010 0\n  24 * 3, 26 * 3, 0, //  18  0001 0\n  32 * 3, 30 * 3, 0, //  19  0000 1\n  0, 0, 0x0401, //  20  0011 0.\n  23 * 3, 28 * 3, 0, //  21  0001 1\n  0, 0, 0x0301, //  22  0011 1.\n  0, 0, 0x0102, //  23  0001 10.\n  0, 0, 0x0701, //  24  0001 00.\n  0, 0, 0xffff, //  25  0000 01. -- escape\n  0, 0, 0x0601, //  26  0001 01.\n  37 * 3, 36 * 3, 0, //  27  0000 00\n  0, 0, 0x0501, //  28  0001 11.\n  35 * 3, 34 * 3, 0, //  29  0010 00\n  39 * 3, 38 * 3, 0, //  30  0000 11\n  33 * 3, 42 * 3, 0, //  31  0010 01\n  40 * 3, 41 * 3, 0, //  32  0000 10\n  52 * 3, 50 * 3, 0, //  33  0010 010\n  54 * 3, 53 * 3, 0, //  34  0010 001\n  48 * 3, 49 * 3, 0, //  35  0010 000\n  43 * 3, 45 * 3, 0, //  36  0000 001\n  46 * 3, 44 * 3, 0, //  37  0000 000\n  0, 0, 0x0801, //  38  0000 111.\n  0, 0, 0x0004, //  39  0000 110.\n  0, 0, 0x0202, //  40  0000 100.\n  0, 0, 0x0901, //  41  0000 101.\n  51 * 3, 47 * 3, 0, //  42  0010 011\n  55 * 3, 57 * 3, 0, //  43  0000 0010\n  60 * 3, 56 * 3, 0, //  44  0000 0001\n  59 * 3, 58 * 3, 0, //  45  0000 0011\n  61 * 3, 62 * 3, 0, //  46  0000 0000\n  0, 0, 0x0a01, //  47  0010 0111.\n  0, 0, 0x0d01, //  48  0010 0000.\n  0, 0, 0x0006, //  49  0010 0001.\n  0, 0, 0x0103, //  50  0010 0101.\n  0, 0, 0x0005, //  51  0010 0110.\n  0, 0, 0x0302, //  52  0010 0100.\n  0, 0, 0x0b01, //  53  0010 0011.\n  0, 0, 0x0c01, //  54  0010 0010.\n  76 * 3, 75 * 3, 0, //  55  0000 0010 0\n  67 * 3, 70 * 3, 0, //  56  0000 0001 1\n  73 * 3, 71 * 3, 0, //  57  0000 0010 1\n  78 * 3, 74 * 3, 0, //  58  0000 0011 1\n  72 * 3, 77 * 3, 0, //  59  0000 0011 0\n  69 * 3, 64 * 3, 0, //  60  0000 0001 0\n  68 * 3, 63 * 3, 0, //  61  0000 0000 0\n  66 * 3, 65 * 3, 0, //  62  0000 0000 1\n  81 * 3, 87 * 3, 0, //  63  0000 0000 01\n  91 * 3, 80 * 3, 0, //  64  0000 0001 01\n  82 * 3, 79 * 3, 0, //  65  0000 0000 11\n  83 * 3, 86 * 3, 0, //  66  0000 0000 10\n  93 * 3, 92 * 3, 0, //  67  0000 0001 10\n  84 * 3, 85 * 3, 0, //  68  0000 0000 00\n  90 * 3, 94 * 3, 0, //  69  0000 0001 00\n  88 * 3, 89 * 3, 0, //  70  0000 0001 11\n  0, 0, 0x0203, //  71  0000 0010 11.\n  0, 0, 0x0104, //  72  0000 0011 00.\n  0, 0, 0x0007, //  73  0000 0010 10.\n  0, 0, 0x0402, //  74  0000 0011 11.\n  0, 0, 0x0502, //  75  0000 0010 01.\n  0, 0, 0x1001, //  76  0000 0010 00.\n  0, 0, 0x0f01, //  77  0000 0011 01.\n  0, 0, 0x0e01, //  78  0000 0011 10.\n  105 * 3, 107 * 3, 0, //  79  0000 0000 111\n  111 * 3, 114 * 3, 0, //  80  0000 0001 011\n  104 * 3, 97 * 3, 0, //  81  0000 0000 010\n  125 * 3, 119 * 3, 0, //  82  0000 0000 110\n  96 * 3, 98 * 3, 0, //  83  0000 0000 100\n  -1, 123 * 3, 0, //  84  0000 0000 000\n  95 * 3, 101 * 3, 0, //  85  0000 0000 001\n  106 * 3, 121 * 3, 0, //  86  0000 0000 101\n  99 * 3, 102 * 3, 0, //  87  0000 0000 011\n  113 * 3, 103 * 3, 0, //  88  0000 0001 110\n  112 * 3, 116 * 3, 0, //  89  0000 0001 111\n  110 * 3, 100 * 3, 0, //  90  0000 0001 000\n  124 * 3, 115 * 3, 0, //  91  0000 0001 010\n  117 * 3, 122 * 3, 0, //  92  0000 0001 101\n  109 * 3, 118 * 3, 0, //  93  0000 0001 100\n  120 * 3, 108 * 3, 0, //  94  0000 0001 001\n  127 * 3, 136 * 3, 0, //  95  0000 0000 0010\n  139 * 3, 140 * 3, 0, //  96  0000 0000 1000\n  130 * 3, 126 * 3, 0, //  97  0000 0000 0101\n  145 * 3, 146 * 3, 0, //  98  0000 0000 1001\n  128 * 3, 129 * 3, 0, //  99  0000 0000 0110\n  0, 0, 0x0802, // 100  0000 0001 0001.\n  132 * 3, 134 * 3, 0, // 101  0000 0000 0011\n  155 * 3, 154 * 3, 0, // 102  0000 0000 0111\n  0, 0, 0x0008, // 103  0000 0001 1101.\n  137 * 3, 133 * 3, 0, // 104  0000 0000 0100\n  143 * 3, 144 * 3, 0, // 105  0000 0000 1110\n  151 * 3, 138 * 3, 0, // 106  0000 0000 1010\n  142 * 3, 141 * 3, 0, // 107  0000 0000 1111\n  0, 0, 0x000a, // 108  0000 0001 0011.\n  0, 0, 0x0009, // 109  0000 0001 1000.\n  0, 0, 0x000b, // 110  0000 0001 0000.\n  0, 0, 0x1501, // 111  0000 0001 0110.\n  0, 0, 0x0602, // 112  0000 0001 1110.\n  0, 0, 0x0303, // 113  0000 0001 1100.\n  0, 0, 0x1401, // 114  0000 0001 0111.\n  0, 0, 0x0702, // 115  0000 0001 0101.\n  0, 0, 0x1101, // 116  0000 0001 1111.\n  0, 0, 0x1201, // 117  0000 0001 1010.\n  0, 0, 0x1301, // 118  0000 0001 1001.\n  148 * 3, 152 * 3, 0, // 119  0000 0000 1101\n  0, 0, 0x0403, // 120  0000 0001 0010.\n  153 * 3, 150 * 3, 0, // 121  0000 0000 1011\n  0, 0, 0x0105, // 122  0000 0001 1011.\n  131 * 3, 135 * 3, 0, // 123  0000 0000 0001\n  0, 0, 0x0204, // 124  0000 0001 0100.\n  149 * 3, 147 * 3, 0, // 125  0000 0000 1100\n  172 * 3, 173 * 3, 0, // 126  0000 0000 0101 1\n  162 * 3, 158 * 3, 0, // 127  0000 0000 0010 0\n  170 * 3, 161 * 3, 0, // 128  0000 0000 0110 0\n  168 * 3, 166 * 3, 0, // 129  0000 0000 0110 1\n  157 * 3, 179 * 3, 0, // 130  0000 0000 0101 0\n  169 * 3, 167 * 3, 0, // 131  0000 0000 0001 0\n  174 * 3, 171 * 3, 0, // 132  0000 0000 0011 0\n  178 * 3, 177 * 3, 0, // 133  0000 0000 0100 1\n  156 * 3, 159 * 3, 0, // 134  0000 0000 0011 1\n  164 * 3, 165 * 3, 0, // 135  0000 0000 0001 1\n  183 * 3, 182 * 3, 0, // 136  0000 0000 0010 1\n  175 * 3, 176 * 3, 0, // 137  0000 0000 0100 0\n  0, 0, 0x0107, // 138  0000 0000 1010 1.\n  0, 0, 0x0a02, // 139  0000 0000 1000 0.\n  0, 0, 0x0902, // 140  0000 0000 1000 1.\n  0, 0, 0x1601, // 141  0000 0000 1111 1.\n  0, 0, 0x1701, // 142  0000 0000 1111 0.\n  0, 0, 0x1901, // 143  0000 0000 1110 0.\n  0, 0, 0x1801, // 144  0000 0000 1110 1.\n  0, 0, 0x0503, // 145  0000 0000 1001 0.\n  0, 0, 0x0304, // 146  0000 0000 1001 1.\n  0, 0, 0x000d, // 147  0000 0000 1100 1.\n  0, 0, 0x000c, // 148  0000 0000 1101 0.\n  0, 0, 0x000e, // 149  0000 0000 1100 0.\n  0, 0, 0x000f, // 150  0000 0000 1011 1.\n  0, 0, 0x0205, // 151  0000 0000 1010 0.\n  0, 0, 0x1a01, // 152  0000 0000 1101 1.\n  0, 0, 0x0106, // 153  0000 0000 1011 0.\n  180 * 3, 181 * 3, 0, // 154  0000 0000 0111 1\n  160 * 3, 163 * 3, 0, // 155  0000 0000 0111 0\n  196 * 3, 199 * 3, 0, // 156  0000 0000 0011 10\n  0, 0, 0x001b, // 157  0000 0000 0101 00.\n  203 * 3, 185 * 3, 0, // 158  0000 0000 0010 01\n  202 * 3, 201 * 3, 0, // 159  0000 0000 0011 11\n  0, 0, 0x0013, // 160  0000 0000 0111 00.\n  0, 0, 0x0016, // 161  0000 0000 0110 01.\n  197 * 3, 207 * 3, 0, // 162  0000 0000 0010 00\n  0, 0, 0x0012, // 163  0000 0000 0111 01.\n  191 * 3, 192 * 3, 0, // 164  0000 0000 0001 10\n  188 * 3, 190 * 3, 0, // 165  0000 0000 0001 11\n  0, 0, 0x0014, // 166  0000 0000 0110 11.\n  184 * 3, 194 * 3, 0, // 167  0000 0000 0001 01\n  0, 0, 0x0015, // 168  0000 0000 0110 10.\n  186 * 3, 193 * 3, 0, // 169  0000 0000 0001 00\n  0, 0, 0x0017, // 170  0000 0000 0110 00.\n  204 * 3, 198 * 3, 0, // 171  0000 0000 0011 01\n  0, 0, 0x0019, // 172  0000 0000 0101 10.\n  0, 0, 0x0018, // 173  0000 0000 0101 11.\n  200 * 3, 205 * 3, 0, // 174  0000 0000 0011 00\n  0, 0, 0x001f, // 175  0000 0000 0100 00.\n  0, 0, 0x001e, // 176  0000 0000 0100 01.\n  0, 0, 0x001c, // 177  0000 0000 0100 11.\n  0, 0, 0x001d, // 178  0000 0000 0100 10.\n  0, 0, 0x001a, // 179  0000 0000 0101 01.\n  0, 0, 0x0011, // 180  0000 0000 0111 10.\n  0, 0, 0x0010, // 181  0000 0000 0111 11.\n  189 * 3, 206 * 3, 0, // 182  0000 0000 0010 11\n  187 * 3, 195 * 3, 0, // 183  0000 0000 0010 10\n  218 * 3, 211 * 3, 0, // 184  0000 0000 0001 010\n  0, 0, 0x0025, // 185  0000 0000 0010 011.\n  215 * 3, 216 * 3, 0, // 186  0000 0000 0001 000\n  0, 0, 0x0024, // 187  0000 0000 0010 100.\n  210 * 3, 212 * 3, 0, // 188  0000 0000 0001 110\n  0, 0, 0x0022, // 189  0000 0000 0010 110.\n  213 * 3, 209 * 3, 0, // 190  0000 0000 0001 111\n  221 * 3, 222 * 3, 0, // 191  0000 0000 0001 100\n  219 * 3, 208 * 3, 0, // 192  0000 0000 0001 101\n  217 * 3, 214 * 3, 0, // 193  0000 0000 0001 001\n  223 * 3, 220 * 3, 0, // 194  0000 0000 0001 011\n  0, 0, 0x0023, // 195  0000 0000 0010 101.\n  0, 0, 0x010b, // 196  0000 0000 0011 100.\n  0, 0, 0x0028, // 197  0000 0000 0010 000.\n  0, 0, 0x010c, // 198  0000 0000 0011 011.\n  0, 0, 0x010a, // 199  0000 0000 0011 101.\n  0, 0, 0x0020, // 200  0000 0000 0011 000.\n  0, 0, 0x0108, // 201  0000 0000 0011 111.\n  0, 0, 0x0109, // 202  0000 0000 0011 110.\n  0, 0, 0x0026, // 203  0000 0000 0010 010.\n  0, 0, 0x010d, // 204  0000 0000 0011 010.\n  0, 0, 0x010e, // 205  0000 0000 0011 001.\n  0, 0, 0x0021, // 206  0000 0000 0010 111.\n  0, 0, 0x0027, // 207  0000 0000 0010 001.\n  0, 0, 0x1f01, // 208  0000 0000 0001 1011.\n  0, 0, 0x1b01, // 209  0000 0000 0001 1111.\n  0, 0, 0x1e01, // 210  0000 0000 0001 1100.\n  0, 0, 0x1002, // 211  0000 0000 0001 0101.\n  0, 0, 0x1d01, // 212  0000 0000 0001 1101.\n  0, 0, 0x1c01, // 213  0000 0000 0001 1110.\n  0, 0, 0x010f, // 214  0000 0000 0001 0011.\n  0, 0, 0x0112, // 215  0000 0000 0001 0000.\n  0, 0, 0x0111, // 216  0000 0000 0001 0001.\n  0, 0, 0x0110, // 217  0000 0000 0001 0010.\n  0, 0, 0x0603, // 218  0000 0000 0001 0100.\n  0, 0, 0x0b02, // 219  0000 0000 0001 1010.\n  0, 0, 0x0e02, // 220  0000 0000 0001 0111.\n  0, 0, 0x0d02, // 221  0000 0000 0001 1000.\n  0, 0, 0x0c02, // 222  0000 0000 0001 1001.\n  0, 0, 0x0f02 // 223  0000 0000 0001 0110.\n  ]);\n  MPEG1.PICTURE_TYPE = {\n    INTRA: 1,\n    PREDICTIVE: 2,\n    B: 3\n  };\n  MPEG1.START = {\n    SEQUENCE: 0xB3,\n    SLICE_FIRST: 0x01,\n    SLICE_LAST: 0xAF,\n    PICTURE: 0x00,\n    EXTENSION: 0xB5,\n    USER_DATA: 0xB2\n  };\n  return MPEG1;\n}();\n\n//# sourceURL=webpack:///./src/js/3rdparty/mpeg1.js?");

/***/ }),

/***/ "./src/js/3rdparty/ts.js":
/*!*******************************!*\
  !*** ./src/js/3rdparty/ts.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const BitBuffer = __webpack_require__(/*! ./buffer */ \"./src/js/3rdparty/buffer.js\");\n\nmodule.exports = function () {\n  \"use strict\";\n\n  var TS = function (options) {\n    this.bits = null;\n    this.leftoverBytes = null;\n    this.guessVideoFrameEnd = true;\n    this.pidsToStreamIds = {};\n    this.pesPacketInfo = {};\n    this.startTime = 0;\n    this.currentTime = 0;\n  };\n\n  TS.prototype.connect = function (streamId, destination) {\n    this.pesPacketInfo[streamId] = {\n      destination: destination,\n      currentLength: 0,\n      totalLength: 0,\n      pts: 0,\n      buffers: []\n    };\n  };\n\n  TS.prototype.write = function (buffer) {\n    if (this.leftoverBytes) {\n      var totalLength = buffer.byteLength + this.leftoverBytes.byteLength;\n      this.bits = new BitBuffer(totalLength);\n      this.bits.write([this.leftoverBytes, buffer]);\n    } else {\n      this.bits = new BitBuffer(buffer);\n    }\n\n    while (this.bits.has(188 << 3) && this.parsePacket()) {}\n\n    var leftoverCount = this.bits.byteLength - (this.bits.index >> 3);\n    this.leftoverBytes = leftoverCount > 0 ? this.bits.bytes.subarray(this.bits.index >> 3) : null;\n  };\n\n  TS.prototype.parsePacket = function () {\n    // Check if we're in sync with packet boundaries; attempt to resync if not.\n    if (this.bits.read(8) !== 0x47) {\n      if (!this.resync()) {\n        // Couldn't resync; maybe next time...\n        return false;\n      }\n    }\n\n    var end = (this.bits.index >> 3) + 187;\n    var transportError = this.bits.read(1),\n        payloadStart = this.bits.read(1),\n        transportPriority = this.bits.read(1),\n        pid = this.bits.read(13),\n        transportScrambling = this.bits.read(2),\n        adaptationField = this.bits.read(2),\n        continuityCounter = this.bits.read(4); // If this is the start of a new payload; signal the end of the previous\n    // frame, if we didn't do so already.\n\n    var streamId = this.pidsToStreamIds[pid];\n\n    if (payloadStart && streamId) {\n      var pi = this.pesPacketInfo[streamId];\n\n      if (pi && pi.currentLength) {\n        this.packetComplete(pi);\n      }\n    } // Extract current payload\n\n\n    if (adaptationField & 0x1) {\n      if (adaptationField & 0x2) {\n        var adaptationFieldLength = this.bits.read(8);\n        this.bits.skip(adaptationFieldLength << 3);\n      }\n\n      if (payloadStart && this.bits.nextBytesAreStartCode()) {\n        this.bits.skip(24);\n        streamId = this.bits.read(8);\n        this.pidsToStreamIds[pid] = streamId;\n        var packetLength = this.bits.read(16);\n        this.bits.skip(8);\n        var ptsDtsFlag = this.bits.read(2);\n        this.bits.skip(6);\n        var headerLength = this.bits.read(8);\n        var payloadBeginIndex = this.bits.index + (headerLength << 3);\n        var pi = this.pesPacketInfo[streamId];\n\n        if (pi) {\n          var pts = 0;\n\n          if (ptsDtsFlag & 0x2) {\n            // The Presentation Timestamp is encoded as 33(!) bit\n            // integer, but has a \"marker bit\" inserted at weird places\n            // in between, making the whole thing 5 bytes in size.\n            // You can't make this shit up...\n            this.bits.skip(4);\n            var p32_30 = this.bits.read(3);\n            this.bits.skip(1);\n            var p29_15 = this.bits.read(15);\n            this.bits.skip(1);\n            var p14_0 = this.bits.read(15);\n            this.bits.skip(1); // Can't use bit shifts here; we need 33 bits of precision,\n            // so we're using JavaScript's double number type. Also\n            // divide by the 90khz clock to get the pts in seconds.\n\n            pts = (p32_30 * 1073741824 + p29_15 * 32768 + p14_0) / 90000;\n            this.currentTime = pts;\n\n            if (this.startTime === -1) {\n              this.startTime = pts;\n            }\n          }\n\n          var payloadLength = packetLength ? packetLength - headerLength - 3 : 0;\n          this.packetStart(pi, pts, payloadLength);\n        } // Skip the rest of the header without parsing it\n\n\n        this.bits.index = payloadBeginIndex;\n      }\n\n      if (streamId) {\n        // Attempt to detect if the PES packet is complete. For Audio (and\n        // other) packets, we received a total packet length with the PES\n        // header, so we can check the current length.\n        // For Video packets, we have to guess the end by detecting if this\n        // TS packet was padded - there's no good reason to pad a TS packet\n        // in between, but it might just fit exactly. If this fails, we can\n        // only wait for the next PES header for that stream.\n        var pi = this.pesPacketInfo[streamId];\n\n        if (pi) {\n          var start = this.bits.index >> 3;\n          var complete = this.packetAddData(pi, start, end);\n          var hasPadding = !payloadStart && adaptationField & 0x2;\n\n          if (complete || this.guessVideoFrameEnd && hasPadding) {\n            this.packetComplete(pi);\n          }\n        }\n      }\n    }\n\n    this.bits.index = end << 3;\n    return true;\n  };\n\n  TS.prototype.resync = function () {\n    // Check if we have enough data to attempt a resync. We need 5 full packets.\n    if (!this.bits.has(188 * 6 << 3)) {\n      return false;\n    }\n\n    var byteIndex = this.bits.index >> 3; // Look for the first sync token in the first 187 bytes\n\n    for (var i = 0; i < 187; i++) {\n      if (this.bits.bytes[byteIndex + i] === 0x47) {\n        // Look for 4 more sync tokens, each 188 bytes appart\n        var foundSync = true;\n\n        for (var j = 1; j < 5; j++) {\n          if (this.bits.bytes[byteIndex + i + 188 * j] !== 0x47) {\n            foundSync = false;\n            break;\n          }\n        }\n\n        if (foundSync) {\n          this.bits.index = byteIndex + i + 1 << 3;\n          return true;\n        }\n      }\n    } // In theory, we shouldn't arrive here. If we do, we had enough data but\n    // still didn't find sync - this can only happen if we were fed garbage\n    // data. Check your source!\n\n\n    console.warn('JSMpeg: Possible garbage data. Skipping.');\n    this.bits.skip(187 << 3);\n    return false;\n  };\n\n  TS.prototype.packetStart = function (pi, pts, payloadLength) {\n    pi.totalLength = payloadLength;\n    pi.currentLength = 0;\n    pi.pts = pts;\n  };\n\n  TS.prototype.packetAddData = function (pi, start, end) {\n    pi.buffers.push(this.bits.bytes.subarray(start, end));\n    pi.currentLength += end - start;\n    var complete = pi.totalLength !== 0 && pi.currentLength >= pi.totalLength;\n    return complete;\n  };\n\n  TS.prototype.packetComplete = function (pi) {\n    pi.destination.write(pi.pts, pi.buffers);\n    pi.totalLength = 0;\n    pi.currentLength = 0;\n    pi.buffers = [];\n  };\n\n  TS.STREAM = {\n    PACK_HEADER: 0xBA,\n    SYSTEM_HEADER: 0xBB,\n    PROGRAM_MAP: 0xBC,\n    PRIVATE_1: 0xBD,\n    PADDING: 0xBE,\n    PRIVATE_2: 0xBF,\n    AUDIO_1: 0xC0,\n    VIDEO_1: 0xE0,\n    DIRECTORY: 0xFF\n  };\n  return TS;\n}();\n\n//# sourceURL=webpack:///./src/js/3rdparty/ts.js?");

/***/ }),

/***/ "./src/js/decode_video.js":
/*!********************************!*\
  !*** ./src/js/decode_video.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.array.iterator */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator */ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n\nconst JSMpeg = __webpack_require__(/*! ./jsmpeg */ \"./src/js/jsmpeg.js\");\n\nconst jpeg = __webpack_require__(/*! ./pttjpeg */ \"./src/js/pttjpeg.js\");\n\nconst jsjpeg = __webpack_require__(/*! jpeg-js */ \"./node_modules/jpeg-js/index.js\");\n\nconst Base64 = __webpack_require__(/*! js-base64 */ \"./node_modules/js-base64/base64.js\").Base64;\n/* This function is a modified version of function from jsmpeg\n    which converts an image from YCbCr space to RGBA space\n*/\n\n\nfunction YCbCrToRGBA(y, cb, cr, width, height) {\n  const rgba = new Uint8ClampedArray(width * height * 4).fill(255);\n  const w = width + 15 >> 4 << 4;\n  const w2 = w >> 1;\n  let yIndex1 = 0;\n  let yIndex2 = w;\n  const yNext2Lines = w + (w - width);\n  let cIndex = 0;\n  const cNextLine = w2 - (width >> 1);\n  let rgbaIndex1 = 0;\n  let rgbaIndex2 = width * 4;\n  const rgbaNext2Lines = width * 4;\n  const cols = width >> 1;\n  const rows = height >> 1;\n  let ccb = 0;\n  let ccr = 0;\n  let r = 0;\n  let g = 0;\n  let b = 0;\n\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < cols; col++) {\n      ccb = cb[cIndex];\n      ccr = cr[cIndex];\n      cIndex++;\n      r = ccb + (ccb * 103 >> 8) - 179;\n      g = (ccr * 88 >> 8) - 44 + (ccb * 183 >> 8) - 91;\n      b = ccr + (ccr * 198 >> 8) - 227; // Line 1\n\n      const y1 = y[yIndex1++];\n      const y2 = y[yIndex1++];\n      rgba[rgbaIndex1] = y1 + r;\n      rgba[rgbaIndex1 + 1] = y1 - g;\n      rgba[rgbaIndex1 + 2] = y1 + b;\n      rgba[rgbaIndex1 + 4] = y2 + r;\n      rgba[rgbaIndex1 + 5] = y2 - g;\n      rgba[rgbaIndex1 + 6] = y2 + b;\n      rgbaIndex1 += 8; // Line 2\n\n      const y3 = y[yIndex2++];\n      const y4 = y[yIndex2++];\n      rgba[rgbaIndex2] = y3 + r;\n      rgba[rgbaIndex2 + 1] = y3 - g;\n      rgba[rgbaIndex2 + 2] = y3 + b;\n      rgba[rgbaIndex2 + 4] = y4 + r;\n      rgba[rgbaIndex2 + 5] = y4 - g;\n      rgba[rgbaIndex2 + 6] = y4 + b;\n      rgbaIndex2 += 8;\n    }\n\n    yIndex1 += yNext2Lines;\n    yIndex2 += yNext2Lines;\n    rgbaIndex1 += rgbaNext2Lines;\n    rgbaIndex2 += rgbaNext2Lines;\n    cIndex += cNextLine;\n  }\n\n  return rgba;\n}\n\nself.onmessage = function (e) {\n  const block = e.data.block;\n  const start = e.data.start;\n  const end = e.data.end;\n  videoDecoder = new JSMpeg.Decoder.MPEG1Video({\n    decodeFirstFrame: false\n  });\n  demuxer = new JSMpeg.Demuxer.TS({});\n  demuxer.connect(JSMpeg.Demuxer.TS.STREAM.VIDEO_1, videoDecoder);\n  demuxer.write(block);\n\n  for (let i = start; i <= end; i++) {\n    var t0 = performance.now();\n    const result = videoDecoder.decode();\n    var t_decode = performance.now();\n    console.log(\"decode \" + i + \" frame  took \" + (t_decode - t0) + \" milliseconds.\");\n\n    if (!Array.isArray(result)) {\n      const message = 'Result must be an array.' + `Got ${result}. Possible reasons: ` + 'bad video file, unpached jsmpeg';\n      throw Error(message);\n    }\n\n    postMessage({\n      fileName: null,\n      index: i,\n      data: YCbCrToRGBA(...result, e.data.width, e.data.height)\n    });\n  }\n\n  self.close();\n};\n\n//# sourceURL=webpack:///./src/js/decode_video.js?");

/***/ }),

/***/ "./src/js/jsmpeg.js":
/*!**************************!*\
  !*** ./src/js/jsmpeg.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n* Copyright (C) 2019 Intel Corporation\n* SPDX-License-Identifier: MIT\n*/\n\n/* global\n    require:true\n*/\nconst JSMpeg = __webpack_require__(/*! ./3rdparty/jsmpeg */ \"./src/js/3rdparty/jsmpeg.js\");\n\nJSMpeg.BitBuffer = __webpack_require__(/*! ./3rdparty/buffer */ \"./src/js/3rdparty/buffer.js\");\nJSMpeg.Decoder.Base = __webpack_require__(/*! ./3rdparty/decoder */ \"./src/js/3rdparty/decoder.js\");\nJSMpeg.Decoder.MPEG1Video = __webpack_require__(/*! ./3rdparty/mpeg1 */ \"./src/js/3rdparty/mpeg1.js\");\nJSMpeg.Demuxer.TS = __webpack_require__(/*! ./3rdparty/ts.js */ \"./src/js/3rdparty/ts.js\");\nmodule.exports = JSMpeg;\n\n//# sourceURL=webpack:///./src/js/jsmpeg.js?");

/***/ }),

/***/ "./src/js/pttjpeg.js":
/*!***************************!*\
  !*** ./src/js/pttjpeg.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! core-js/modules/es.array.iterator */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n\n/* @@--\n * Copyright (C) 2014 Alberto Vigata\n * All rights reserved\n * \n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met\n * \n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *     * Neither the name of the University of California, Berkeley nor the\n *       names of its contributors may be used to endorse or promote products\n *       derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE REGENTS AND CONTRIBUTORS BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n(function namespace() {\n  //-------------------------------------------------------------------------------------------\n  // Debugging support\n  //-------------------------------------------------------------------------------------------\n\n  /*! sprintf.js\n   *\n   * Copyright (c) 2007-2014, Alexandru Marasteanu <hello [at) alexei (dot] ro>\n   * All rights reserved.\n   *\n   * Redistribution and use in source and binary forms, with or without\n   * modification, are permitted provided that the following conditions are met:\n   *\n   *     * Redistributions of source code must retain the above copyright\n   *       notice, this list of conditions and the following disclaimer.\n   *\n   *     * Redistributions in binary form must reproduce the above copyright\n   *       notice, this list of conditions and the following disclaimer in the\n   *       documentation and/or other materials provided with the distribution.\n   *\n   *     * Neither the name of this software nor the names of its contributors may be\n   *       used to endorse or promote products derived from this software without\n   *       specific prior written permission.\n   *\n   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n   * DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\n   * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n   * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n   * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n   * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n   *\n   * usage:\n   *\n   *  string sprintf(string format , [mixed arg1 [, mixed arg2 [ ,...]]]);\n   *\n   */\n  var ct = {}; //  This is a modification to the embedded sprintf.js logic so that it\n  //  will attach itself to this object only.  This is so that the embedded\n  //  version of sprintf.js does not get exported out into the global /\n  //  application environment.\n\n  (function (ctx) {\n    var sprintf = function () {\n      if (!sprintf.cache.hasOwnProperty(arguments[0])) {\n        sprintf.cache[arguments[0]] = sprintf.parse(arguments[0]);\n      }\n\n      return sprintf.format.call(null, sprintf.cache[arguments[0]], arguments);\n    };\n\n    sprintf.format = function (parse_tree, argv) {\n      var cursor = 1,\n          tree_length = parse_tree.length,\n          node_type = '',\n          arg,\n          output = [],\n          i,\n          k,\n          match,\n          pad,\n          pad_character,\n          pad_length;\n\n      for (i = 0; i < tree_length; i++) {\n        node_type = get_type(parse_tree[i]);\n\n        if (node_type === 'string') {\n          output.push(parse_tree[i]);\n        } else if (node_type === 'array') {\n          match = parse_tree[i]; // convenience purposes only\n\n          if (match[2]) {\n            // keyword argument\n            arg = argv[cursor];\n\n            for (k = 0; k < match[2].length; k++) {\n              if (!arg.hasOwnProperty(match[2][k])) {\n                throw sprintf('[sprintf] property \"%s\" does not exist', match[2][k]);\n              }\n\n              arg = arg[match[2][k]];\n            }\n          } else if (match[1]) {\n            // positional argument (explicit)\n            arg = argv[match[1]];\n          } else {\n            // positional argument (implicit)\n            arg = argv[cursor++];\n          }\n\n          if (/[^s]/.test(match[8]) && get_type(arg) != 'number') {\n            throw sprintf('[sprintf] expecting number but found %s', get_type(arg));\n          }\n\n          switch (match[8]) {\n            case 'b':\n              arg = arg.toString(2);\n              break;\n\n            case 'c':\n              arg = String.fromCharCode(arg);\n              break;\n\n            case 'd':\n              arg = parseInt(arg, 10);\n              break;\n\n            case 'e':\n              arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();\n              break;\n\n            case 'f':\n              arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);\n              break;\n\n            case 'o':\n              arg = arg.toString(8);\n              break;\n\n            case 's':\n              arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;\n              break;\n\n            case 'u':\n              arg = arg >>> 0;\n              break;\n\n            case 'x':\n              arg = arg.toString(16);\n              break;\n\n            case 'X':\n              arg = arg.toString(16).toUpperCase();\n              break;\n          }\n\n          arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? '+' + arg : arg;\n          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';\n          pad_length = match[6] - String(arg).length;\n          pad = match[6] ? str_repeat(pad_character, pad_length) : '';\n          output.push(match[5] ? arg + pad : pad + arg);\n        }\n      }\n\n      return output.join('');\n    };\n\n    sprintf.cache = {};\n\n    sprintf.parse = function (fmt) {\n      var _fmt = fmt,\n          match = [],\n          parse_tree = [],\n          arg_names = 0;\n\n      while (_fmt) {\n        if ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n          parse_tree.push(match[0]);\n        } else if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n          parse_tree.push('%');\n        } else if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {\n          if (match[2]) {\n            arg_names |= 1;\n            var field_list = [],\n                replacement_field = match[2],\n                field_match = [];\n\n            if ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n              field_list.push(field_match[1]);\n\n              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                if ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                } else if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n                  field_list.push(field_match[1]);\n                } else {\n                  throw '[sprintf] huh?';\n                }\n              }\n            } else {\n              throw '[sprintf] huh?';\n            }\n\n            match[2] = field_list;\n          } else {\n            arg_names |= 2;\n          }\n\n          if (arg_names === 3) {\n            throw '[sprintf] mixing positional and named placeholders is not (yet) supported';\n          }\n\n          parse_tree.push(match);\n        } else {\n          throw '[sprintf] huh?';\n        }\n\n        _fmt = _fmt.substring(match[0].length);\n      }\n\n      return parse_tree;\n    };\n\n    var vsprintf = function (fmt, argv, _argv) {\n      _argv = argv.slice(0);\n\n      _argv.splice(0, 0, fmt);\n\n      return sprintf.apply(null, _argv);\n    };\n    /**\n     * helpers\n     */\n\n\n    function get_type(variable) {\n      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n    }\n\n    function str_repeat(input, multiplier) {\n      for (var output = []; multiplier > 0; output[--multiplier] = input) {\n        /* do nothing */\n      }\n\n      return output.join('');\n    }\n    /**\n     * export to either browser or node.js\n     */\n\n\n    ctx.sprintf = sprintf;\n    ctx.vsprintf = vsprintf;\n  })(ct);\n\n  var sprintf = ct.sprintf;\n  var flagQuiet = false;\n\n  function DEBUGMSG(x) {\n    if (flagQuiet) return;\n\n    if (typeof importScripts != 'undefined') {\n      var m = {\n        'log': x,\n        'reason': 'log'\n      };\n      postMessage(m);\n    } else if (typeof console != 'undefined') {\n      console.log(x);\n    }\n  } //-------------------------------------------------------------------------------------------\n  // petitoJPEG routines \n  //-------------------------------------------------------------------------------------------\n\n  /**\n   * BitWriter class\n   *\n   * A class to write bits to a random output\n   *\n   * Provide a byte sink by providing an object like ByteWriter with the setByteWriter method\n   *\n   */\n\n\n  function BitWriter() {\n    var _this = this;\n\n    var bufsize = 1024;\n    var buf = new Uint8Array(bufsize);\n    var bufptr = 0;\n    var bitcount = 0;\n    var bitcache = 0;\n    var byteswritten = 0; // private methods\n\n    function reset_writer() {\n      byteswritten = 0;\n      bufptr = 0;\n      bitcount = 0;\n    }\n\n    ;\n\n    function output_buffer() {\n      if (bw) {\n        bw.write(buf, 0, bufptr);\n      }\n\n      byteswritten += bufptr;\n      bufptr = 0;\n    }\n\n    ;\n\n    function emptybitbuffer() {\n      do {\n        /* Check if we need to dump buffer*/\n        if (bufptr >= bufsize) {\n          output_buffer();\n        }\n\n        var b = bitcache >> 24 & 0xff;\n\n        if (b == 0xff) {\n          /*Add 0x00 stuffing*/\n          bitcache &= 0x00ffffff;\n          buf[bufptr++] = 0xff;\n          continue;\n        }\n\n        buf[bufptr++] = b;\n        bitcache <<= 8;\n        /* remove bits from bitcache*/\n\n        bitcount -= 8;\n      } while (bitcount >= 8);\n    } // This ensures there is at least 16 free bits in the buffer\n\n\n    function emptybitbuffer_16(pbs) {\n      /* the following loop always adds two bytes at least. to the bitcache*/\n      if (bitcount > 16) {\n        emptybitbuffer();\n      }\n    }\n\n    function shovebits(val, bits) {\n      bitcache |= (val & (1 << bits) - 1) << 32 - bitcount - bits;\n      bitcount += bits;\n    }\n\n    var flush_buffers = function () {\n      align8();\n\n      if (bitcount >= 8) {\n        emptybitbuffer();\n        output_buffer();\n      }\n    };\n\n    var align8 = function () {\n      _this.putbits(0xff, 32 - bitcount & 0x7);\n    };\n    /**\n     * Public API\n     */\n\n\n    var bw;\n\n    this.getWrittenBytes = function () {\n      return byteswritten;\n    };\n\n    this.end = function () {\n      output_buffer();\n    };\n\n    this.putbits = function (val, bits) {\n      emptybitbuffer_16();\n      shovebits(val, bits);\n    };\n\n    this.align = function () {\n      align8();\n    };\n\n    this.setByteWriter = function (bww) {\n      bw = bww;\n    };\n\n    this.putshort = function (s) {\n      flush_buffers();\n      buf[bufptr++] = (s & 0xffff) >>> 8;\n      buf[bufptr++] = s & 0xff;\n    };\n\n    this.putbyte = function (b) {\n      flush_buffers();\n      buf[bufptr++] = b;\n    };\n  } //-------------------------------------------------------------------------------------------\n  // encoding tables \n  //-------------------------------------------------------------------------------------------\n\n\n  var std_dc_luminance_nrcodes = new Uint32Array([0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]);\n  var std_dc_luminance_values = new Uint32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n  var std_ac_luminance_nrcodes = new Uint32Array([0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d]);\n  var std_ac_luminance_values = new Uint32Array([0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa]);\n  var std_dc_chrominance_nrcodes = new Uint32Array([0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]);\n  var std_dc_chrominance_values = new Uint32Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]);\n  var std_ac_chrominance_nrcodes = new Uint32Array([0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77]);\n  var std_ac_chrominance_values = new Uint32Array([0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa]);\n  var jpeg_natural_order = new Uint32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63,\n  /* extra entries for safety in decoder */\n  63, 63, 63, 63, 63, 63, 63, 63]);\n  /* zig zag scan table */\n\n  var zz = new Uint32Array([0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63]);\n  /* aan dct scale factors */\n\n  var aasf = new Float64Array([1.0, 1.387039845, 1.306562965, 1.175875602, 1.0, 0.785694958, 0.541196100, 0.275899379]);\n  /* default quantization tables */\n\n  var YQT = new Uint32Array([16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99]);\n  var UVQT = new Uint32Array([17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99]); //-------------------------------------------------------------------------------------------\n  // PTTJPEG object \n  //-------------------------------------------------------------------------------------------\n\n  function PTTJPEG() {\n    /* private context variables */\n    var fdtbl_Y = new Float64Array(64);\n    var fdtbl_UV = new Float64Array(64);\n    var YDU = new Float64Array(64);\n    var YDU2 = new Float64Array(64); // filled in 420 mode\n\n    var YDU3 = new Float64Array(64); // filled in 420 mode\n\n    var YDU4 = new Float64Array(64); // filled in 420 mode\n\n    var UDU = new Float64Array(64);\n    var UDU1 = new Float64Array(64);\n    var UDU2 = new Float64Array(64);\n    var UDU3 = new Float64Array(64);\n    var UDU4 = new Float64Array(64);\n    var VDU = new Float64Array(64);\n    var VDU1 = new Float64Array(64);\n    var VDU2 = new Float64Array(64);\n    var VDU3 = new Float64Array(64);\n    var VDU4 = new Float64Array(64);\n    var DU = new Int32Array(64);\n    var YTable = new Int32Array(64);\n    var UVTable = new Int32Array(64);\n    var outputfDCTQuant = new Int32Array(64);\n    var sf = 1; // int. the scale factor\n\n    var inputImage;\n    /** \n     * BitString class\n     */\n\n    function BitString() {\n      this.val = 0;\n      this.len = 0;\n    }\n\n    ;\n    var YDC_HT = new Array(256);\n    var UVDC_HT = new Array(256);\n    var YAC_HT = new Array(256);\n    var UVAC_HT = new Array(256);\n    /**\n     * var quality:int\n     * \n     */\n\n    var init_quality_settings = function (quality) {\n      if (quality <= 0) quality = 1;\n      if (quality > 100) quality = 100;\n      sf = quality < 50 ? 5000 / quality | 0 : 200 - (quality << 1) | 0;\n      /* init quantization tables */\n\n      init_quant_tables(sf);\n    };\n    /** \n     * var sf:int: the scale factor\n     * @returns\n     */\n\n\n    var init_quant_tables = function (sff) {\n      var i;\n      var I64 = 64;\n      var I8 = 8;\n\n      for (i = 0; i < I64; ++i) {\n        var t = (YQT[i] * sff + 50) * 0.01 | 0;\n\n        if (t < 1) {\n          t = 1;\n        } else if (t > 255) {\n          t = 255;\n        }\n\n        YTable[zz[i]] = t;\n      }\n\n      for (i = 0; i < I64; i++) {\n        var u = (UVQT[i] * sff + 50) * 0.01 | 0;\n\n        if (u < 1) {\n          u = 1;\n        } else if (u > 255) {\n          u = 255;\n        }\n\n        UVTable[zz[i]] = u;\n      }\n\n      i = 0;\n      var row;\n      var col;\n\n      for (row = 0; row < I8; ++row) {\n        for (col = 0; col < I8; ++col) {\n          fdtbl_Y[i] = 1 / (YTable[zz[i]] * aasf[row] * aasf[col] * I8);\n          fdtbl_UV[i] = 1 / (UVTable[zz[i]] * aasf[row] * aasf[col] * I8);\n          i++;\n        }\n      }\n    };\n    /**\n     * const int nrcodes[]\n     * const int std_table[]\n     * BitString HT, Array(BitsString) \n     *\n     */\n\n\n    var computeHuffmanTbl = function (nrcodes, std_table, HT) {\n      var codevalue = 0; //int\n\n      var pos_in_table = 0; //int\n\n      var k, j; //int\n\n      var bs; //BitString object\n      // initialize table\n\n      for (k = 0; k < 256; k++) {\n        bs = new BitString();\n        bs.val = 0;\n        bs.len = 0;\n        HT[k] = bs;\n      }\n\n      for (k = 1; k <= 16; ++k) {\n        for (j = 1; j <= nrcodes[k]; ++j) {\n          var bs = new BitString();\n          bs.val = codevalue;\n          bs.len = k;\n          HT[std_table[pos_in_table]] = bs;\n          pos_in_table++;\n          codevalue++;\n        }\n\n        codevalue <<= 1;\n      }\n    };\n    /**\n     * Initialize huffman tables\n     */\n\n\n    var init_huffman_tables = function () {\n      computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values, YDC_HT);\n      computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values, UVDC_HT);\n      computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values, YAC_HT);\n      computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values, UVAC_HT);\n    };\n    /** \n     *\n     * DCT and quantization core\n     *\n     * double data[]\n     * double fdtbl[]\n     *\n     * returns quantized coefficients\n     *\n     */\n\n\n    function fDCTQuant(data, fdtbl) {\n      /* Pass 1: process rows. */\n      var dataOff = 0;\n      var d0, d1, d2, d3, d4, d5, d6, d7;\n      var i;\n      var I8 = 8;\n      var I64 = 64;\n\n      for (i = 0; i < I8; ++i) {\n        d0 = data[dataOff];\n        d1 = data[dataOff + 1];\n        d2 = data[dataOff + 2];\n        d3 = data[dataOff + 3];\n        d4 = data[dataOff + 4];\n        d5 = data[dataOff + 5];\n        d6 = data[dataOff + 6];\n        d7 = data[dataOff + 7];\n        var tmp0 = d0 + d7;\n        var tmp7 = d0 - d7;\n        var tmp1 = d1 + d6;\n        var tmp6 = d1 - d6;\n        var tmp2 = d2 + d5;\n        var tmp5 = d2 - d5;\n        var tmp3 = d3 + d4;\n        var tmp4 = d3 - d4;\n        /* Even part */\n\n        var tmp10 = tmp0 + tmp3;\n        /* phase 2 */\n\n        var tmp13 = tmp0 - tmp3;\n        var tmp11 = tmp1 + tmp2;\n        var tmp12 = tmp1 - tmp2;\n        data[dataOff] = tmp10 + tmp11;\n        /* phase 3 */\n\n        data[dataOff + 4] = tmp10 - tmp11;\n        var z1 = (tmp12 + tmp13) * 0.707106781;\n        /* c4 */\n\n        data[dataOff + 2] = tmp13 + z1;\n        /* phase 5 */\n\n        data[dataOff + 6] = tmp13 - z1;\n        /* Odd part */\n\n        tmp10 = tmp4 + tmp5;\n        /* phase 2 */\n\n        tmp11 = tmp5 + tmp6;\n        tmp12 = tmp6 + tmp7;\n        /* The rotator is modified from fig 4-8 to avoid extra negations. */\n\n        var z5 = (tmp10 - tmp12) * 0.382683433;\n        /* c6 */\n\n        var z2 = 0.541196100 * tmp10 + z5;\n        /* c2-c6 */\n\n        var z4 = 1.306562965 * tmp12 + z5;\n        /* c2+c6 */\n\n        var z3 = tmp11 * 0.707106781;\n        /* c4 */\n\n        var z11 = tmp7 + z3;\n        /* phase 5 */\n\n        var z13 = tmp7 - z3;\n        data[dataOff + 5] = z13 + z2;\n        /* phase 6 */\n\n        data[dataOff + 3] = z13 - z2;\n        data[dataOff + 1] = z11 + z4;\n        data[dataOff + 7] = z11 - z4;\n        dataOff += 8;\n        /* advance pointer to next row */\n      }\n      /* Pass 2: process columns. */\n\n\n      dataOff = 0;\n\n      for (i = 0; i < I8; ++i) {\n        d0 = data[dataOff];\n        d1 = data[dataOff + 8];\n        d2 = data[dataOff + 16];\n        d3 = data[dataOff + 24];\n        d4 = data[dataOff + 32];\n        d5 = data[dataOff + 40];\n        d6 = data[dataOff + 48];\n        d7 = data[dataOff + 56];\n        var tmp0p2 = d0 + d7;\n        var tmp7p2 = d0 - d7;\n        var tmp1p2 = d1 + d6;\n        var tmp6p2 = d1 - d6;\n        var tmp2p2 = d2 + d5;\n        var tmp5p2 = d2 - d5;\n        var tmp3p2 = d3 + d4;\n        var tmp4p2 = d3 - d4;\n        /* Even part */\n\n        var tmp10p2 = tmp0p2 + tmp3p2;\n        /* phase 2 */\n\n        var tmp13p2 = tmp0p2 - tmp3p2;\n        var tmp11p2 = tmp1p2 + tmp2p2;\n        var tmp12p2 = tmp1p2 - tmp2p2;\n        data[dataOff] = tmp10p2 + tmp11p2;\n        /* phase 3 */\n\n        data[dataOff + 32] = tmp10p2 - tmp11p2;\n        var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;\n        /* c4 */\n\n        data[dataOff + 16] = tmp13p2 + z1p2;\n        /* phase 5 */\n\n        data[dataOff + 48] = tmp13p2 - z1p2;\n        /* Odd part */\n\n        tmp10p2 = tmp4p2 + tmp5p2;\n        /* phase 2 */\n\n        tmp11p2 = tmp5p2 + tmp6p2;\n        tmp12p2 = tmp6p2 + tmp7p2;\n        /* The rotator is modified from fig 4-8 to avoid extra negations. */\n\n        var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;\n        /* c6 */\n\n        var z2p2 = 0.541196100 * tmp10p2 + z5p2;\n        /* c2-c6 */\n\n        var z4p2 = 1.306562965 * tmp12p2 + z5p2;\n        /* c2+c6 */\n\n        var z3p2 = tmp11p2 * 0.707106781;\n        /* c4 */\n\n        var z11p2 = tmp7p2 + z3p2;\n        /* phase 5 */\n\n        var z13p2 = tmp7p2 - z3p2;\n        data[dataOff + 40] = z13p2 + z2p2;\n        /* phase 6 */\n\n        data[dataOff + 24] = z13p2 - z2p2;\n        data[dataOff + 8] = z11p2 + z4p2;\n        data[dataOff + 56] = z11p2 - z4p2;\n        dataOff++;\n        /* advance po(int)er to next column */\n      } // Quantize/descale the coefficients\n\n\n      var fDCTQuant;\n\n      for (i = 0; i < I64; ++i) {\n        // Apply the quantization and scaling factor & Round to nearest (int)eger\n        fDCTQuant = data[i] * fdtbl[i];\n        outputfDCTQuant[i] = fDCTQuant > 0.0 ? fDCTQuant + 0.5 | 0 : fDCTQuant - 0.5 | 0;\n      }\n\n      return outputfDCTQuant;\n    } //-------------------------------------------------------------------------------------------\n    // chunk writing routines\n\n\n    function writeAPP0() {\n      bitwriter.putshort(0xFFE0); // marker\n\n      bitwriter.putshort(16); // length\n\n      bitwriter.putbyte(0x4A); // J\n\n      bitwriter.putbyte(0x46); // F\n\n      bitwriter.putbyte(0x49); // I\n\n      bitwriter.putbyte(0x46); // F\n\n      bitwriter.putbyte(0); // = \"JFIF\"'\\0'\n\n      bitwriter.putbyte(1); // versionhi\n\n      bitwriter.putbyte(1); // versionlo\n\n      bitwriter.putbyte(0); // xyunits\n\n      bitwriter.putshort(1); // xdensity\n\n      bitwriter.putshort(1); // ydensity\n\n      bitwriter.putbyte(0); // thumbnwidth\n\n      bitwriter.putbyte(0); // thumbnheight\n    } // width:int, height:int\n\n\n    function writeSOF0(width, height, _444) {\n      bitwriter.putshort(0xFFC0); // marker\n\n      bitwriter.putshort(17); // length, truecolor YUV JPG\n\n      bitwriter.putbyte(8); // precision\n\n      bitwriter.putshort(height);\n      bitwriter.putshort(width);\n      bitwriter.putbyte(3); // nrofcomponents\n\n      bitwriter.putbyte(1); // IdY. id of Y \n\n      bitwriter.putbyte(_444 ? 0x11 : 0x22); // HVY. sampling factor horizontal Y  | sampling factor vertical Y\n\n      bitwriter.putbyte(0); // QTY. quantization table table  \n\n      bitwriter.putbyte(2); // IdU \n\n      bitwriter.putbyte(_444 ? 0x11 : 0x11); // HVU sampling factor horizontal U  | sampling factor vertical U. 0x11 -> 4:4:4, 0x22 -> 4:2:0\n\n      bitwriter.putbyte(1); // QTU\n\n      bitwriter.putbyte(3); // IdV\n\n      bitwriter.putbyte(_444 ? 0x11 : 0x11); // HVV sampling factor horizontal V  | sampling factor vertical V. 0x11 -> 4:4:4, 0x22 -> 4:2:0\n\n      bitwriter.putbyte(1); // QTV\n    }\n\n    function writeDQT() {\n      bitwriter.putshort(0xFFDB); // marker\n\n      bitwriter.putshort(132); // length\n\n      bitwriter.putbyte(0);\n      var i;\n      var I64 = 64;\n\n      for (i = 0; i < I64; ++i) bitwriter.putbyte(YTable[i]);\n\n      bitwriter.putbyte(1);\n\n      for (i = 0; i < I64; ++i) bitwriter.putbyte(UVTable[i]);\n    }\n\n    function writeDHT() {\n      bitwriter.putshort(0xFFC4); // marker\n\n      bitwriter.putshort(0x01A2); // length\n\n      bitwriter.putbyte(0); // HTYDCinfno\n\n      var i;\n      var I11 = 11;\n      var I16 = 16;\n      var I161 = 161;\n\n      for (i = 0; i < I16; ++i) {\n        bitwriter.putbyte(std_dc_luminance_nrcodes[i + 1]);\n      }\n\n      for (i = 0; i <= I11; ++i) bitwriter.putbyte(std_dc_luminance_values[i]);\n\n      bitwriter.putbyte(0x10); // HTYACinfo\n\n      for (i = 0; i < I16; ++i) bitwriter.putbyte(std_ac_luminance_nrcodes[i + 1]);\n\n      for (i = 0; i <= I161; ++i) bitwriter.putbyte(std_ac_luminance_values[i]);\n\n      bitwriter.putbyte(1); // HTUDCinfo\n\n      for (i = 0; i < I16; ++i) bitwriter.putbyte(std_dc_chrominance_nrcodes[i + 1]);\n\n      for (i = 0; i <= I11; ++i) bitwriter.putbyte(std_dc_chrominance_values[i]);\n\n      bitwriter.putbyte(0x11); // HTUACinfo\n\n      for (i = 0; i < I16; ++i) bitwriter.putbyte(std_ac_chrominance_nrcodes[i + 1]);\n\n      for (i = 0; i <= I161; ++i) bitwriter.putbyte(std_ac_chrominance_values[i]);\n    }\n\n    function writeSOS() {\n      bitwriter.putshort(0xFFDA); // marker\n\n      bitwriter.putshort(12); // length\n\n      bitwriter.putbyte(3); // nrofcomponents\n\n      bitwriter.putbyte(1); // IdY\n\n      bitwriter.putbyte(0); // HTY\n\n      bitwriter.putbyte(2); // IdU\n\n      bitwriter.putbyte(0x11); // HTU\n\n      bitwriter.putbyte(3); // IdV\n\n      bitwriter.putbyte(0x11); // HTV\n\n      bitwriter.putbyte(0); // Ss\n\n      bitwriter.putbyte(0x3f); // Se\n\n      bitwriter.putbyte(0); // Bf\n    }\n\n    function writeEOI() {\n      bitwriter.align();\n      bitwriter.putshort(0xFFD9); //EOI\n\n      bitwriter.end();\n    } //--------------------------------------------------------------------\n    // Block Processing\n\n\n    function huffman_extend(mag, size) {\n      return mag < 1 << size - 1 ? mag + ((-1 << size) + 1) : mag;\n    }\n\n    function huffman_compact(mag, size) {\n      return mag < 0 ? mag + (1 << size) - 1 : mag;\n    }\n\n    function log2(x, res) {\n      res = 0;\n\n      while (x != 0) {\n        x >>= 1;\n        res++;\n      }\n\n      return res;\n    }\n\n    function abs(x) {\n      return x > 0 ? x : -x;\n    }\n    /** \n     * double CDU[]\n     * double fdtbl[]\n     * double DC\n     * BitString HTDC[]\n     * BitString HTAC[]\n     *\n     * Returns double\n     */\n\n\n    function processDU(CDU, fdtbl, DC, HTDC, HTAC) {\n      var DU_DCT = fDCTQuant(CDU, fdtbl);\n      var dc_diff; //int\n\n      var last_dc; // double\n      // output\n      // DC Bits\n\n      dc_diff = DU_DCT[0] - DC | 0;\n      last_dc = DU_DCT[0]; ///////////////////////\n      //DC CODING\n      // DC Size\n\n      var dc_size = 0,\n          diffabs = abs(dc_diff);\n      dc_size = log2(diffabs, dc_size);\n      bitwriter.putbits(HTDC[dc_size].val, HTDC[dc_size].len); // DC Bits\n\n      if (dc_size) {\n        dc_diff = huffman_compact(dc_diff, dc_size);\n        bitwriter.putbits(dc_diff, dc_size);\n      } ////////////////////\n      // AC CODING\n\n\n      var run;\n      var accoeff; //int16\n\n      var lastcoeff_pos = 0; //ui32\n\n      var maxcoeff = 64; // int\n\n      var i = 0;\n\n      while (1) {\n        // find next coefficient to code\n        i++;\n\n        for (run = 0; (accoeff = DU_DCT[jpeg_natural_order[i]]) == 0 && i < maxcoeff; i++, run++);\n\n        if (i >= maxcoeff) break; // Code runs greater than 16\n\n        while (run >= 16) {\n          // Write value\n          bitwriter.putbits(HTAC[0xf0].val, HTAC[0xf0].len);\n          run -= 16;\n        } // AC Size\n\n\n        var acsize = 0;\n        var acabs = abs(accoeff);\n        acsize = log2(acabs, acsize); // Write value\n\n        var hv = run << 4 | acsize;\n        bitwriter.putbits(HTAC[hv].val, HTAC[hv].len); // AC Bits\n\n        if (acsize) {\n          accoeff = huffman_compact(accoeff, acsize);\n          bitwriter.putbits(accoeff, acsize);\n        } // Keep position of last encoded coefficient\n\n\n        lastcoeff_pos = i;\n      } // Write EOB \n\n\n      if (lastcoeff_pos != 63) bitwriter.putbits(HTAC[0].val, HTAC[0].len);\n      return last_dc;\n    }\n    /**\n     * xpos:int\n     * ypos:int\n     *\n     * This functions calls the getpixels() object to obtain an McuImg object that contains\n     * an Uint8Array() buffer with pixel data in RGBA byte order. McuImg includes an offset\n     * to the beginning of the requested area as well as the stride in bytes.\n     *\n     * The method converts the RGB pixels into YUV ready for further processing. The destination\n     * pixels are written to the local private PTTJPEG fields YDU,UDU,VDU\n     *\n     */\n\n\n    function rgb2yuv_444(xpos, ypos, YDU, UDU, VDU) {\n      // RGBA format in unpacked bytes\n      var mcuimg = inputImage.getPixels(xpos, ypos, 8, 8); // DEBUGMSG(sprintf(\"getpixels() xpos:%d ypos:%d retw:%d reth:%d\", xpos, ypos, mcuimg.w, mcuimg.h ));\n\n      var buf = mcuimg.buf;\n      var pel;\n      var P = 0;\n      var x,\n          y,\n          off,\n          off_1 = 0,\n          R,\n          G,\n          B;\n\n      if (mcuimg.w == 8 && mcuimg.h == 8) {\n        /* block is 8x8 */\n        for (y = 0; y < 8; y++) {\n          for (x = 0; x < 8; x++) {\n            off = mcuimg.offset + y * mcuimg.stride + x * 4;\n            R = buf[off];\n            G = buf[off + 1];\n            B = buf[off + 2];\n            YDU[off_1] = 0.29900 * R + 0.58700 * G + 0.11400 * B - 0x80;\n            UDU[off_1] = -0.16874 * R + -0.33126 * G + 0.50000 * B;\n            VDU[off_1++] = 0.50000 * R + -0.41869 * G + -0.08131 * B;\n          }\n        }\n      } else {\n        /* we separate the borderline conditions to avoid having to branch out\n         * on every mcu */\n        for (y = 0; y < 8; y++) {\n          for (x = 0; x < 8; x++) {\n            var xx = x,\n                yy = y;\n\n            if (x >= mcuimg.w) {\n              xx = mcuimg.w - 1;\n            }\n\n            if (y >= mcuimg.h) {\n              yy = mcuimg.h - 1;\n            }\n\n            off = mcuimg.offset + yy * mcuimg.stride + xx * 4;\n            R = buf[off];\n            G = buf[off + 1];\n            B = buf[off + 2];\n            YDU[off_1] = 0.29900 * R + 0.58700 * G + 0.11400 * B - 0x80;\n            UDU[off_1] = -0.16874 * R + -0.33126 * G + 0.50000 * B;\n            VDU[off_1++] = 0.50000 * R + -0.41869 * G + -0.08131 * B;\n          }\n        }\n      }\n    } // takes 4 DU units and downsamples them 2:1 using simple averaging\n\n\n    function downsample_8_line(DU, outoff, DU1, DU2, inoff) {\n      DU[outoff + 0] = DU1[inoff + 00] + DU1[inoff + 01] + DU1[inoff + 08] + DU1[inoff + 09] + 2 >> 2;\n      DU[outoff + 1] = DU1[inoff + 02] + DU1[inoff + 03] + DU1[inoff + 10] + DU1[inoff + 11] + 2 >> 2;\n      DU[outoff + 2] = DU1[inoff + 04] + DU1[inoff + 05] + DU1[inoff + 12] + DU1[inoff + 13] + 2 >> 2;\n      DU[outoff + 3] = DU1[inoff + 06] + DU1[inoff + 07] + DU1[inoff + 14] + DU1[inoff + 15] + 2 >> 2;\n      DU[outoff + 4] = DU2[inoff + 00] + DU2[inoff + 01] + DU2[inoff + 08] + DU2[inoff + 09] + 2 >> 2;\n      DU[outoff + 5] = DU2[inoff + 02] + DU2[inoff + 03] + DU2[inoff + 10] + DU2[inoff + 11] + 2 >> 2;\n      DU[outoff + 6] = DU2[inoff + 04] + DU2[inoff + 05] + DU2[inoff + 12] + DU2[inoff + 13] + 2 >> 2;\n      DU[outoff + 7] = DU2[inoff + 06] + DU2[inoff + 07] + DU2[inoff + 14] + DU2[inoff + 15] + 2 >> 2;\n    }\n\n    function downsample_DU(DU, DU1, DU2, DU3, DU4) {\n      downsample_8_line(DU, 0, DU1, DU2, 0);\n      downsample_8_line(DU, 8, DU1, DU2, 16);\n      downsample_8_line(DU, 16, DU1, DU2, 32);\n      downsample_8_line(DU, 24, DU1, DU2, 48);\n      downsample_8_line(DU, 32, DU3, DU4, 0);\n      downsample_8_line(DU, 40, DU3, DU4, 16);\n      downsample_8_line(DU, 48, DU3, DU4, 32);\n      downsample_8_line(DU, 56, DU3, DU4, 48);\n    }\n    /**\n     * xpos:int\n     * ypos:int\n     *\n     * This functions calls the getpixels() object to obtain an McuImg object that contains\n     * an Uint8Array() buffer with pixel data in RGBA byte order. McuImg includes an offset\n     * to the beginning of the requested area as well as the stride in bytes.\n     *\n     * The method converts the RGB pixels into YUV ready for further processing. The destination\n     * pixels are written to the local private PTTJPEG fields YDU[2,3,4],UDU,VDU\n     *\n     * \n     * output: for luma blocks. YDU, YDU2, YDU3, YDU4\n     *         2 chroma blocks, UDU, VDU\n     *\n     */\n\n\n    function rgb2yuv_420(xpos, ypos) {\n      rgb2yuv_444(xpos, ypos, YDU, UDU1, VDU1);\n      rgb2yuv_444(xpos + 8, ypos, YDU2, UDU2, VDU2);\n      rgb2yuv_444(xpos, ypos + 8, YDU3, UDU3, VDU3);\n      rgb2yuv_444(xpos + 8, ypos + 8, YDU4, UDU4, VDU4);\n      downsample_DU(UDU, UDU1, UDU2, UDU3, UDU4);\n      downsample_DU(VDU, VDU1, VDU2, VDU3, VDU4);\n    } //--------------------------------------------------------------------\n    // exported functions\n\n\n    this.version = function () {\n      return \"petitJPEG 0.4\";\n    };\n\n    this.setVerbosity = function (flagVerbose) {\n      flagQuiet = !flagVerbose;\n    };\n\n    this.ByteWriter = function () {\n      var bufsize = 1024 * 1024 * 10;\n      var buf = new Uint8Array(bufsize);\n      var bufptr = 0;\n      /**\n       * Base64 encoding.\n       * input:Uint8Array \n       * output:String\n       */\n\n      var base64EncodeFromUint8Array = function (input) {\n        var _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        var output = \"\";\n        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n        var i = 0;\n\n        while (i < input.length) {\n          chr1 = input[i++];\n          chr2 = i < input.length ? input[i++] : 0;\n          chr3 = i < input.length ? input[i++] : 0;\n          enc1 = chr1 >>> 2;\n          enc2 = (chr1 & 3) << 4 | chr2 >>> 4;\n          enc3 = (chr2 & 15) << 2 | chr3 >>> 6;\n          enc4 = chr3 & 63;\n\n          if (i >= input.length) {\n            var mod = input.length % 3;\n\n            if (mod == 2) {\n              enc4 = 64;\n            }\n\n            if (mod == 1) {\n              enc3 = enc4 = 64;\n            }\n          }\n\n          output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);\n        }\n\n        return output;\n      }; // writes count bytes starting at start position from array\n      // array is Uint8Array()\n\n\n      this.write = function (array, start, count) {\n        for (var i = 0; i < count && bufptr + i < bufsize; i++) {\n          buf[bufptr + i] = array[start + i];\n        }\n\n        bufptr += i;\n      };\n      /**\n       * returns a base64 string with the data in the buffer\n       */\n\n\n      this.getBase64Data = function () {\n        return base64EncodeFromUint8Array(buf.subarray(0, bufptr));\n      };\n\n      this.getImgUrl = function () {\n        return \"data:image/jpeg;base64,\" + this.getBase64Data();\n      };\n\n      this.getWrittenBytes = function () {\n        return bufptr;\n      };\n    };\n\n    this.dlog = DEBUGMSG;\n\n    this.pttImage = function (imageData) {\n      var width = imageData.width;\n      var height = imageData.height;\n      var id = imageData;\n      var buf = imageData.data; // Uint8Array()\n\n      this.width = width;\n      this.height = height;\n\n      this.mcuPixels = function () {\n        this.buf = null;\n        this.offset = 0;\n        this.stride = 0;\n        this.xpos = 0;\n        this.ypos = 0;\n        this.w = 0;\n        this.h = 0;\n      };\n      /**\n       * returns an mcuPixels object with data for a\n       * specific mcu\n       */\n\n\n      this.getPixels = function (xpos, ypos, w, h) {\n        // only valid for RGBA data \n        var ret = new this.mcuPixels();\n        ret.buf = buf;\n        ret.stride = width * 4;\n        ret.offset = ypos * ret.stride + xpos * 4;\n        ret.xpos = xpos;\n        ret.ypos = ypos;\n        ret.w = xpos + w > width ? width - xpos : w;\n        ret.h = ypos + h > height ? height - ypos : h;\n        return ret;\n      };\n    };\n\n    var encodetime = 0;\n\n    this.getEncodeTime = function () {\n      return encodetime;\n    };\n    /**\n     * The encode function stub\n     * \n     * quality:int 0-100\n     * img: pttJPEGImage object. The image object to encode\n     * bw: byteWriter object. The object that will be used to write the compressed data\n     * \n     * uses auto for chroma sampling\n     * \n     */\n\n\n    this.encode = function (quality, img, bw) {\n      this.encode_ext(quality, img, bw, \"auto\");\n    };\n    /**\n     * The encode function\n     * \n     * quality:int 0-100\n     * img: pttJPEGImage object. The image object to encode\n     * bw: byteWriter object. The object that will be used to write the compressed data\n     * sr: \"444\" for 4:4:4 chroma sampling \"420\" for 4:2:0 chroma sampling, \"auto\" for auto\n     *\n     * \n     */\n\n\n    this.encode_ext = function (quality, img, bw, sr) {\n      if (!img) DEBUGMSG(\"input image not provided. aborting encode\");\n      if (!bw) DEBUGMSG(\"byte writer not provided. aborting encode\");\n      var _444 = true;\n\n      if (sr == \"auto\") {\n        if (quality > 50) {\n          _444 = true;\n        } else {\n          _444 = false;\n        }\n      } // DEBUGMSG(sprintf(\"pttjpeg_encode  qual:%d,  %dx%d, %s:%s\", quality ,img.width,img.height, sr, _444 ? \"4:4:4\": \"4:2:0\" ));\n\n\n      var start = new Date().getTime();\n      init_quality_settings(quality);\n      /* start the bitwriter */\n\n      bitwriter = new BitWriter();\n      bitwriter.setByteWriter(bw);\n      /* save copy of input image */\n\n      inputImage = img;\n      /* write headers out */\n\n      bitwriter.putshort(0xFFD8); // SOI\n\n      writeAPP0();\n      writeDQT();\n      writeSOF0(img.width, img.height, _444);\n      writeDHT();\n      writeSOS();\n      DEBUGMSG(\"wrote headers\");\n      /* MCU(minimum coding units) are 8x8 blocks for now*/\n\n      var DCU = 0,\n          DCY = 0,\n          DCV = 0;\n      var width = img.width;\n      var height = img.height;\n      var ypos, xpos;\n      var mcucount = 0;\n\n      if (_444) {\n        // 4:4:4 \n        for (ypos = 0; ypos < height; ypos += 8) {\n          for (xpos = 0; xpos < width; xpos += 8) {\n            rgb2yuv_444(xpos, ypos, YDU, UDU, VDU);\n            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\n            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\n          }\n        }\n      } else {\n        // 4:2:0 \n        for (ypos = 0; ypos < height; ypos += 16) {\n          for (xpos = 0; xpos < width; xpos += 16) {\n            rgb2yuv_420(xpos, ypos);\n            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n            DCY = processDU(YDU2, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n            DCY = processDU(YDU3, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n            DCY = processDU(YDU4, fdtbl_Y, DCY, YDC_HT, YAC_HT);\n            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);\n            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);\n          }\n        }\n      }\n\n      writeEOI(); // DEBUGMSG(sprintf(\"wrote EOI. %d bytes written\", bitwriter.getWrittenBytes() ));\n\n      var stop = new Date().getTime();\n      encodetime = stop - start; // DEBUGMSG(sprintf(\"%d ms\", encodetime));\n    };\n    /**\n     * Setup the encoding envinment object\n     */\n\n\n    var startup = function () {\n      init_huffman_tables();\n    }();\n  }\n\n  if (true) {\n    //  Inside CommonJS / NodeJS.\n    exports.pttJPEG = PTTJPEG;\n  } else { var encoder; }\n})();\n\n//# sourceURL=webpack:///./src/js/pttjpeg.js?");

/***/ })

/******/ });